
You are an expert full-stack developer and code auditor with deep knowledge of React (JS/JSX), Express.js, and MongoDB. The codebase below is a ~10k-line MVP called GitStatus, which analyzes GitHub commit history to generate AI-powered reports. I’ve made significant changes, including removing hardcoded API keys, adding PDF watermarking, and separating concerns into smaller, single-duty units. Note: The app is likely broken and won’t deploy due to untested changes, but the code is cleaner and more modular. I’ve included the current Claude Bible (`BIBLE.md`), app docs (`APP_DOCS.md`), and additional documentation for reference. This is a sample run to calibrate token usage—summarize the codebase structure and estimate its size in lines.

---

---
File: frontend/README.md
---
# Getting Started with Create React App

This project was bootstrapped with [Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can `eject` at any time. This command will remove the single build dependency from your project.

Instead, it will copy all the configuration files and the transitive dependencies (webpack, Babel, ESLint, etc) right into your project so you have full control over them. All of the commands except `eject` will still work, but they will point to the copied scripts so you can tweak them. At this point you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for small and middle deployments, and you shouldn't feel obligated to use this feature. However we understand that this tool wouldn't be useful if you couldn't customize it when you are ready for it.

## Learn More

You can learn more in the [Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here: [https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here: [https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here: [https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here: [https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here: [https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here: [https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)


---
File: frontend/package.json
---
{
  "name": "gitstatus-frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@date-io/date-fns": "^2.16.0",
    "@emotion/react": "^11.10.6",
    "@emotion/styled": "^11.10.6",
    "@mui/icons-material": "^5.11.16",
    "@mui/lab": "^5.0.0-alpha.127",
    "@mui/material": "^5.12.1",
    "@mui/x-date-pickers": "^6.2.1",
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.3.6",
    "date-fns": "^2.29.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.10.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "NODE_OPTIONS=--no-deprecation react-scripts start",
    "build": "NODE_OPTIONS=--no-deprecation react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "proxy": "http://localhost:5000"
}


---
File: frontend/src/index.js
---
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { LocalizationProvider } from '@mui/x-date-pickers';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <LocalizationProvider dateAdapter={AdapterDateFns}>
      <App />
    </LocalizationProvider>
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();


---
File: frontend/src/components/Modals/ViewCommits/ViewCommitsModal.css
---
.modal-title {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.action-buttons {
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 12px;
}

.commit-list-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
  background-color: #f5f5f5;
  border-radius: 4px;
}

.commits-container {
  overflow-y: auto;
  flex-grow: 1;
}

.commit-item {
  transition: background-color 0.2s ease-in-out;
}

.commit-item:hover {
  background-color: rgba(0, 0, 0, 0.04);
}

.commit-details {
  margin-left: 32px;
}

.file-item {
  border-left: 2px solid #e0e0e0;
  margin-left: 16px;
  padding-left: 16px;
}

.file-item:hover {
  background-color: rgba(0, 0, 0, 0.02);
}

.diff-container {
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  overflow: hidden;
  margin-top: 8px;
  margin-bottom: 8px;
}

.select-all-container {
  display: flex;
  align-items: center;
}

.error-message {
  color: #d32f2f;
  margin: 8px 0;
}

.usage-info {
  margin-right: 16px;
  font-size: 0.875rem;
  color: rgba(0, 0, 0, 0.6);
}

.loading-indicator {
  margin-left: 8px;
}


---
File: frontend/src/components/Modals/ViewCommits/index.js
---
export { default } from './ViewCommitsModalComponent';


---
File: frontend/src/components/Modals/ViewCommits/ViewCommitsModal.js
---
import React, { useState, useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import api from '../../../services/api';
import { useModal } from '../../../contexts/ModalContext';
import ViewCommitsModalComponent from './ViewCommitsModal';

const ViewCommitsModal = () => {
  const navigate = useNavigate();
  const {
    modalState,
    closeModals,
    openCreateReportModal,
    updateSelectedCommits
  } = useModal();

  const {
    viewCommitsOpen,
    reportData,
    commits,
    selectedCommits: initialSelectedCommits
  } = modalState;

  // Local state
  const [selectedCommits, setSelectedCommits] = useState(initialSelectedCommits || []);
  const [expandedCommit, setExpandedCommit] = useState(null);
  const [expandedFiles, setExpandedFiles] = useState({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [userStats, setUserStats] = useState(null);
  const [loadingStats, setLoadingStats] = useState(true);

  // Fetch user stats when component mounts
  useEffect(() => {
    const fetchUserStats = async () => {
      try {
        const response = await api.getUserStats();
        setUserStats(response.data);
      } catch (err) {
        console.error('Error fetching user stats:', err);
        setError('Failed to load user limits. Please try again.');
      } finally {
        setLoadingStats(false);
      }
    };

    if (viewCommitsOpen) {
      fetchUserStats();
    }
  }, [viewCommitsOpen]);

  // Toggle a commit's selection status
  const toggleCommitSelection = (commitSha) => {
    setSelectedCommits(prev => {
      if (prev.includes(commitSha)) {
        return prev.filter(sha => sha !== commitSha);
      } else {
        return [...prev, commitSha];
      }
    });
  };

  // Toggle select all commits
  const toggleSelectAllCommits = () => {
    if (selectedCommits.length === commits.length) {
      // Deselect all
      setSelectedCommits([]);
    } else {
      // Select all
      setSelectedCommits(commits.map(commit => commit.sha));
    }
  };

  // Toggle expanded commit for viewing diffs
  const toggleExpandCommit = (commitSha) => {
    setExpandedCommit(expandedCommit === commitSha ? null : commitSha);
  };

  // Toggle expanded file in a commit
  const toggleExpandFile = (fileId) => {
    setExpandedFiles(prev => ({
      ...prev,
      [fileId]: !prev[fileId]
    }));
  };

  // Go back to create report modal
  const handleBackToForm = () => {
    // Save selected commits to context
    updateSelectedCommits(selectedCommits);
    openCreateReportModal();
  };

  // Handle closing the modal
  const handleClose = () => {
    updateSelectedCommits(selectedCommits);
    closeModals();
  };

  // Generate report from selected commits
  const generateReport = async () => {
    if (!selectedCommits.length) {
      setError('Please select at least one commit');
      return;
    }

    try {
      setLoading(true);
      setError(null);

      // First get detailed commit info including branch details
      const commitsWithInfo = await api.getCommitInfo({
        repository: reportData.repository,
        commitIds: selectedCommits
      });

      // Generate report with selected commits
      const reportParams = {
        repository: reportData.repository,
        branches: reportData.branches.map(branch => 
          typeof branch === 'object' ? branch.name : branch
        ),
        authors: reportData.authors,
        startDate: reportData.startDate ? reportData.startDate.toISOString() : null,
        endDate: reportData.endDate ? reportData.endDate.toISOString() : null,
        title: reportData.title || `${reportData.repository} Report`,
        includeCode: reportData.includeCode,
        commitIds: selectedCommits
      };

      const report = await api.generateReport(reportParams);
      
      // Close modal and navigate to the report view page
      closeModals();
      navigate(`/reports/${report.reportId || report.id}`);
    } catch (error) {
      console.error('Error generating report:', error);
      setError('Failed to generate report. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <ViewCommitsModalComponent
      open={viewCommitsOpen}
      commits={commits || []}
      selectedCommits={selectedCommits}
      expandedCommit={expandedCommit}
      expandedFiles={expandedFiles}
      loading={loading}
      error={error}
      userStats={userStats}
      loadingStats={loadingStats}
      onClose={handleClose}
      onBack={handleBackToForm}
      onToggleCommitSelection={toggleCommitSelection}
      onToggleSelectAllCommits={toggleSelectAllCommits}
      onToggleExpandCommit={toggleExpandCommit}
      onToggleExpandFile={toggleExpandFile}
      onGenerateReport={generateReport}
    />
  );
};

export default ViewCommitsModal;


---
File: frontend/src/components/Modals/ViewCommits/ViewCommitsModal.jsx
---
import React from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Typography,
  Button,
  Box,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Checkbox,
  Collapse,
  Divider,
  IconButton,
  CircularProgress,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  Tooltip
} from '@mui/material';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import CodeIcon from '@mui/icons-material/Code';
import CloseIcon from '@mui/icons-material/Close';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import DiffViewer from '../../DiffViewer';
import './ViewCommitsModalComponent.css';

const ViewCommitsModalComponent = ({
  open,
  commits = [],
  selectedCommits = [],
  expandedCommit,
  expandedFiles = {},
  loading = false,
  error = null,
  userStats = null,
  loadingStats = false,
  onClose,
  onBack,
  onToggleCommitSelection,
  onToggleSelectAllCommits,
  onToggleExpandCommit,
  onToggleExpandFile,
  onGenerateReport
}) => {
  // Calculate if all commits are selected
  const allCommitsSelected = commits.length > 0 && selectedCommits.length === commits.length;
  
  // Format date for display
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleString();
  };
  
  // Determine report type and button state based on selected commits
  const getReportTypeInfo = () => {
    if (!userStats?.plan?.limits) return { disabled: true, message: 'Loading plan limits...' };

    const commitCount = selectedCommits.length;
    const { commitsPerStandardReport, commitsPerLargeReport } = userStats.plan.limits;

    if (commitCount === 0) {
      return { disabled: true, message: 'Select commits to generate a report' };
    }

    if (commitCount <= commitsPerStandardReport) {
      return { disabled: false, message: 'Generate Standard Report' };
    }

    if (commitCount <= commitsPerLargeReport) {
      return { disabled: false, message: 'Generate Large Report' };
    }

    return {
      disabled: true,
      message: `Exceeds maximum commits allowed (${commitsPerLargeReport} commits)`
    };
  };

  // Get usage info for current report type
  const getUsageInfo = () => {
    if (!userStats?.plan?.limits || !userStats?.currentUsage) return null;

    const commitCount = selectedCommits.length;
    const { commitsPerStandardReport, commitsPerLargeReport } = userStats.plan.limits;
    const { reportsGenerated } = userStats.currentUsage;

    if (commitCount === 0) return null;

    const isStandard = commitCount <= commitsPerStandardReport;
    const current = isStandard ? reportsGenerated.standard || 0 : reportsGenerated.large || 0;
    const limit = isStandard ? userStats.plan.limits.reportsPerMonth : userStats.plan.limits.reportsPerMonth;

    return {
      current,
      limit,
      isStandard
    };
  };

  const reportTypeInfo = getReportTypeInfo();
  const usageInfo = getUsageInfo();

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="lg"
      fullWidth
      PaperProps={{
        sx: {
          borderRadius: 2,
          boxShadow: '0 8px 32px rgba(0,0,0,0.2)',
          bgcolor: 'background.paper',
          maxHeight: '90vh',
          height: '90vh'
        }
      }}
    >
      <DialogTitle className="modal-title">
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Typography variant="h5" component="div">Select Commits</Typography>
          <Typography variant="body2" color="text.secondary" sx={{ ml: 2 }}>
            {selectedCommits.length} of {commits.length} commits selected
          </Typography>
        </Box>
        <Box>
          <Button
            startIcon={<ArrowBackIcon />}
            onClick={onBack}
            sx={{ mr: 1 }}
          >
            Back to Form
          </Button>
          <IconButton onClick={onClose} size="small">
            <CloseIcon />
          </IconButton>
        </Box>
      </DialogTitle>
      
      <DialogContent sx={{ display: 'flex', flexDirection: 'column', p: 0, overflow: 'hidden' }}>
        <Box className="commit-list-header">
          <Box className="select-all-container">
            <Checkbox
              checked={allCommitsSelected}
              indeterminate={selectedCommits.length > 0 && selectedCommits.length < commits.length}
              onChange={onToggleSelectAllCommits}
              disabled={commits.length === 0}
            />
            <Typography variant="body2">
              {allCommitsSelected ? 'Deselect All' : 'Select All'}
            </Typography>
          </Box>
        </Box>
        
        {error && (
          <Box px={3} py={1}>
            <Typography className="error-message">{error}</Typography>
          </Box>
        )}
        
        <Box className="commits-container">
          <List sx={{ p: 0 }}>
            {commits.map((commit) => (
              <React.Fragment key={commit.sha}>
                <ListItem className="commit-item" sx={{ py: 1 }}>
                  <ListItemIcon sx={{ minWidth: 40 }}>
                    <Checkbox
                      checked={selectedCommits.includes(commit.sha)}
                      onChange={() => onToggleCommitSelection(commit.sha)}
                      edge="start"
                    />
                  </ListItemIcon>
                  
                  <ListItemText
                    primary={
                      <Box sx={{ display: 'flex', alignItems: 'center' }}>
                        <Typography variant="body1" component="span" fontWeight="500" sx={{ mr: 1 }}>
                          {commit.message.split('\n')[0]}
                        </Typography>
                        <Typography variant="body2" color="text.secondary" component="span">
                          {commit.sha.substring(0, 7)}
                        </Typography>
                      </Box>
                    }
                    secondary={
                      <Box sx={{ mt: 0.5 }}>
                        <Typography variant="body2" component="span">
                          {commit.author?.name || "Unknown"} • {formatDate(commit.date)}
                        </Typography>
                        <Typography variant="body2" component="div" color="text.secondary" sx={{ mt: 0.5 }}>
                          <Button
                            size="small"
                            startIcon={<CodeIcon />}
                            onClick={() => onToggleExpandCommit(commit.sha)}
                            sx={{ p: 0, minWidth: 'auto', textTransform: 'none' }}
                          >
                            {commit.files ? `${commit.files.length} files changed` : 'View changes'}
                            <ExpandMoreIcon
                              sx={{
                                ml: 0.5,
                                transform: expandedCommit === commit.sha ? 'rotate(180deg)' : 'rotate(0deg)',
                                transition: 'transform 0.2s'
                              }}
                            />
                          </Button>
                        </Typography>
                      </Box>
                    }
                  />
                </ListItem>
                
                {commit.files && (
                  <Collapse in={expandedCommit === commit.sha} timeout="auto" unmountOnExit>
                    <Box className="commit-details">
                      <List disablePadding>
                        {commit.files.map((file, fileIndex) => (
                          <React.Fragment key={`${commit.sha}-${file.filename}`}>
                            <Accordion
                              expanded={expandedFiles[`${commit.sha}-${file.filename}`] || false}
                              onChange={() => onToggleExpandFile(`${commit.sha}-${file.filename}`)}
                              elevation={0}
                              disableGutters
                              sx={{ backgroundColor: 'transparent' }}
                            >
                              <AccordionSummary
                                expandIcon={<ExpandMoreIcon />}
                                sx={{ p: 0 }}
                              >
                                <Typography variant="body2">
                                  {file.filename} {' '}
                                  <Typography component="span" color="text.secondary" variant="body2">
                                    ({file.additions} additions, {file.deletions} deletions)
                                  </Typography>
                                </Typography>
                              </AccordionSummary>
                              <AccordionDetails sx={{ p: 0 }}>
                                <Box className="diff-container">
                                  <DiffViewer
                                    oldCode={file.patch ? file.patch.split('\n').filter(line => 
                                      line.startsWith('-') && !line.startsWith('---')
                                    ).map(line => line.substring(1)).join('\n') : ''}
                                    newCode={file.patch ? file.patch.split('\n').filter(line => 
                                      line.startsWith('+') && !line.startsWith('+++')
                                    ).map(line => line.substring(1)).join('\n') : ''}
                                    language={file.filename.split('.').pop()}
                                  />
                                </Box>
                              </AccordionDetails>
                            </Accordion>
                            {fileIndex < commit.files.length - 1 && <Divider sx={{ my: 1 }} />}
                          </React.Fragment>
                        ))}
                      </List>
                    </Box>
                  </Collapse>
                )}
                
                <Divider />
              </React.Fragment>
            ))}
            
            {commits.length === 0 && (
              <ListItem>
                <ListItemText
                  primary={
                    <Typography variant="body1" sx={{ textAlign: 'center', py: 4 }}>
                      No commits found that match your criteria.
                    </Typography>
                  }
                />
              </ListItem>
            )}
          </List>
        </Box>
      </DialogContent>
      
      <DialogActions sx={{ px: 3, py: 2, justifyContent: 'space-between' }}>
        <Box>
          {usageInfo && (
            <Typography className="usage-info">
              {usageInfo.isStandard ? 'Standard' : 'Large'} reports: {usageInfo.current}/{usageInfo.limit}
            </Typography>
          )}
        </Box>
        <Box className="action-buttons">
          <Button onClick={onClose} color="inherit">
            Cancel
          </Button>
          
          <Tooltip title={reportTypeInfo.disabled ? reportTypeInfo.message : ''}>
            <span>
              <Button
                onClick={onGenerateReport}
                variant="contained"
                color="primary"
                disabled={loading || reportTypeInfo.disabled || loadingStats}
              >
                {loading ? (
                  <>
                    Generating
                    <CircularProgress size={20} className="loading-indicator" />
                  </>
                ) : (
                  reportTypeInfo.message
                )}
              </Button>
            </span>
          </Tooltip>
        </Box>
      </DialogActions>
    </Dialog>
  );
};

export default ViewCommitsModalComponent;


---
File: frontend/src/components/Modals/CreateReport/index.js
---
export { default } from './CreateReportModalComponent';


---
File: frontend/src/components/Modals/CreateReport/CreateReportModal.jsx
---
import React from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions,
  Typography, 
  TextField, 
  Button, 
  Grid, 
  CircularProgress, 
  FormControl, 
  Chip, 
  Autocomplete, 
  FormHelperText, 
  Box, 
  Checkbox,
  IconButton
} from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import { DatePicker } from '@mui/x-date-pickers/DatePicker';
import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import CloseIcon from '@mui/icons-material/Close';
import './CreateReportModalComponent.css';

const CreateReportModalComponentTemplate = ({
  open,
  onClose,
  formData,
  handleInputChange,
  handleRepositorySelect,
  handleBranchesChange,
  handleAuthorsChange,
  handleDateChange,
  handleCheckboxChange,
  handleSubmit,
  validateForm,
  formSubmitted,
  error,
  repositoryValid,
  searching,
  searchQuery,
  setSearchQuery,
  searchResults,
  branches,
  availableAuthors,
  isLoadingAuthors,
  isLoadingDateRange,
  dateRange,
  loadingViewCommits
}) => {
  return (
    <Dialog 
      open={open} 
      onClose={onClose}
      maxWidth="md"
      fullWidth
    >
      <DialogTitle className="modal-title">
        <Typography variant="h6" className="modal-title-text">
          Create New Report
        </Typography>
        <IconButton 
          onClick={onClose}
          className="close-button"
          size="small"
        >
          <CloseIcon />
        </IconButton>
      </DialogTitle>
      
      <DialogContent dividers>
        <Grid container spacing={3}>
          {/* Repository Selection */}
          <Grid item xs={12}>
            <FormControl fullWidth className="form-field">
              <Autocomplete
                value={formData.repository}
                onChange={(event, newValue) => handleRepositorySelect(newValue)}
                inputValue={searchQuery}
                onInputChange={(event, newInputValue) => setSearchQuery(newInputValue)}
                options={searchResults}
                getOptionLabel={(option) => option}
                filterOptions={(x) => x} // Disable built-in filtering
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Repository"
                    variant="outlined"
                    error={formSubmitted && !repositoryValid}
                    helperText={formSubmitted && !repositoryValid ? "Please select a valid repository" : ""}
                    InputProps={{
                      ...params.InputProps,
                      endAdornment: (
                        <>
                          {searching && (
                            <CircularProgress
                              color="inherit"
                              size={20}
                              className="search-loading-indicator"
                            />
                          )}
                          {params.InputProps.endAdornment}
                        </>
                      ),
                    }}
                  />
                )}
              />
              <FormHelperText className="info-text">
                Search for a GitHub repository to analyze
              </FormHelperText>
            </FormControl>
          </Grid>

          {/* Branch Selection */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth className="form-field">
              <Autocomplete
                multiple
                value={formData.branches}
                onChange={(event, newValue) => handleBranchesChange(newValue)}
                options={branches}
                getOptionLabel={(option) => typeof option === 'object' ? option.name : option}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Branches"
                    variant="outlined"
                    error={formSubmitted && formData.branches.length === 0}
                    helperText={formSubmitted && formData.branches.length === 0 ? "Please select at least one branch" : ""}
                  />
                )}
                renderTags={(value, getTagProps) =>
                  value.map((option, index) => (
                    <Chip
                      label={typeof option === 'object' ? option.name : option}
                      {...getTagProps({ index })}
                      className="author-chip"
                    />
                  ))
                }
                disabled={!repositoryValid}
              />
              <FormHelperText className="info-text">
                Select branches to include in the report
              </FormHelperText>
            </FormControl>
          </Grid>

          {/* Author Selection */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth className="form-field">
              <Autocomplete
                multiple
                value={formData.authors}
                onChange={(event, newValue) => handleAuthorsChange(newValue)}
                options={availableAuthors}
                getOptionLabel={(option) => option}
                renderInput={(params) => (
                  <TextField
                    {...params}
                    label="Authors (optional)"
                    variant="outlined"
                    InputProps={{
                      ...params.InputProps,
                      endAdornment: (
                        <>
                          {isLoadingAuthors && (
                            <CircularProgress
                              color="inherit"
                              size={20}
                              className="loading-indicator"
                            />
                          )}
                          {params.InputProps.endAdornment}
                        </>
                      ),
                    }}
                  />
                )}
                renderTags={(value, getTagProps) =>
                  value.map((option, index) => (
                    <Chip
                      label={option}
                      {...getTagProps({ index })}
                      className="author-chip"
                    />
                  ))
                }
                disabled={!repositoryValid || formData.branches.length === 0 || isLoadingAuthors}
              />
              <FormHelperText className="info-text">
                Filter by specific authors (leave empty to include all)
              </FormHelperText>
            </FormControl>
          </Grid>

          {/* Date Range */}
          <Grid item xs={12} md={6}>
            <FormControl fullWidth className="form-field">
              <LocalizationProvider dateAdapter={AdapterDateFns}>
                <DatePicker
                  label="Start Date"
                  value={formData.startDate}
                  onChange={(newValue) => handleDateChange('startDate', newValue)}
                  minDate={dateRange?.firstCommitDate ? new Date(dateRange.firstCommitDate) : undefined}
                  maxDate={dateRange?.lastCommitDate ? new Date(dateRange.lastCommitDate) : undefined}
                  disabled={!repositoryValid || formData.branches.length === 0 || isLoadingDateRange}
                  className="date-picker-container"
                />
              </LocalizationProvider>
              
              {isLoadingDateRange ? (
                <Box className="date-range-indicator">
                  <CircularProgress size={14} className="loading-indicator" />
                  <Typography className="date-range-text">
                    Loading date range...
                  </Typography>
                </Box>
              ) : dateRange?.firstCommitDate ? (
                <FormHelperText className="info-text">
                  First commit: {new Date(dateRange.firstCommitDate).toLocaleDateString()}
                </FormHelperText>
              ) : null}
            </FormControl>
          </Grid>

          <Grid item xs={12} md={6}>
            <FormControl fullWidth className="form-field">
              <LocalizationProvider dateAdapter={AdapterDateFns}>
                <DatePicker
                  label="End Date"
                  value={formData.endDate}
                  onChange={(newValue) => handleDateChange('endDate', newValue)}
                  minDate={formData.startDate || (dateRange?.firstCommitDate ? new Date(dateRange.firstCommitDate) : undefined)}
                  maxDate={dateRange?.lastCommitDate ? new Date(dateRange.lastCommitDate) : undefined}
                  disabled={!repositoryValid || formData.branches.length === 0 || isLoadingDateRange}
                  className="date-picker-container"
                />
              </LocalizationProvider>
              
              {isLoadingDateRange ? (
                <Box className="date-range-indicator">
                  <CircularProgress size={14} className="loading-indicator" />
                  <Typography className="date-range-text">
                    Loading date range...
                  </Typography>
                </Box>
              ) : dateRange?.lastCommitDate ? (
                <FormHelperText className="info-text">
                  Last commit: {new Date(dateRange.lastCommitDate).toLocaleDateString()}
                </FormHelperText>
              ) : null}
            </FormControl>
          </Grid>

          {/* Report Title */}
          <Grid item xs={12}>
            <FormControl fullWidth className="form-field">
              <TextField
                label="Report Title"
                name="title"
                value={formData.title}
                onChange={handleInputChange}
                variant="outlined"
                error={formSubmitted && !formData.title}
                helperText={formSubmitted && !formData.title ? "Please enter a title for your report" : ""}
              />
              <FormHelperText className="info-text">
                Give your report a descriptive title
              </FormHelperText>
            </FormControl>
          </Grid>

          {/* Include Code Option */}
          <Grid item xs={12}>
            <Box className="include-code-option">
              <Checkbox
                checked={formData.includeCode}
                onChange={(e) => handleCheckboxChange('includeCode', e.target.checked)}
                name="includeCode"
                color="primary"
              />
              <Typography>
                Include code snippets in the report
              </Typography>
            </Box>
            <FormHelperText className="info-text">
              When enabled, the report will include relevant code snippets from commits
            </FormHelperText>
          </Grid>

          {/* Error Display */}
          {error && (
            <Grid item xs={12}>
              <Typography className="validation-error">
                {error}
              </Typography>
            </Grid>
          )}
        </Grid>
      </DialogContent>
      
      <DialogActions>
        <Button onClick={onClose} color="inherit">
          Cancel
        </Button>
        <Button
          onClick={handleSubmit}
          color="primary"
          variant="contained"
          className="submit-button"
          disabled={loadingViewCommits || !validateForm()}
          startIcon={loadingViewCommits ? <CircularProgress size={20} color="inherit" /> : <CheckCircleIcon />}
        >
          {loadingViewCommits ? 'Loading...' : 'View Commits'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

export default CreateReportModalComponentTemplate;


---
File: frontend/src/components/Modals/CreateReport/CreateReportModal.js
---
import React, { useState, useEffect, useRef } from 'react';
import api from '../../../services/api.js';
import { useModal } from '../../../contexts/ModalContext.js';
import CreateReportModalComponentTemplate from './CreateReportModal.jsx';

/**
 * CreateReportModal component - Modal for selecting repository and parameters for report creation
 */
const CreateReportModalComponent = () => {
  const { 
    modalState, 
    closeModals, 
    updateReportData, 
    openViewCommitsModal 
  } = useModal();

  const { createReportOpen, reportData } = modalState;

  // Form data state
  const [formData, setFormData] = useState({
    repository: '',
    branches: [],
    authors: [],
    startDate: null,
    endDate: null,
    title: '',
    includeCode: true
  });

  // Initialize form data from context if available
  useEffect(() => {
    if (reportData) {
      setFormData(prevData => ({ ...prevData, ...reportData }));
    }
  }, [reportData]);

  // Repository data state
  const [repositoryInfo, setRepositoryInfo] = useState(null);
  const [branches, setBranches] = useState([]);
  const [availableAuthors, setAvailableAuthors] = useState([]);
  const [repositoryValid, setRepositoryValid] = useState(false);
  
  // Repository search state
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [searching, setSearching] = useState(false);
  
  // Date constraint state
  const [dateRange, setDateRange] = useState({
    firstCommitDate: null,
    lastCommitDate: null
  });
  
  // UI state
  const [loading, setLoading] = useState(false);
  const [validating, setValidating] = useState(false);
  const [error, setError] = useState(null);
  const [isLoadingAuthors, setIsLoadingAuthors] = useState(false);
  const [isLoadingDateRange, setIsLoadingDateRange] = useState(false);
  const [formSubmitted, setFormSubmitted] = useState(false);
  const [loadingViewCommits, setLoadingViewCommits] = useState(false);

  // Caching mechanism for API calls
  const apiCache = useRef({
    authors: {},
    dateRanges: {}
  });
  
  // Debounce timers
  const authorsDebounceTimer = useRef(null);
  const dateRangeDebounceTimer = useRef(null);

  // Handle repository search
  useEffect(() => {
    const searchRepositories = async () => {
      if (!searchQuery || searchQuery.trim().length < 2) {
        setSearchResults([]);
        return;
      }
      
      try {
        setSearching(true);
        const repos = await api.searchRepositories(searchQuery);
        setSearchResults(repos);
      } catch (err) {
        console.error('Repository search error:', err);
      } finally {
        setSearching(false);
      }
    };
    
    // Debounce search requests
    const timeoutId = setTimeout(() => {
      searchRepositories();
    }, 300);
    
    return () => clearTimeout(timeoutId);
  }, [searchQuery]);
  
  // Update authors when branches change
  useEffect(() => {
    const updateAvailableAuthors = async () => {
      const { repository, branches } = formData;
      
      if (!repository || !repositoryValid || !branches.length) {
        setAvailableAuthors([]);
        return;
      }
      
      try {
        setIsLoadingAuthors(true);
        const branchNames = branches.map(branch => typeof branch === 'object' ? branch.name : branch);
        
        // Create a cache key based on repository and branches
        const cacheKey = `${repository}:${branchNames.sort().join(',')}`;
        
        // Check if we have cached results
        if (apiCache.current.authors[cacheKey]) {
          setAvailableAuthors(apiCache.current.authors[cacheKey]);
        } else {
          // Fetch from API if not cached
          const authors = await api.getAuthorsForBranches(repository, branchNames);
          
          // Cache the results
          apiCache.current.authors[cacheKey] = authors;
          setAvailableAuthors(authors);
        }
        
        // Filter out selected authors that are no longer available
        setFormData(prev => ({
          ...prev,
          authors: prev.authors.filter(author => 
            apiCache.current.authors[cacheKey].includes(author)
          )
        }));
      } catch (err) {
        console.error('Error fetching authors:', err);
        setAvailableAuthors([]);
      } finally {
        setIsLoadingAuthors(false);
      }
    };
    
    // Clear any existing debounce timer
    if (authorsDebounceTimer.current) {
      clearTimeout(authorsDebounceTimer.current);
    }
    
    // Set a new debounce timer
    authorsDebounceTimer.current = setTimeout(updateAvailableAuthors, 300);
    
    // Clean up the timer on component unmount
    return () => {
      if (authorsDebounceTimer.current) {
        clearTimeout(authorsDebounceTimer.current);
      }
    };
  }, [formData.repository, formData.branches, repositoryValid]);
  
  // Update date range when branches or authors change
  useEffect(() => {
    const updateDateRange = async () => {
      const { repository, branches, authors } = formData;
      
      if (!repository || !repositoryValid || !branches.length) {
        return;
      }
      
      try {
        setIsLoadingDateRange(true);
        const branchNames = branches.map(branch => typeof branch === 'object' ? branch.name : branch);
        
        // Create a cache key based on repository, branches and authors
        const cacheKey = `${repository}:${branchNames.sort().join(',')}:${authors.sort().join(',')}`;
        
        let newDateRange;
        
        // Check if we have cached results
        if (apiCache.current.dateRanges[cacheKey]) {
          newDateRange = apiCache.current.dateRanges[cacheKey];
        } else {
          // Fetch from API if not cached
          newDateRange = await api.getDateRange(repository, branchNames, authors);
          
          // Cache the results
          apiCache.current.dateRanges[cacheKey] = newDateRange;
        }
        
        setDateRange(newDateRange);
        
        // Update date fields if they're outside the new range
        setFormData(prev => {
          const updatedForm = { ...prev };
          
          // If start date is before first commit date, update it
          if (newDateRange.firstCommitDate && (!prev.startDate || new Date(prev.startDate) < new Date(newDateRange.firstCommitDate))) {
            updatedForm.startDate = new Date(newDateRange.firstCommitDate);
          }
          
          // If end date is after last commit date, update it
          if (newDateRange.lastCommitDate && (!prev.endDate || new Date(prev.endDate) > new Date(newDateRange.lastCommitDate))) {
            updatedForm.endDate = new Date(newDateRange.lastCommitDate);
          }
          
          return updatedForm;
        });
      } catch (err) {
        console.error('Error fetching date range:', err);
      } finally {
        setIsLoadingDateRange(false);
      }
    };
    
    // Clear any existing debounce timer
    if (dateRangeDebounceTimer.current) {
      clearTimeout(dateRangeDebounceTimer.current);
    }
    
    // Set a new debounce timer
    dateRangeDebounceTimer.current = setTimeout(updateDateRange, 300);
    
    // Clean up the timer on component unmount
    return () => {
      if (dateRangeDebounceTimer.current) {
        clearTimeout(dateRangeDebounceTimer.current);
      }
    };
  }, [formData.repository, formData.branches, formData.authors, repositoryValid]);

  // Handle repository selection
  const handleRepositorySelect = async (repo) => {
    if (!repo) {
      setFormData(prev => ({ ...prev, repository: '', branches: [] }));
      setRepositoryValid(false);
      setBranches([]);
      return;
    }
    
    setFormData(prev => ({ ...prev, repository: repo, branches: [] }));
    
    try {
      setLoading(true);
      setError(null);
      
      // Fetch repository info and branches
      const [repoInfo, repoBranches] = await Promise.all([
        api.getRepositoryInfo(repo),
        api.getBranches(repo)
      ]);
      
      setRepositoryInfo(repoInfo);
      setBranches(repoBranches);
      setRepositoryValid(true);
    } catch (err) {
      console.error('Error fetching repository details:', err);
      setError(`Error loading repository details: ${err.message || 'Unknown error'}`);
      setRepositoryValid(false);
      setBranches([]);
    } finally {
      setLoading(false);
    }
  };

  // Handle form input changes
  const handleInputChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };

  // Handle branches selection
  const handleBranchesChange = (newBranches) => {
    setFormData(prev => ({ ...prev, branches: newBranches, authors: [] }));
  };

  // Handle authors selection
  const handleAuthorsChange = (newAuthors) => {
    setFormData(prev => ({ ...prev, authors: newAuthors }));
  };

  // Handle date changes
  const handleDateChange = (field, value) => {
    setFormData(prev => ({ ...prev, [field]: value }));
  };

  // Handle checkbox changes
  const handleCheckboxChange = (field, checked) => {
    setFormData(prev => ({ ...prev, [field]: checked }));
  };

  // Validate form data
  const validateForm = () => {
    const { repository, branches, title, startDate, endDate } = formData;
    
    // Basic validation
    if (!repository || !repositoryValid) return false;
    if (!branches.length) return false;
    if (!title) return false;
    if (!startDate || !endDate) return false;
    
    // Validate date range
    if (startDate > endDate) return false;
    
    return true;
  };

  // Handle form submission
  const handleSubmit = async () => {
    setFormSubmitted(true);
    
    if (!validateForm()) {
      return;
    }
    
    try {
      setLoadingViewCommits(true);
      setError(null);
      
      // Store report data in context
      updateReportData(formData);
      
      // Close this modal and open the ViewCommits modal
      closeModals();
      openViewCommitsModal();
    } catch (err) {
      console.error('Error preparing report:', err);
      setError(`Error preparing report: ${err.message || 'Unknown error'}`);
    } finally {
      setLoadingViewCommits(false);
    }
  };

  // Handle closing the modal
  const handleClose = () => {
    closeModals();
    
    // Reset form state
    setFormSubmitted(false);
    setError(null);
  };

  return (
    <CreateReportModalComponentTemplate
      open={createReportOpen}
      onClose={handleClose}
      formData={formData}
      handleInputChange={handleInputChange}
      handleRepositorySelect={handleRepositorySelect}
      handleBranchesChange={handleBranchesChange}
      handleAuthorsChange={handleAuthorsChange}
      handleDateChange={handleDateChange}
      handleCheckboxChange={handleCheckboxChange}
      handleSubmit={handleSubmit}
      validateForm={validateForm}
      formSubmitted={formSubmitted}
      error={error}
      repositoryValid={repositoryValid}
      searching={searching}
      searchQuery={searchQuery}
      setSearchQuery={setSearchQuery}
      searchResults={searchResults}
      branches={branches}
      availableAuthors={availableAuthors}
      isLoadingAuthors={isLoadingAuthors}
      isLoadingDateRange={isLoadingDateRange}
      dateRange={dateRange}
      loadingViewCommits={loadingViewCommits}
    />
  );
};

export default CreateReportModalComponent;


---
File: frontend/src/components/Modals/CreateReport/CreateReportModal.css
---
.modal-title {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding-right: 8px;
}

.modal-title-text {
  font-weight: 600;
}

.close-button:hover {
  background-color: rgba(255, 255, 255, 0.1);
}

.form-field {
  margin-bottom: 16px;
}

.search-loading-indicator {
  margin-right: 8px;
}

.date-picker-container {
  width: 100%;
}

.info-text {
  font-size: 0.85rem;
  margin-top: 8px;
}

.author-chip {
  margin: 2px;
}

.date-range-indicator {
  display: flex;
  align-items: center;
  margin-top: 8px;
  margin-bottom: 4px;
}

.date-range-text {
  font-size: 0.75rem;
  margin-left: 8px;
}

.loading-indicator {
  margin-right: 8px;
}

.validation-error {
  color: #f44336;
  margin-top: 8px;
}

.submit-button {
  margin-left: 8px;
}

.include-code-option {
  display: flex;
  align-items: center;
  margin-top: 8px;
}

.chip-with-icon {
  display: flex;
  align-items: center;
}

.chip-icon {
  margin-right: 4px;
}


---
File: frontend/src/components/AuthCallback/index.js
---
export { default } from './AuthCallbackComponent';


---
File: frontend/src/components/AuthCallback/AuthCallbackComponent.jsx
---
import React from 'react';
import { Box, CircularProgress, Typography, Alert } from '@mui/material';
import './AuthCallbackPage.css';

const AuthCallbackPageTemplate = ({ error }) => {
  return (
    <Box
      className="auth-callback-container"
      sx={{
        bgcolor: 'background.default',
      }}
    >
      {error && (
        <Alert severity="error" className="auth-callback-error">
          {error}
        </Alert>
      )}
      
      <CircularProgress 
        size={60} 
        thickness={4} 
        className="auth-callback-spinner"
      />
      <Typography 
        variant="h6" 
        className="auth-callback-text"
      >
        Completing authentication...
      </Typography>
    </Box>
  );
};

export default AuthCallbackPageTemplate;


---
File: frontend/src/components/AuthCallback/AuthCallbackComponent.css
---
.auth-callback-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
}

.auth-callback-error {
  margin-bottom: 1.5rem;
  max-width: 80%;
  text-align: center;
}

.auth-callback-spinner {
  animation: pulse 1.5s ease-in-out infinite;
}

.auth-callback-text {
  margin-top: 2rem;
  opacity: 0.9;
}

@keyframes pulse {
  0% {
    opacity: 0.6;
    transform: scale(0.98);
  }
  50% {
    opacity: 1;
    transform: scale(1.02);
  }
  100% {
    opacity: 0.6;
    transform: scale(0.98);
  }
}


---
File: frontend/src/components/AuthCallback/AuthCallbackComponent.js
---
import React, { useEffect, useContext, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { AuthContext } from '../../contexts/AuthContext.js';
import axios from 'axios';
import AuthCallbackPageTemplate from './AuthCallbackPage.jsx';

/**
 * Auth callback page component - handles OAuth callback and redirections
 */
const AuthCallbackPage = () => {
  const navigate = useNavigate();
  const { checkAuth } = useContext(AuthContext);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const handleAuthentication = async () => {
      try {
        // Direct API call instead of using the checkAuth method to avoid interceptor issues
        const response = await axios.get('/api/auth/me');
        
        if (response.data.isAuthenticated) {
          // Get the redirect path from sessionStorage or default to dashboard
          const redirectPath = sessionStorage.getItem('redirectPath') || '/dashboard';
          
          // Clear the redirect path from sessionStorage
          sessionStorage.removeItem('redirectPath');
          
          // Redirect to the intended destination
          navigate(redirectPath, { replace: true });
        } else {
          setError("Authentication failed. Please try logging in again.");
          setTimeout(() => {
            navigate('/login', { replace: true });
          }, 2000);
        }
      } catch (error) {
        setError("An error occurred during authentication. Please try again.");
        setTimeout(() => {
          navigate('/login?error=auth_failed', { replace: true });
        }, 2000);
      }
    };
    
    handleAuthentication();
  }, [navigate]);
  
  return <AuthCallbackPageTemplate error={error} />;
};

export default AuthCallbackPage;


---
File: frontend/src/components/AnalyticsDashboard/index.js
---
export { default } from './AnalyticsDashboardComponent';


---
File: frontend/src/components/AnalyticsDashboard/AnalyticsDashboardComponent.css
---
.dashboard-container {
  padding: 1rem 0;
}

.welcome-section {
  display: flex;
  align-items: center;
  margin-bottom: 2rem;
  padding: 1.5rem;
  border-radius: 8px;
  backdrop-filter: blur(10px);
}

.welcome-icon {
  font-size: 48px;
  margin-right: 1rem;
}

.welcome-title {
  margin-bottom: 0.5rem;
}

.welcome-subtitle {
  opacity: 0.75;
}

.stat-card {
  height: 100%;
  transition: all 0.2s ease-in-out;
  border: 1px solid rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(10px);
}

.stat-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
}

.stat-card-header {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
}

.stat-card-icon-container {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 48px;
  height: 48px;
  border-radius: 8px;
  margin-right: 1rem;
}

.stat-card-title {
  font-weight: 600;
}

.stat-card-subtitle {
  color: rgba(255, 255, 255, 0.6);
}

.stat-card-value {
  font-weight: 700;
  margin-bottom: 0.5rem;
  font-size: 2rem;
}

.usage-progress-container {
  margin-bottom: 1rem;
}

.usage-progress-header {
  display: flex;
  justify-content: space-between;
  margin-bottom: 0.5rem;
}

.usage-progress-bar {
  height: 8px;
  border-radius: 4px;
}

.usage-warning {
  display: flex;
  align-items: center;
  margin-top: 0.5rem;
}

.usage-warning-icon {
  margin-right: 0.5rem;
}

.plan-info-section {
  padding: 1.5rem;
  border-radius: 8px;
  margin-bottom: 1.5rem;
}

.plan-header {
  display: flex;
  align-items: center;
  margin-bottom: 1rem;
}

.plan-name {
  font-weight: 600;
  margin-right: 0.5rem;
}

.upgrade-button {
  margin-top: 1rem;
}

.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 60vh;
}

.section-title {
  margin-bottom: 1rem;
  font-weight: 600;
}

.chart-container {
  height: 300px;
  padding: 1rem;
  border-radius: 8px;
}

.sub-section {
  margin-top: 1.5rem;
}


---
File: frontend/src/components/AnalyticsDashboard/AnalyticsDashboardComponent.js
---
import React, { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { useTheme } from '@mui/material/styles';
import { useSnackbar } from 'notistack';
import AnalyticsDashboardComponentTemplate from './AnalyticsDashboardComponent.jsx';
import { useAuth } from '../../contexts/AuthContext';
import api from '../../services/api';

const AnalyticsDashboardComponent = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { enqueueSnackbar } = useSnackbar();
  const { user, isAuthenticated, loading: authLoading } = useAuth();
  
  const [stats, setStats] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // If authentication is complete and user is not authenticated, redirect to login
    if (!authLoading && !isAuthenticated) {
      navigate('/login', { state: { from: '/analytics' } });
      return;
    }

    // Fetch user stats if authenticated
    if (isAuthenticated && user) {
      fetchUserStats();
    }
  }, [isAuthenticated, authLoading, user, navigate]);

  const fetchUserStats = async () => {
    try {
      setLoading(true);
      const response = await api.get('/users/stats');
      setStats(response.data);
      setError(null);
    } catch (err) {
      console.error('Error fetching user stats:', err);
      setError(
        err.response?.data?.message || 
        'Failed to load analytics data. Please try again later.'
      );
      enqueueSnackbar('Failed to load analytics data', { variant: 'error' });
    } finally {
      setLoading(false);
    }
  };

  // Handle refresh button click
  const handleRefresh = () => {
    fetchUserStats();
    enqueueSnackbar('Refreshing analytics data...', { variant: 'info' });
  };

  return (
    <AnalyticsDashboardComponentTemplate
      loading={loading || authLoading}
      error={error}
      stats={stats}
      theme={theme}
      onRefresh={handleRefresh}
    />
  );
};

export default AnalyticsDashboardComponent;


---
File: frontend/src/components/AnalyticsDashboard/AnalyticsDashboardComponent.jsx
---
import React from 'react';
import {
  Grid,
  Typography,
  Card,
  CardContent,
  Box,
  CircularProgress,
  LinearProgress,
  Divider,
  Alert,
  Paper,
  Tooltip,
  IconButton,
  Button
} from '@mui/material';
import {
  Description as DescriptionIcon,
  Code as CodeIcon,
  Speed as SpeedIcon,
  Warning as WarningIcon,
  Info as InfoIcon,
  TrendingUp as TrendingUpIcon,
  Storage as StorageIcon,
  AccountCircle as AccountCircleIcon,
  GitHub as GitHubIcon
} from '@mui/icons-material';
import Layout from '../../components/Layout';
import './AnalyticsDashboardComponent.css';

// Stat Card Component
const StatCard = ({ title, value, icon, color, subtitle, tooltip }) => {
  return (
    <Card className="stat-card" sx={{ bgcolor: 'background.paper' }}>
      <CardContent>
        <Box className="stat-card-header">
          <Box 
            className="stat-card-icon-container"
            sx={{ bgcolor: `${color}15` }}
          >
            {icon}
          </Box>
          <Box>
            <Typography variant="h6" component="div" className="stat-card-title">
              {title}
            </Typography>
            {subtitle && (
              <Typography variant="body2" color="text.secondary" className="stat-card-subtitle">
                {subtitle}
              </Typography>
            )}
          </Box>
        </Box>
        <Typography variant="h4" component="div" className="stat-card-value">
          {value}
        </Typography>
        {tooltip && (
          <Tooltip title={tooltip} arrow>
            <IconButton size="small" sx={{ color: 'text.secondary' }}>
              <InfoIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        )}
      </CardContent>
    </Card>
  );
};

// Usage Progress Component
const UsageProgress = ({ current, limit, label, color }) => {
  const percentage = (current / limit) * 100;

  return (
    <Box className="usage-progress-container">
      <Box className="usage-progress-header">
        <Typography variant="body2" color="text.secondary">
          {label}
        </Typography>
        <Typography variant="body2" color="text.secondary">
          {current} / {limit}
        </Typography>
      </Box>
      <LinearProgress
        variant="determinate"
        value={Math.min(percentage, 100)}
        className="usage-progress-bar"
        sx={{
          bgcolor: `${color}15`,
          '& .MuiLinearProgress-bar': {
            bgcolor: color,
          }
        }}
      />
      {percentage >= 90 && (
        <Box className="usage-warning">
          <WarningIcon color="warning" fontSize="small" className="usage-warning-icon" />
          <Typography variant="caption" color="warning.main">
            Approaching limit
          </Typography>
        </Box>
      )}
    </Box>
  );
};

const AnalyticsDashboardComponentTemplate = ({ loading, error, stats, theme }) => {
  if (loading) {
    return (
      <Layout title="Analytics">
        <Box className="loading-container">
          <CircularProgress />
        </Box>
      </Layout>
    );
  }

  if (error) {
    return (
      <Layout title="Analytics">
        <Alert severity="error" sx={{ mt: 2 }}>{error}</Alert>
      </Layout>
    );
  }

  return (
    <Layout title="Analytics">
      <Box className="dashboard-container">
        <Grid container spacing={3}>
          {/* Welcome Section */}
          <Grid item xs={12}>
            <Box 
              className="welcome-section"
              sx={{ 
                background: theme?.palette?.background?.cardGradient,
                border: '1px solid rgba(255, 255, 255, 0.05)',
              }}
            >
              <AccountCircleIcon className="welcome-icon" sx={{ color: theme?.palette?.primary?.main }} />
              <Box>
                <Typography variant="h4" component="h1" className="welcome-title">
                  Your Analytics Dashboard
                </Typography>
                <Typography variant="body1" color="text.secondary" className="welcome-subtitle">
                  Track your usage, monitor limits, and analyze your Git activity patterns
                </Typography>
              </Box>
            </Box>
          </Grid>

          {/* Key Stats */}
          <Grid item xs={12} md={4}>
            <StatCard 
              title="Reports Generated" 
              value={stats?.allTimeStats?.reports || 0} 
              icon={<DescriptionIcon sx={{ color: theme?.palette?.primary?.main }} />}
              color={theme?.palette?.primary?.main}
              subtitle="All-time total"
            />
          </Grid>
          <Grid item xs={12} md={4}>
            <StatCard 
              title="Commits Analyzed" 
              value={stats?.allTimeStats?.commits || 0} 
              icon={<CodeIcon sx={{ color: theme?.palette?.secondary?.main }} />}
              color={theme?.palette?.secondary?.main}
              subtitle="All-time total"
            />
          </Grid>
          <Grid item xs={12} md={4}>
            <StatCard 
              title="Average Commit Size" 
              value={stats?.averageStats?.commitSize ? `${stats.averageStats.commitSize} lines` : 'N/A'} 
              icon={<StorageIcon sx={{ color: theme?.palette?.info?.main }} />}
              color={theme?.palette?.info?.main}
              subtitle="Average per report"
            />
          </Grid>

          {/* Plan Info */}
          <Grid item xs={12}>
            <Paper 
              className="plan-info-section"
              sx={{ 
                background: theme?.palette?.background?.cardGradient,
                border: '1px solid rgba(255, 255, 255, 0.05)',
              }}
            >
              <Box className="plan-header">
                <Typography variant="h6" className="section-title">
                  Your Plan: <span className="plan-name">{stats?.plan?.displayName || 'Basic'}</span>
                </Typography>
                {stats?.plan?.name !== 'enterprise' && (
                  <Button 
                    variant="outlined" 
                    size="small" 
                    color="primary"
                    sx={{ ml: 2 }}
                  >
                    Upgrade
                  </Button>
                )}
              </Box>

              <Divider sx={{ mb: 3 }} />

              <Grid container spacing={3}>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle1" className="sub-section">
                    Monthly Usage
                  </Typography>
                  <UsageProgress 
                    current={stats?.currentUsage?.reportsGenerated?.standard || 0} 
                    limit={stats?.plan?.limits?.reportsPerMonth || 10}
                    label="Standard Reports"
                    color={theme?.palette?.primary?.main}
                  />
                  <UsageProgress 
                    current={stats?.currentUsage?.reportsGenerated?.large || 0} 
                    limit={Math.floor((stats?.plan?.limits?.reportsPerMonth || 10) * 0.1)}
                    label="Large Reports"
                    color={theme?.palette?.secondary?.main}
                  />
                </Grid>
                <Grid item xs={12} md={6}>
                  <Typography variant="subtitle1" className="sub-section">
                    Report Limits
                  </Typography>
                  <Box sx={{ mb: 2 }}>
                    <Typography variant="body2">
                      <strong>Standard Report:</strong> Up to {stats?.plan?.limits?.commitsPerStandardReport || 20} commits
                    </Typography>
                    <Typography variant="body2">
                      <strong>Large Report:</strong> Up to {stats?.plan?.limits?.commitsPerLargeReport || 50} commits
                    </Typography>
                  </Box>
                </Grid>
              </Grid>

              {stats?.plan?.name === 'basic' && (
                <Box sx={{ mt: 3 }}>
                  <Button 
                    variant="contained" 
                    color="primary"
                    className="upgrade-button"
                  >
                    Upgrade to Pro for more reports
                  </Button>
                </Box>
              )}
            </Paper>
          </Grid>

          {/* Recent Activity */}
          <Grid item xs={12}>
            <Paper 
              className="chart-container"
              sx={{ 
                background: theme?.palette?.background?.cardGradient,
                border: '1px solid rgba(255, 255, 255, 0.05)',
              }}
            >
              <Typography variant="h6" className="section-title">
                Recent Activity
              </Typography>
              <Divider sx={{ mb: 2 }} />
              
              {stats?.recentActivity?.length === 0 ? (
                <Box sx={{ p: 3, textAlign: 'center' }}>
                  <Typography color="text.secondary">
                    No recent activity to display. Generate a report to see your activity here.
                  </Typography>
                </Box>
              ) : (
                <Box>
                  {stats?.recentActivity?.map((activity, index) => (
                    <Box key={index} sx={{ mb: 2 }}>
                      <Typography variant="body1">
                        {activity.type === 'report' ? (
                          <>
                            <DescriptionIcon fontSize="small" sx={{ verticalAlign: 'middle', mr: 1 }} />
                            Generated a report: <strong>{activity.title}</strong>
                          </>
                        ) : activity.type === 'commit' ? (
                          <>
                            <CodeIcon fontSize="small" sx={{ verticalAlign: 'middle', mr: 1 }} />
                            Analyzed commit: <strong>{activity.sha.substring(0, 7)}</strong>
                          </>
                        ) : (
                          <>
                            <InfoIcon fontSize="small" sx={{ verticalAlign: 'middle', mr: 1 }} />
                            {activity.description}
                          </>
                        )}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        {new Date(activity.timestamp).toLocaleString()}
                      </Typography>
                      {index < stats.recentActivity.length - 1 && <Divider sx={{ my: 1 }} />}
                    </Box>
                  ))}
                </Box>
              )}
            </Paper>
          </Grid>
        </Grid>
      </Box>
    </Layout>
  );
};

export default AnalyticsDashboardComponentTemplate;


---
File: frontend/src/components/NotFound/NotFoundComponent.js
---
import React from 'react';
import NotFoundComponentTemplate from './NotFoundComponent.jsx';

/**
 * NotFound page component - handles 404 errors
 */
const NotFoundComponent = () => {
  // This is a simple component with minimal logic
  // In a more complex app, we might add analytics tracking for 404 errors here
  
  return <NotFoundComponentTemplate />;
};

export default NotFoundComponent;


---
File: frontend/src/components/NotFound/index.js
---
export { default } from './NotFoundComponent';


---
File: frontend/src/components/NotFound/NotFoundComponent.jsx
---
import React from 'react';
import { Box, Typography, Button } from '@mui/material';
import { Link as RouterLink } from 'react-router-dom';
import './NotFoundComponent.css';

const NotFoundComponentTemplate = () => {
  return (
    <Box className="not-found-container">
      <Typography variant="h1" className="not-found-title">
        404
      </Typography>
      <Typography variant="h4" className="not-found-subtitle">
        Page Not Found
      </Typography>
      <Typography variant="body1" className="not-found-message">
        The page you are looking for doesn't exist or has been moved.
      </Typography>
      <Button
        component={RouterLink}
        to="/dashboard"
        variant="contained"
        color="primary"
        className="not-found-button"
      >
        Go to Dashboard
      </Button>
    </Box>
  );
};

export default NotFoundComponentTemplate;


---
File: frontend/src/components/NotFound/NotFoundComponent.css
---
.not-found-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh;
  text-align: center;
  padding-top: 2rem;
  padding-bottom: 2rem;
}

.not-found-title {
  font-size: 6rem;
  margin-bottom: 1rem;
  background: linear-gradient(90deg, #e1f5fe, #4dabf5);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.not-found-subtitle {
  margin-bottom: 1rem;
  font-weight: 500;
}

.not-found-message {
  margin-bottom: 2rem;
  opacity: 0.8;
}

.home-button {
  margin-top: 1rem;
  padding: 0.75rem 1.5rem;
  border-radius: 8px;
  transition: all 0.3s ease;
}

.home-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(77, 171, 245, 0.3);
}


---
File: frontend/src/components/Login/LoginComponent.jsx
---
import React from 'react';
import {
  Box,
  Button,
  Typography,
  Container,
  Grid,
  Paper,
  Alert
} from '@mui/material';
import GitHubIcon from '@mui/icons-material/GitHub';
import './LoginComponent.css';

const LoginComponentTemplate = ({ handleGitHubLogin, theme, error }) => {
  return (
    <Box className="login-container">
      <Container maxWidth="sm">
        <Grid container justifyContent="center" alignItems="center" style={{ minHeight: '100vh' }}>
          <Grid item xs={12}>
            <Paper className="login-paper" elevation={3}>
              <Box className="login-box">
                <Typography variant="h4" component="h1" className="login-title">
                  Welcome to GitStatus
                </Typography>
                
                <Typography variant="body1" className="login-subtitle">
                  Generate professional reports from your git commits
                </Typography>
                
                {error && (
                  <Alert severity="error" className="login-error">
                    {error === 'access_denied' 
                      ? 'GitHub access was denied. Please try again.' 
                      : 'An error occurred during login. Please try again.'}
                  </Alert>
                )}
                
                <Button
                  variant="contained"
                  color="primary"
                  size="large"
                  className="github-button"
                  startIcon={<GitHubIcon />}
                  onClick={handleGitHubLogin}
                  sx={{
                    bgcolor: '#24292e',
                    '&:hover': {
                      bgcolor: '#1b1f23'
                    }
                  }}
                >
                  Login with GitHub
                </Button>
                
                <Box className="login-features">
                  <Typography variant="subtitle1" className="features-title">
                    GitStatus helps you:
                  </Typography>
                  <ul className="features-list">
                    <li>Generate professional summaries of your work</li>
                    <li>Track your development progress over time</li>
                    <li>Export polished PDF reports for clients or managers</li>
                    <li>Analyze commit patterns to improve productivity</li>
                  </ul>
                </Box>
              </Box>
            </Paper>
          </Grid>
        </Grid>
      </Container>
    </Box>
  );
};

export default LoginComponentTemplate;


---
File: frontend/src/components/Login/index.js
---
export { default } from './LoginComponent';


---
File: frontend/src/components/Login/LoginComponent.js
---
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { useTheme } from '@mui/material/styles';
import { useAuth } from '../../contexts/AuthContext';
import LoginComponentTemplate from './LoginComponent.jsx';

/**
 * Login page component - contains only business logic
 */
const LoginComponent = () => {
  const theme = useTheme();
  const navigate = useNavigate();
  const { login, isAuthenticated } = useAuth();

  // If already authenticated, redirect to dashboard
  React.useEffect(() => {
    if (isAuthenticated) {
      navigate('/dashboard');
    }
  }, [isAuthenticated, navigate]);

  const handleGitHubLogin = () => {
    window.location.href = `${process.env.REACT_APP_API_URL}/auth/github`;
  };

  return (
    <LoginComponentTemplate
      handleGitHubLogin={handleGitHubLogin}
      theme={theme}
    />
  );
};

export default LoginComponent;


---
File: frontend/src/components/Login/LoginComponent.css
---
/* Login page container */
.login-container {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  align-items: center;
  justify-content: center;
  position: relative;
  overflow: hidden;
  padding-top: 3rem;
  padding-bottom: 3rem;
}

/* Background decorative elements */
.login-container::before {
  content: "";
  position: absolute;
  top: 5%;
  left: 10%;
  width: 30%;
  height: 40%;
  background: radial-gradient(circle, rgba(77, 171, 245, 0.08) 0%, rgba(0, 0, 0, 0) 70%);
  z-index: 0;
  border-radius: 50%;
}

.login-container::after {
  content: "";
  position: absolute;
  bottom: 10%;
  right: 5%;
  width: 25%;
  height: 35%;
  background: radial-gradient(circle, rgba(179, 136, 255, 0.08) 0%, rgba(0, 0, 0, 0) 70%);
  z-index: 0;
  border-radius: 50%;
}

/* Header section */
.login-header {
  text-align: center;
  margin-bottom: 2.5rem;
  animation: slideUp 0.8s ease-out;
}

.login-icon-container {
  display: inline-block;
  border-radius: 50%;
  padding: 1rem;
  margin-bottom: 1rem;
  background: linear-gradient(145deg, rgba(30, 30, 30, 0.8), rgba(20, 20, 20, 0.5));
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  transition: transform 0.3s ease-in-out;
}

.login-icon-container:hover {
  transform: rotate(5deg) scale(1.05);
}

.login-icon {
  font-size: 64px;
  transition: all 0.3s ease;
}

.login-title {
  font-weight: 600;
  background: linear-gradient(90deg, #fff, #81d4fa);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  letter-spacing: -0.02em;
}

.login-subtitle {
  opacity: 0.9;
  max-width: 80%;
  margin-left: auto;
  margin-right: auto;
  margin-bottom: 1rem;
}

/* Login card */
.login-card {
  margin-bottom: 2rem;
  border-radius: 1.5rem;
  border: 1px solid rgba(255, 255, 255, 0.05);
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
  transform: translateY(0);
  transition: all 0.3s ease;
}

.login-card:hover {
  transform: translateY(-5px);
  box-shadow: 0 12px 40px rgba(0, 0, 0, 0.3);
}

.login-card-content {
  padding: 2.5rem;
}

.login-instructions {
  margin-bottom: 2rem;
  text-align: center;
  font-size: 1.1rem;
  line-height: 1.5;
}

.login-error {
  margin-bottom: 1.5rem;
  padding: 1rem;
  text-align: center;
  border-radius: 8px;
  background-color: rgba(211, 47, 47, 0.1);
  border: 1px solid rgba(211, 47, 47, 0.3);
}

.login-button {
  padding-top: 0.9rem;
  padding-bottom: 0.9rem;
  font-size: 1.1rem;
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(77, 171, 245, 0.4);
}

.login-button:hover {
  box-shadow: 0 6px 25px rgba(77, 171, 245, 0.6);
}

/* Description box */
.description-box {
  text-align: center;
  padding: 1.5rem;
  border-radius: 1.5rem;
  background-color: rgba(255, 255, 255, 0.03);
  backdrop-filter: blur(10px);
}

.description-text {
  line-height: 1.6;
}

/* Footer */
.login-footer {
  padding-top: 1.5rem;
  padding-bottom: 1.5rem;
  padding-left: 1rem;
  padding-right: 1rem;
  margin-top: auto;
  text-align: center;
  width: 100%;
  position: relative;
  z-index: 1;
  border-top: 1px solid rgba(255, 255, 255, 0.05);
}

/* Animations */
@keyframes slideUp {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}


---
File: frontend/src/components/Dashboard/index.js
---
export { default } from './DashboardComponent'; 

---
File: frontend/src/components/Dashboard/DashboardComponent.js
---
import React, { useState, useEffect, useContext } from 'react';
import { useNavigate } from 'react-router-dom';
import { useTheme } from '@mui/material';
import { useModal } from '../../contexts/ModalContext';
import { AuthContext } from '../../contexts/AuthContext';
import api from '../../services/api';
import toast from '../../services/toast';
import DashboardComponentTemplate from './DashboardComponent.jsx';

/**
 * Dashboard component - contains only business logic
 */
const DashboardComponent = () => {
  const { isAuthenticated, loading: authLoading } = useContext(AuthContext);
  const navigate = useNavigate();
  const theme = useTheme();
  const { openCreateReportModal } = useModal();
  const [reports, setReports] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [deleteDialog, setDeleteDialog] = useState({ open: false, report: null });
  const [confirmationName, setConfirmationName] = useState('');
  const [isDeleting, setIsDeleting] = useState(false);

  // Redirect if not authenticated
  useEffect(() => {
    if (!authLoading && !isAuthenticated) {
      navigate('/login');
    }
  }, [isAuthenticated, authLoading, navigate]);

  // Function to fetch user's reports
  const fetchReports = async () => {
    try {
      setLoading(true);
      const fetchedReports = await api.getReports();
      setReports(fetchedReports);
      setError(null);
    } catch (err) {
      console.error('Error fetching reports:', err);
      setError('Failed to load reports. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  // Fetch reports on component mount
  useEffect(() => {
    if (isAuthenticated) {
      fetchReports();
    }
  }, [isAuthenticated]);

  // Format date for display
  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };

  const handleOpenDeleteDialog = (report, event) => {
    event.preventDefault();
    event.stopPropagation();
    setDeleteDialog({ open: true, report });
    setConfirmationName('');
  };

  const handleCloseDeleteDialog = () => {
    setDeleteDialog({ open: false, report: null });
    setConfirmationName('');
  };

  const handleDeleteReport = async () => {
    if (!deleteDialog.report) return;
    
    try {
      setIsDeleting(true);
      await api.deleteReport(deleteDialog.report.id, confirmationName);
      
      // Remove the deleted report from state
      setReports(reports.filter(r => r.id !== deleteDialog.report.id));
      
      // Show success message
      toast.success(`Report "${deleteDialog.report.title || deleteDialog.report.name}" successfully deleted`);
      
      // Close dialog
      handleCloseDeleteDialog();
    } catch (err) {
      console.error('Error deleting report:', err);
      toast.error(err.response?.data?.error || 'Failed to delete report');
    } finally {
      setIsDeleting(false);
    }
  };

  // Pass all required props to the template
  return (
    <DashboardComponentTemplate
      reports={reports}
      loading={loading}
      error={error}
      handleOpenDeleteDialog={handleOpenDeleteDialog}
      handleCloseDeleteDialog={handleCloseDeleteDialog}
      handleDeleteReport={handleDeleteReport}
      deleteDialog={deleteDialog}
      confirmationName={confirmationName}
      setConfirmationName={setConfirmationName}
      isDeleting={isDeleting}
      formatDate={formatDate}
      openCreateReportModal={openCreateReportModal}
      theme={theme}
    />
  );
};

export default DashboardComponent; 

---
File: frontend/src/components/Dashboard/DashboardComponent.css
---
.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  padding-bottom: 1rem;
}

.dashboard-title-container {
  display: flex;
  align-items: center;
}

.dashboard-icon {
  font-size: 28px;
  margin-right: 0.75rem;
}

.dashboard-title {
  background: linear-gradient(90deg, #fff, #81d4fa);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  font-weight: 600;
}

.create-report-button {
  padding-left: 1.5rem;
  padding-right: 1.5rem;
  padding-top: 0.6rem;
  padding-bottom: 0.6rem;
  font-weight: 500;
  box-shadow: 0 4px 12px rgba(77, 171, 245, 0.3);
  transition: all 0.2s ease-in-out;
}

.create-report-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(77, 171, 245, 0.4);
}

.create-report-button:active {
  transform: translateY(0);
  box-shadow: 0 4px 12px rgba(77, 171, 245, 0.3);
}

.error-alert {
  border-radius: 8px;
  border: 1px solid rgba(211, 47, 47, 0.3);
}

.reports-card {
  border: 1px solid rgba(255, 255, 255, 0.05);
  backdrop-filter: blur(10px);
  overflow: hidden;
}

.loading-container {
  display: flex;
  justify-content: center;
  margin-top: 2rem;
  margin-bottom: 2rem;
}

.loading-progress .MuiCircularProgress-circle {
  stroke-linecap: round;
}

.empty-reports-container {
  text-align: center;
  padding-top: 3rem;
  padding-bottom: 3rem;
  background: rgba(77, 171, 245, 0.02);
  border-radius: 16px;
}

.empty-reports-icon {
  font-size: 64px;
  color: rgba(255, 255, 255, 0.5);
  margin-bottom: 1.5rem;
  opacity: 0.7;
}

.report-table-container {
  margin-top: 1rem;
}

.report-link {
  text-decoration: none;
  color: inherit;
  display: contents;
}

.report-table-row {
  transition: background-color 0.2s ease-in-out;
}

.report-table-row:hover {
  background-color: rgba(77, 171, 245, 0.04);
}

.report-title {
  font-weight: 500;
  color: #4dabf5;
}

.report-chip {
  font-size: 0.75rem;
  height: 24px;
}

.report-action-button {
  color: rgba(255, 255, 255, 0.7);
}

.report-action-button:hover {
  color: #fff;
}

.delete-button:hover {
  color: #f44336;
}

.download-button:hover {
  color: #4caf50;
}

.dialog-content {
  margin-top: 1rem;
}

.delete-confirmation-input {
  margin-top: 1rem;
}

/* Animation for fade-in effect */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.fade-in {
  animation: fadeIn 0.5s ease-in-out;
} 

---
File: frontend/src/components/Dashboard/DashboardComponent.jsx
---
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import { 
  Grid, 
  Typography, 
  Card, 
  CardContent, 
  Button, 
  Box, 
  CircularProgress, 
  Link,
  Divider,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  IconButton,
  Tooltip,
  Alert,
  Dialog,
  DialogActions,
  DialogContent,
  DialogContentText,
  DialogTitle,
  TextField,
  Chip,
  Zoom
} from '@mui/material';
import { Add as AddIcon } from '@mui/icons-material';
import DescriptionIcon from '@mui/icons-material/Description';
import DownloadIcon from '@mui/icons-material/Download';
import DeleteIcon from '@mui/icons-material/Delete';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import GitHubIcon from '@mui/icons-material/GitHub';
import Layout from '../../components/Layout';
import './DashboardComponent.css';

const DashboardComponentTemplate = ({
  reports,
  loading,
  error,
  handleOpenDeleteDialog,
  handleCloseDeleteDialog,
  handleDeleteReport,
  deleteDialog,
  confirmationName,
  setConfirmationName,
  isDeleting,
  formatDate,
  openCreateReportModal,
  theme
}) => {
  return (
    <Layout title="Dashboard">
      <Grid container spacing={3} className="fade-in">
        <Grid item xs={12}>
          <Box className="dashboard-header">
            <Box className="dashboard-title-container">
              <DescriptionIcon 
                className="dashboard-icon"
                sx={{ color: theme.palette.primary.main }}
              />
              <Typography 
                variant="h4" 
                component="h1" 
                className="dashboard-title"
              >
                Your Reports
              </Typography>
            </Box>
            <Zoom in={true} style={{ transitionDelay: '300ms' }}>
              <Button
                variant="contained"
                color="primary"
                onClick={openCreateReportModal}
                startIcon={<AddIcon />}
                className="create-report-button"
                sx={{
                  '&:hover': {
                    bgcolor: 'primary.light'
                  }
                }}
              >
                Create New Report
              </Button>
            </Zoom>
          </Box>
        </Grid>

        {error && (
          <Grid item xs={12}>
            <Alert 
              severity="error"
              className="error-alert"
            >
              {error}
            </Alert>
          </Grid>
        )}

        <Grid item xs={12}>
          <Card 
            elevation={2}
            className="reports-card"
          >
            <CardContent sx={{ py: 3 }}>
              <Divider sx={{ mb: 3 }} />

              {loading ? (
                <Box className="loading-container">
                  <CircularProgress 
                    color="primary" 
                    className="loading-progress"
                  />
                </Box>
              ) : !reports || reports.length === 0 ? (
                <Box className="empty-reports-container">
                  <DescriptionIcon className="empty-reports-icon" />
                  <Typography variant="h6" color="text.secondary" gutterBottom>
                    You haven't created any reports yet.
                  </Typography>
                  <Typography variant="body2" color="text.secondary" paragraph>
                    Get started by creating your first report.
                  </Typography>
                  <Button
                    variant="contained"
                    color="primary"
                    startIcon={<AddIcon />}
                    onClick={openCreateReportModal}
                    sx={{ mt: 2 }}
                  >
                    Create Report
                  </Button>
                </Box>
              ) : (
                <TableContainer component={Paper} className="report-table-container">
                  <Table sx={{ minWidth: 650 }} aria-label="reports table">
                    <TableHead>
                      <TableRow>
                        <TableCell>Report Name</TableCell>
                        <TableCell>Repository</TableCell>
                        <TableCell>Created</TableCell>
                        <TableCell>Status</TableCell>
                        <TableCell align="right">Actions</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {reports.map((report) => (
                        <TableRow 
                          key={report.id} 
                          className="report-table-row"
                        >
                          <TableCell component="th" scope="row">
                            <Link 
                              component={RouterLink} 
                              to={`/reports/${report.id}`}
                              className="report-link"
                            >
                              <Typography className="report-title">
                                {report.name || report.title || 'Untitled Report'}
                              </Typography>
                            </Link>
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                              <GitHubIcon sx={{ fontSize: 16, mr: 1, opacity: 0.7 }} />
                              {report.repository || 'Unknown Repository'}
                            </Box>
                          </TableCell>
                          <TableCell>
                            <Box sx={{ display: 'flex', alignItems: 'center' }}>
                              <CalendarTodayIcon sx={{ fontSize: 16, mr: 1, opacity: 0.7 }} />
                              {formatDate(report.createdAt)}
                            </Box>
                          </TableCell>
                          <TableCell>
                            <Chip 
                              label={report.pdfUrl === 'pending' ? 'Processing' : 'Ready'} 
                              color={report.pdfUrl === 'pending' ? 'warning' : 'success'}
                              size="small"
                              className="report-chip"
                            />
                          </TableCell>
                          <TableCell align="right">
                            <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
                              {report.pdfUrl && report.pdfUrl !== 'pending' && (
                                <Tooltip title="Download PDF">
                                  <IconButton 
                                    component={RouterLink}
                                    to={report.pdfUrl}
                                    target="_blank"
                                    className="report-action-button download-button"
                                    size="small"
                                  >
                                    <DownloadIcon />
                                  </IconButton>
                                </Tooltip>
                              )}
                              <Tooltip title="Delete Report">
                                <IconButton 
                                  onClick={(e) => handleOpenDeleteDialog(report, e)}
                                  className="report-action-button delete-button"
                                  size="small"
                                >
                                  <DeleteIcon />
                                </IconButton>
                              </Tooltip>
                            </Box>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              )}
            </CardContent>
          </Card>
        </Grid>
      </Grid>

      {/* Delete Confirmation Dialog */}
      <Dialog
        open={deleteDialog.open}
        onClose={handleCloseDeleteDialog}
      >
        <DialogTitle>
          Confirm Delete
        </DialogTitle>
        <DialogContent className="dialog-content">
          <DialogContentText>
            This action cannot be undone. This will permanently delete the report
            <strong>{deleteDialog.report ? ` "${deleteDialog.report.title || deleteDialog.report.name}"` : ''}</strong>.
          </DialogContentText>
          <DialogContentText sx={{ mt: 2 }}>
            To confirm, please type the name of the report:
          </DialogContentText>
          <TextField
            className="delete-confirmation-input"
            fullWidth
            value={confirmationName}
            onChange={(e) => setConfirmationName(e.target.value)}
            placeholder={deleteDialog.report ? deleteDialog.report.title || deleteDialog.report.name : ''}
            variant="outlined"
            size="small"
          />
        </DialogContent>
        <DialogActions>
          <Button 
            onClick={handleCloseDeleteDialog} 
            color="primary"
          >
            Cancel
          </Button>
          <Button 
            onClick={handleDeleteReport} 
            color="error"
            disabled={
              isDeleting || 
              !deleteDialog.report || 
              !confirmationName || 
              confirmationName !== (deleteDialog.report?.title || deleteDialog.report?.name)
            }
          >
            {isDeleting ? 'Deleting...' : 'Delete'}
          </Button>
        </DialogActions>
      </Dialog>
    </Layout>
  );
};

export default DashboardComponentTemplate; 

---
File: frontend/src/components/ViewReport/ViewReportComponent.js
---
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { useTheme, useMediaQuery } from '@mui/material';
import { useSnackbar } from 'notistack';
import { useAuth } from '../../contexts/AuthContext';
import api from '../../services/api';
import ViewReportComponentTemplate from './ViewReportComponent.jsx';

/**
 * Page component for viewing a generated report - contains only business logic
 */
const ViewReportComponent = () => {
  const { id } = useParams();
  const navigate = useNavigate();
  const theme = useTheme();
  const [report, setReport] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  // PDF generation status state
  const [pdfStatus, setPdfStatus] = useState('loading');
  const [pdfProgress, setPdfProgress] = useState(0);
  const [pdfPollInterval, setPdfPollInterval] = useState(null);

  useEffect(() => {
    const fetchReport = async () => {
      try {
        setLoading(true);
        const fetchedReport = await api.getReportById(id);
        
        // Initialize authors set with any existing report authors
        const authors = new Set();
        if (fetchedReport.author) {
          fetchedReport.author.split(', ').forEach(author => authors.add(author));
        }
        
        // Fetch commit details if we have commits
        if (fetchedReport.commits?.length > 0) {
          const commitIds = fetchedReport.commits.map(commit => 
            commit.sha || commit.commitId || commit.id
          ).filter(Boolean);
          
          if (commitIds.length > 0) {
            try {
              // Try to get detailed commit info with author and summary
              const commitDetails = await api.getCommitDetails({
                repository: fetchedReport.repository,
                commitIds
              });
              
              console.log('Commit details received:', commitDetails);
              
              // Merge the commit details with the existing commits
              fetchedReport.commits = fetchedReport.commits.map(commit => {
                const commitId = commit.sha || commit.commitId || commit.id;
                const details = commitDetails.find(c => c.commitId === commitId || c.id === commitId);
                
                // Add author to the set if available
                if (details?.author?.name) {
                  authors.add(details.author.name);
                } else if (details?.author?.login) {
                  authors.add(details.author.login);
                } else if (typeof details?.author === 'string') {
                  authors.add(details.author);
                }
                
                return details ? { ...commit, ...details } : commit;
              });
              
              // Update the report's allAuthors
              fetchedReport.allAuthors = Array.from(authors);
            } catch (detailsErr) {
              console.error('Error fetching commit details:', detailsErr);
              // Fallback to basic commit info if detailed info fails
              try {
                const commitInfo = await api.getCommitInfo({
                  repository: fetchedReport.repository,
                  commitIds
                });
                
                // Merge the commit info with the existing commits
                fetchedReport.commits = fetchedReport.commits.map(commit => {
                  const commitId = commit.sha || commit.commitId || commit.id;
                  const info = commitInfo.find(c => c.sha === commitId);
                  
                  // Add author to the set if available
                  if (info?.author?.name) {
                    authors.add(info.author.name);
                  } else if (info?.author?.login) {
                    authors.add(info.author.login);
                  } else if (typeof info?.author === 'string') {
                    authors.add(info.author);
                  }
                  
                  return info ? { ...commit, ...info } : commit;
                });
                
                // Update the report's allAuthors
                fetchedReport.allAuthors = Array.from(authors);
              } catch (infoErr) {
                console.error('Error fetching commit info:', infoErr);
              }
            }
          }
        }
        
        setReport(fetchedReport);
        setError(null);
      } catch (err) {
        console.error('Error fetching report:', err);
        setError('Failed to load report. Please try again.');
      } finally {
        setLoading(false);
      }
    };

    if (id) {
      fetchReport();
    }
  }, [id]);

  // Poll for PDF generation status
  useEffect(() => {
    // Function to check PDF generation status
    const checkPdfStatus = async () => {
      if (!id || !report || (report.pdfUrl && report.pdfUrl !== 'pending' && report.pdfUrl !== 'failed')) {
        // If we have a complete PDF URL, no need to poll
        clearInterval(pdfPollInterval);
        setPdfPollInterval(null);
        return;
      }

      try {
        const statusResponse = await api.getPdfStatus(id);
        console.log('PDF Status:', statusResponse);
        
        setPdfStatus(statusResponse.status);
        if (statusResponse.progress) {
          setPdfProgress(statusResponse.progress);
        }
        
        // If complete or failed, stop polling
        if (statusResponse.status === 'completed' || statusResponse.status === 'failed') {
          clearInterval(pdfPollInterval);
          setPdfPollInterval(null);
          
          // If completed, update the report with the new URLs
          if (statusResponse.status === 'completed' && statusResponse.viewUrl && statusResponse.downloadUrl) {
            setReport(prev => ({
              ...prev,
              viewUrl: statusResponse.viewUrl,
              downloadUrl: statusResponse.downloadUrl
            }));
          }
        }
      } catch (error) {
        console.error('Error checking PDF status:', error);
      }
    };

    // Start polling when component mounts and we have an ID
    if (id && report && !pdfPollInterval && (report.pdfUrl === 'pending' || report.pdfJobId)) {
      // Check immediately
      checkPdfStatus();
      
      // Then set up interval (every 3 seconds)
      const interval = setInterval(checkPdfStatus, 3000);
      setPdfPollInterval(interval);
    }

    // Clean up interval on unmount
    return () => {
      if (pdfPollInterval) {
        clearInterval(pdfPollInterval);
      }
    };
  }, [id, report, pdfPollInterval]);

  const handleNavigateBack = () => {
    navigate('/dashboard');
  };

  // Pass all required props to the template
  return (
    <ViewReportComponentTemplate
      loading={loading}
      error={error}
      report={report}
      pdfStatus={pdfStatus}
      pdfProgress={pdfProgress}
      handleNavigateBack={handleNavigateBack}
    />
  );
};

export default ViewReportComponent; 

---
File: frontend/src/components/ViewReport/ViewReportComponent.css
---
.view-report-container {
  animation: fadeIn 0.8s ease-in-out;
}

.back-button {
  border-radius: 8px;
  transition: all 0.2s;
}

.back-button:hover {
  transform: translateX(-5px);
}

.download-button {
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(77, 171, 245, 0.3);
}

.download-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(77, 171, 245, 0.4);
}

.error-alert {
  border-radius: 8px;
  border: 1px solid rgba(211, 47, 47, 0.3);
  margin-bottom: 24px;
}

.info-alert {
  border-radius: 8px;
  border: 1px solid rgba(3, 169, 244, 0.3);
  margin-bottom: 24px;
}

.loading-spinner {
  margin: 32px auto;
  display: block;
}

.pdf-preview-container {
  width: 100%;
  height: 600px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  overflow: hidden;
  position: relative;
}

.pdf-preview-status {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(18, 24, 36, 0.9);
  padding: 24px;
  text-align: center;
}

/* Animation for fade-in effect */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
} 

---
File: frontend/src/components/ViewReport/index.js
---
export { default } from './ViewReportComponent'; 

---
File: frontend/src/components/ViewReport/ViewReportComponent.jsx
---
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Alert,
  Box,
  Button,
  CircularProgress,
  Fade,
  Grid
} from '@mui/material';
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import Layout from '../../components/PagePartials/Layout';
import {
  ViewReportReportHeaderComponent,
  ViewReportReportMetadataComponent,
  ViewReportCommitListComponent,
  ViewReportPDFPreviewComponent
} from '../PagePartials/ViewReport';
import './ViewReportComponent.css';

const ViewReportComponentTemplate = ({
  loading,
  error,
  report,
  pdfStatus,
  pdfProgress,
  handleNavigateBack
}) => {
  if (loading) {
    return (
      <Layout title="Loading Report...">
        <Box sx={{ display: 'flex', justifyContent: 'center', my: 4 }}>
          <CircularProgress 
            size={60}
            thickness={4}
            className="loading-spinner"
          />
        </Box>
      </Layout>
    );
  }

  if (error) {
    return (
      <Layout title="Error">
        <Alert className="error-alert" severity="error">
          {error}
        </Alert>
        <Box sx={{ mt: 2 }}>
          <Button
            variant="contained"
            startIcon={<ArrowBackIcon />}
            component={RouterLink}
            to="/dashboard"
            className="back-button"
          >
            Back to Dashboard
          </Button>
        </Box>
      </Layout>
    );
  }

  if (!report) {
    return (
      <Layout title="Report Not Found">
        <Alert className="info-alert" severity="info">
          The requested report could not be found.
        </Alert>
        <Box sx={{ mt: 2 }}>
          <Button
            variant="contained"
            startIcon={<ArrowBackIcon />}
            component={RouterLink}
            to="/dashboard"
            className="back-button"
          >
            Back to Dashboard
          </Button>
        </Box>
      </Layout>
    );
  }

  return (
    <Layout title={report.name}>
      <Fade in={true} timeout={800}>
        <Box className="view-report-container">
          <ViewReportReportHeaderComponent report={report} />

          <Grid container spacing={3}>
            <Grid item xs={12}>
              <ViewReportReportMetadataComponent report={report} />
            </Grid>

            {/* Commit List Section */}
            <Grid item xs={12}>
              <ViewReportCommitListComponent commits={report.commits || []} />
            </Grid>

            {/* PDF Preview Section */}
            {report && (
              <Grid item xs={12}>
                <ViewReportPDFPreviewComponent 
                  report={report} 
                  pdfStatus={pdfStatus} 
                  pdfProgress={pdfProgress} 
                />
              </Grid>
            )}
          </Grid>
        </Box>
      </Fade>
    </Layout>
  );
};

export default ViewReportComponentTemplate; 

---
File: frontend/src/components/CreateReport/CreateReportComponent.css
---
.loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}


---
File: frontend/src/components/CreateReport/CreateReportComponent.js
---
import React, { useEffect } from 'react';
import { useNavigate } from 'react-router-dom';
import { useModal } from '../../contexts/ModalContext.js';
import CreateReportPageTemplate from './CreateReportPage.jsx';

/**
 * CreateReport page - Redirects to dashboard and opens the CreateReport modal
 */
const CreateReportPage = () => {
  const navigate = useNavigate();
  const { openCreateReportModal } = useModal();

  useEffect(() => {
    // Open the modal and redirect to dashboard
    openCreateReportModal();
    navigate('/dashboard');
  }, [navigate, openCreateReportModal]);

  // Show loading spinner while redirecting
  return <CreateReportPageTemplate />;
};

export default CreateReportPage;


---
File: frontend/src/components/CreateReport/index.js
---
export { default } from './CreateReportComponent';


---
File: frontend/src/components/CreateReport/CreateReportComponent.jsx
---
import React from 'react';
import { CircularProgress, Box } from '@mui/material';
import './CreateReportPage.css';

const CreateReportPageTemplate = () => {
  return (
    <Box className="loading-container">
      <CircularProgress />
    </Box>
  );
};

export default CreateReportPageTemplate;


---
File: frontend/src/components/PagePartials/AdminDashboard/index.js
---
export { default } from './AdminDashboardComponent';


---
File: frontend/src/components/PagePartials/AdminDashboard/AdminDashboardComponent.jsx
---
import React from 'react';
import {
  Box,
  Container,
  Typography,
  Paper,
  Grid,
  TextField,
  Autocomplete,
  Button,
  Alert,
  CircularProgress
} from '@mui/material';
import './AdminDashboardComponent.css';

const AdminDashboardComponentTemplate = ({
  user,
  users,
  selectedUser,
  newRole,
  message,
  loading,
  analytics,
  plans,
  selectedPlan,
  planLimits,
  onUserSelect,
  onRoleChange,
  onRoleUpdate,
  onPlanSelect,
  onLimitChange,
  onLimitsUpdate
}) => {
  if (!user || user.role !== 'admin') {
    return (
      <Container>
        <Alert severity="error">Access denied. Admin privileges required.</Alert>
      </Container>
    );
  }

  // Helper function to format numbers with commas
  const formatNumber = (num) => {
    return num ? num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",") : "0";
  };

  return (
    <Container maxWidth="lg" className="admin-dashboard-container">
      <Typography variant="h4" className="admin-dashboard-title">
        Admin Dashboard
      </Typography>

      {message.text && (
        <Alert severity={message.type} sx={{ mb: 2 }}>
          {message.text}
        </Alert>
      )}

      <Grid container spacing={3}>
        {/* User Management Section */}
        <Grid item xs={12} md={6}>
          <Paper className="admin-section">
            <Typography variant="h6" className="admin-section-title">
              User Management
            </Typography>
            
            <Autocomplete
              options={users}
              getOptionLabel={(option) => `${option.username} (${option.role})`}
              value={selectedUser}
              onChange={onUserSelect}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="Select User"
                  variant="outlined"
                  className="form-field"
                />
              )}
            />

            <TextField
              select
              fullWidth
              label="New Role"
              value={newRole}
              onChange={onRoleChange}
              SelectProps={{
                native: true,
              }}
              className="form-field"
            >
              <option value="user">User</option>
              <option value="admin">Admin</option>
            </TextField>

            <Button
              variant="contained"
              onClick={onRoleUpdate}
              disabled={!selectedUser || loading}
              className="action-button"
            >
              {loading ? <CircularProgress size={24} /> : 'Update Role'}
            </Button>
          </Paper>
        </Grid>

        {/* Plan Management Section */}
        <Grid item xs={12} md={6}>
          <Paper className="admin-section">
            <Typography variant="h6" className="admin-section-title">
              Plan Management
            </Typography>
            
            <Autocomplete
              options={plans}
              getOptionLabel={(option) => `${option.displayName} (${option.name})`}
              value={selectedPlan}
              onChange={onPlanSelect}
              renderInput={(params) => (
                <TextField
                  {...params}
                  label="Select Plan"
                  variant="outlined"
                  className="form-field"
                />
              )}
            />

            {selectedPlan && (
              <>
                <Typography variant="subtitle1" className="admin-section-subtitle">
                  Report Limits
                </Typography>
                <TextField
                  fullWidth
                  type="number"
                  label="Reports per Month"
                  value={planLimits.reportsPerMonth}
                  onChange={(e) => onLimitChange('reportsPerMonth', e.target.value)}
                  className="form-field"
                  helperText="This determines the number of standard reports allowed per month"
                />
                <Typography variant="body2" color="text.secondary" className="form-info">
                  Large reports allowed: {Math.floor(planLimits.reportsPerMonth * 0.1)}
                </Typography>

                <Typography variant="subtitle1" className="admin-section-subtitle">
                  Commits per Report
                </Typography>
                <TextField
                  fullWidth
                  type="number"
                  label="Commits per Standard Report"
                  value={planLimits.commitsPerStandardReport}
                  onChange={(e) => onLimitChange('commitsPerStandardReport', e.target.value)}
                  className="form-field"
                />
                <TextField
                  fullWidth
                  type="number"
                  label="Commits per Large Report"
                  value={planLimits.commitsPerLargeReport}
                  onChange={(e) => onLimitChange('commitsPerLargeReport', e.target.value)}
                  className="form-field"
                />

                <Button
                  variant="contained"
                  onClick={onLimitsUpdate}
                  disabled={loading}
                  className="action-button"
                >
                  {loading ? <CircularProgress size={24} /> : 'Update Plan Limits'}
                </Button>
              </>
            )}
          </Paper>
        </Grid>

        {/* System Analytics */}
        {analytics && (
          <>
            <Grid item xs={12}>
              <Typography variant="h6" gutterBottom>
                System Analytics
              </Typography>
            </Grid>

            {/* Key Metrics */}
            <Grid item xs={12} md={4}>
              <Paper className="stats-card">
                <Typography className="stats-card-title">
                  Total Users
                </Typography>
                <Typography className="stats-card-value">
                  {formatNumber(analytics.totalUsers)}
                </Typography>
                <Typography className="stats-card-description">
                  Active in the last 30 days: {formatNumber(analytics.activeUsers)}
                </Typography>
              </Paper>
            </Grid>

            <Grid item xs={12} md={4}>
              <Paper className="stats-card">
                <Typography className="stats-card-title">
                  Total Reports
                </Typography>
                <Typography className="stats-card-value">
                  {formatNumber(analytics.totalReports)}
                </Typography>
                <Typography className="stats-card-description">
                  Generated in the last 30 days: {formatNumber(analytics.reportsLastMonth)}
                </Typography>
              </Paper>
            </Grid>

            <Grid item xs={12} md={4}>
              <Paper className="stats-card">
                <Typography className="stats-card-title">
                  Total Commits Analyzed
                </Typography>
                <Typography className="stats-card-value">
                  {formatNumber(analytics.totalCommits)}
                </Typography>
                <Typography className="stats-card-description">
                  Analyzed in the last 30 days: {formatNumber(analytics.commitsLastMonth)}
                </Typography>
              </Paper>
            </Grid>

            {/* Monthly Stats */}
            <Grid item xs={12}>
              <Paper className="admin-section">
                <Typography variant="h6" className="admin-section-title">
                  Monthly Usage
                </Typography>

                <Grid container spacing={2}>
                  {analytics.monthlyUsage && analytics.monthlyUsage.map((month, index) => (
                    <Grid item xs={6} md={3} key={index}>
                      <Paper className="stats-card" sx={{ bgcolor: 'background.default' }}>
                        <Typography className="stats-card-title">
                          {month.month}
                        </Typography>
                        <Typography variant="body1">
                          Reports: {formatNumber(month.reports)}
                        </Typography>
                        <Typography variant="body1">
                          Commits: {formatNumber(month.commits)}
                        </Typography>
                        <Typography variant="body1">
                          Users: {formatNumber(month.users)}
                        </Typography>
                      </Paper>
                    </Grid>
                  ))}
                </Grid>
              </Paper>
            </Grid>
          </>
        )}
      </Grid>
    </Container>
  );
};

export default AdminDashboardComponentTemplate;


---
File: frontend/src/components/PagePartials/AdminDashboard/AdminDashboardComponent.css
---
.admin-dashboard-container {
  margin-top: 2rem;
  margin-bottom: 2rem;
}

.admin-dashboard-title {
  margin-bottom: 1rem;
}

.admin-section {
  padding: 1.5rem;
  margin-bottom: 1.5rem;
  border-radius: 8px;
}

.admin-section-title {
  margin-bottom: 1rem;
  font-weight: 600;
}

.admin-section-subtitle {
  margin-top: 1.5rem;
  margin-bottom: 0.5rem;
}

.form-field {
  margin-bottom: 1rem;
}

.form-info {
  margin-bottom: 1rem;
  font-size: 0.875rem;
  color: rgba(0, 0, 0, 0.6);
}

.stats-card {
  padding: 1.5rem;
  border-radius: 8px;
  background-color: #f5f5f5;
  height: 100%;
  display: flex;
  flex-direction: column;
}

.stats-card-title {
  font-size: 1rem;
  margin-bottom: 0.5rem;
  color: rgba(0, 0, 0, 0.7);
}

.stats-card-value {
  font-size: 2rem;
  font-weight: 600;
  margin-bottom: 0.5rem;
}

.stats-card-description {
  font-size: 0.875rem;
  color: rgba(0, 0, 0, 0.6);
  margin-top: auto;
}

.chart-container {
  height: 300px;
  width: 100%;
  margin-top: 1rem;
  margin-bottom: 1rem;
}

.action-button {
  margin-top: 1rem;
}


---
File: frontend/src/components/PagePartials/AdminDashboard/AdminDashboardComponent.js
---
import React, { useState, useEffect } from 'react';
import { useAuth } from '../../../contexts/AuthContext.js';
import api from '../../../services/api.js';
import AdminDashboardComponentTemplate from './AdminDashboardComponent.jsx';

/**
 * AdminDashboard component - Admin control panel for user and plan management
 */
const AdminDashboardComponent = () => {
  const { user } = useAuth();
  const [users, setUsers] = useState([]);
  const [selectedUser, setSelectedUser] = useState(null);
  const [newRole, setNewRole] = useState('user');
  const [message, setMessage] = useState({ type: '', text: '' });
  const [loading, setLoading] = useState(false);
  const [analytics, setAnalytics] = useState(null);
  const [plans, setPlans] = useState([]);
  const [selectedPlan, setSelectedPlan] = useState(null);
  const [planLimits, setPlanLimits] = useState({
    reportsPerMonth: 0,
    commitsPerStandardReport: 0,
    commitsPerLargeReport: 0
  });

  // Fetch data when component mounts
  useEffect(() => {
    fetchUsers();
    fetchAnalytics();
    fetchPlans();
  }, []);

  // Fetch users list
  const fetchUsers = async () => {
    try {
      const response = await api.getUsers();
      setUsers(response.users);
    } catch (error) {
      setMessage({ type: 'error', text: 'Failed to fetch users' });
    }
  };

  // Fetch analytics data
  const fetchAnalytics = async () => {
    try {
      const response = await api.getAdminAnalytics();
      setAnalytics(response.analytics);
    } catch (error) {
      setMessage({ type: 'error', text: 'Failed to fetch analytics' });
    }
  };

  // Fetch plans
  const fetchPlans = async () => {
    try {
      const response = await api.getPlans();
      setPlans(response.plans);
    } catch (error) {
      setMessage({ type: 'error', text: 'Failed to fetch plans' });
    }
  };

  // Handle user selection
  const handleUserSelect = (event, newValue) => {
    setSelectedUser(newValue);
    if (newValue) {
      setNewRole(newValue.role);
    }
  };

  // Handle role change
  const handleRoleChange = (event) => {
    setNewRole(event.target.value);
  };

  // Handle role update
  const handleRoleUpdate = async () => {
    if (!selectedUser) return;
    
    setLoading(true);
    try {
      await api.updateUserRole(selectedUser.id, newRole);
      setMessage({ type: 'success', text: 'User role updated successfully' });
      fetchUsers();
    } catch (error) {
      setMessage({ type: 'error', text: 'Failed to update user role' });
    } finally {
      setLoading(false);
    }
  };

  // Handle plan selection
  const handlePlanSelect = (event, newValue) => {
    setSelectedPlan(newValue);
    if (newValue) {
      setPlanLimits(newValue.limits);
    }
  };

  // Handle limit change
  const handleLimitChange = (field, value) => {
    setPlanLimits(prev => ({
      ...prev,
      [field]: parseInt(value) || 0
    }));
  };

  // Handle limits update
  const handleLimitsUpdate = async () => {
    if (!selectedPlan) return;
    
    setLoading(true);
    try {
      await api.updatePlanLimits(selectedPlan._id, planLimits);
      setMessage({ type: 'success', text: 'Plan limits updated successfully' });
      fetchPlans();
      setSelectedPlan(null);
      setPlanLimits({
        reportsPerMonth: 0,
        commitsPerStandardReport: 0,
        commitsPerLargeReport: 0
      });
    } catch (error) {
      setMessage({ type: 'error', text: 'Failed to update plan limits' });
    } finally {
      setLoading(false);
    }
  };

  return (
    <AdminDashboardComponentTemplate
      user={user}
      users={users}
      selectedUser={selectedUser}
      newRole={newRole}
      message={message}
      loading={loading}
      analytics={analytics}
      plans={plans}
      selectedPlan={selectedPlan}
      planLimits={planLimits}
      onUserSelect={handleUserSelect}
      onRoleChange={handleRoleChange}
      onRoleUpdate={handleRoleUpdate}
      onPlanSelect={handlePlanSelect}
      onLimitChange={handleLimitChange}
      onLimitsUpdate={handleLimitsUpdate}
    />
  );
};

export default AdminDashboardComponent;


---
File: frontend/src/components/PagePartials/ViewReport/index.js
---
export { default as ViewReportReportHeaderComponent } from './ReportHeader';
export { default as ViewReportReportMetadataComponent } from './ReportMetadata';
export { default as ViewReportCommitListComponent } from './CommitList';
export { default as ViewReportPDFPreviewComponent } from './PDFPreview'; 

---
File: frontend/src/components/PagePartials/ViewReport/PDFPreview/ViewReportPDFPreviewComponent.css
---
.pdf-preview-card {
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.3s ease;
}

.pdf-preview-card:hover {
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}

.card-content {
  padding: 24px;
}

.card-header {
  display: flex;
  align-items: center;
  margin-bottom: 16px;
}

.header-icon {
  margin-right: 8px;
}

.header-title {
  font-weight: 600;
  margin: 0;
}

.divider {
  margin-bottom: 24px;
}

.pdf-container {
  width: 100%;
  height: 600px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  overflow: hidden;
  position: relative;
}

.pdf-loading-container, 
.pdf-error-container,
.pdf-fallback-container {
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background-color: rgba(18, 24, 36, 0.9);
  padding: 24px;
  text-align: center;
}

.pdf-loading-spinner {
  margin-bottom: 24px;
}

.pdf-status-message,
.pdf-error-message,
.pdf-fallback-message {
  margin-bottom: 8px;
  max-width: 500px;
}

.pdf-status-info {
  max-width: 500px;
}

.dashboard-button,
.download-button {
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(77, 171, 245, 0.3);
  margin-top: 24px;
  transition: all 0.2s ease;
}

.dashboard-button:hover,
.download-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(77, 171, 245, 0.4);
}

.pdf-iframe {
  border: none;
  background-color: white;
} 

---
File: frontend/src/components/PagePartials/ViewReport/PDFPreview/index.js
---
export { default } from './ViewReportPDFPreviewComponent'; 

---
File: frontend/src/components/PagePartials/ViewReport/PDFPreview/ViewReportPDFPreviewComponent.js
---
import React, { useEffect, useRef, useState } from 'react';
import ViewReportPDFPreviewComponentTemplate from './ViewReportPDFPreviewComponent.jsx';

/**
 * Component for previewing PDFs with various states (loading, failed, preview)
 */
const ViewReportPDFPreviewComponent = ({ 
  report, 
  pdfStatus = 'loading', 
  pdfProgress = 0 
}) => {
  const iframeRef = useRef(null);
  const [pdfPreviewFailed, setPdfPreviewFailed] = useState(false);
  const [scale, setScale] = useState(1);
  const [numPages, setNumPages] = useState(null);
  const [pageNumber, setPageNumber] = useState(1);

  useEffect(() => {
    // Check if PDF preview is available after component mounts
    const checkPdfPreview = () => {
      try {
        const iframe = iframeRef.current;
        if (iframe) {
          // If the iframe is empty or throws an error, show fallback
          setTimeout(() => {
            try {
              // Check if iframe content is accessible
              const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
              // If empty or has an error message
              if (!iframeDoc || iframeDoc.body.innerHTML === '' || 
                  iframeDoc.body.innerHTML.includes('error')) {
                setPdfPreviewFailed(true);
              }
            } catch (err) {
              // Cross-origin errors will be caught here
              setPdfPreviewFailed(true);
            }
          }, 3000); // Give it 3 seconds to load
        }
      } catch (e) {
        setPdfPreviewFailed(true);
      }
    };

    if (report?.downloadUrl && pdfStatus !== 'pending' && pdfStatus !== 'failed') {
      checkPdfPreview();
    }
  }, [report, pdfStatus]);

  const handleIframeLoad = (e) => {
    try {
      const iframe = e.target;
      const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;
      if (!iframeDoc || iframeDoc.body.innerHTML === '') {
        setPdfPreviewFailed(true);
      }
    } catch (err) {
      setPdfPreviewFailed(true);
    }
  };

  const handleIframeError = () => {
    setPdfPreviewFailed(true);
  };

  const handleDocumentLoadSuccess = ({ numPages }) => {
    setNumPages(numPages);
  };

  const handleZoomIn = () => {
    setScale(prevScale => Math.min(prevScale + 0.2, 2.5));
  };

  const handleZoomOut = () => {
    setScale(prevScale => Math.max(prevScale - 0.2, 0.5));
  };

  const handlePrevPage = () => {
    setPageNumber(prevPageNumber => Math.max(prevPageNumber - 1, 1));
  };

  const handleNextPage = () => {
    setPageNumber(prevPageNumber => Math.min(prevPageNumber + 1, numPages));
  };

  return (
    <ViewReportPDFPreviewComponentTemplate
      report={report}
      pdfStatus={pdfStatus}
      pdfProgress={pdfProgress}
      pdfPreviewFailed={pdfPreviewFailed}
      iframeRef={iframeRef}
      handleIframeLoad={handleIframeLoad}
      handleIframeError={handleIframeError}
      scale={scale}
      numPages={numPages}
      pageNumber={pageNumber}
      handleDocumentLoadSuccess={handleDocumentLoadSuccess}
      handleZoomIn={handleZoomIn}
      handleZoomOut={handleZoomOut}
      handlePrevPage={handlePrevPage}
      handleNextPage={handleNextPage}
    />
  );
};

export default ViewReportPDFPreviewComponent; 

---
File: frontend/src/components/PagePartials/ViewReport/PDFPreview/ViewReportPDFPreviewComponent.jsx
---
import React from 'react';
import { useNavigate } from 'react-router-dom';
import {
  Box,
  Button,
  Card,
  CardContent,
  CircularProgress,
  Divider,
  Typography,
  useTheme
} from '@mui/material';
import DescriptionIcon from '@mui/icons-material/Description';
import DownloadIcon from '@mui/icons-material/Download';
import './ViewReportPDFPreviewComponent.css';

const ViewReportPDFPreviewComponentTemplate = ({ 
  report, 
  pdfStatus = 'loading', 
  pdfProgress = 0,
  pdfPreviewFailed,
  iframeRef,
  handleIframeLoad,
  handleIframeError
}) => {
  const theme = useTheme();
  const navigate = useNavigate();

  return (
    <Card 
      className="pdf-preview-card"
      sx={{
        backgroundImage: theme.palette.background.cardGradient,
      }}
    >
      <CardContent className="card-content">
        <Box className="card-header">
          <DescriptionIcon className="header-icon" sx={{ color: theme.palette.primary.main }} />
          <Typography 
            variant="h5" 
            component="h2" 
            className="header-title"
            sx={{ 
              background: 'linear-gradient(90deg, #fff, #81d4fa)',
              backgroundClip: 'text',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
            }}
          >
            Report Preview
          </Typography>
        </Box>
        
        <Divider className="divider" />

        <Box className="pdf-container">
          {pdfStatus === 'pending' || pdfStatus === 'waiting' || pdfStatus === 'active' ? (
            <Box className="pdf-loading-container">
              <CircularProgress 
                variant={pdfProgress > 0 ? "determinate" : "indeterminate"} 
                value={pdfProgress}
                size={60}
                thickness={4}
                className="pdf-loading-spinner"
              />
              <Typography variant="h6" gutterBottom>
                Generating PDF Report
              </Typography>
              <Typography variant="body2" color="text.secondary" className="pdf-status-message">
                {pdfStatus === 'active' 
                  ? `Processing... (${pdfProgress}% complete)`
                  : "Your report is being generated. This may take a moment..."}
              </Typography>
              <Typography variant="body2" color="text.secondary" className="pdf-status-info">
                You can check back later or wait on this page. The report will automatically update when ready.
              </Typography>
            </Box>
          ) : pdfStatus === 'failed' ? (
            <Box className="pdf-error-container">
              <Typography variant="h6" gutterBottom color="error">
                PDF Generation Failed
              </Typography>
              <Typography variant="body2" color="text.secondary" className="pdf-error-message">
                There was a problem generating your PDF. Please try again or contact support if the issue persists.
              </Typography>
              <Button
                variant="contained"
                color="primary"
                onClick={() => navigate('/dashboard')}
                className="dashboard-button"
              >
                Back to Dashboard
              </Button>
            </Box>
          ) : report?.downloadUrl && !pdfPreviewFailed ? (
            <iframe
              ref={iframeRef}
              src={`https://docs.google.com/viewer?url=${encodeURIComponent(report.downloadUrl)}&embedded=true`}
              width="100%"
              height="100%"
              frameBorder="0"
              allowFullScreen
              title="Report Document Viewer"
              onLoad={handleIframeLoad}
              onError={handleIframeError}
              className="pdf-iframe"
            />
          ) : (
            <Box className="pdf-fallback-container">
              <Typography variant="h6" gutterBottom>
                PDF Preview not available
              </Typography>
              <Typography variant="body2" color="text.secondary" className="pdf-fallback-message">
                {report?.downloadUrl ? 
                  "Your browser doesn't support the embedded PDF viewer or the document couldn't be loaded. Please use the button below to download and view the report." :
                  "The PDF download is not available yet. Please check back later."}
              </Typography>
              {report?.downloadUrl && (
                <Button
                  variant="contained"
                  color="primary"
                  startIcon={<DownloadIcon />}
                  href={report.downloadUrl}
                  target="_blank"
                  className="download-button"
                >
                  Download Report
                </Button>
              )}
            </Box>
          )}
        </Box>
      </CardContent>
    </Card>
  );
};

export default ViewReportPDFPreviewComponentTemplate; 

---
File: frontend/src/components/PagePartials/ViewReport/ReportMetadata/index.js
---
export { default } from './ViewReportReportMetadataComponent'; 

---
File: frontend/src/components/PagePartials/ViewReport/ReportMetadata/ViewReportReportMetadataComponent.css
---
.metadata-card {
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.3s ease;
}

.metadata-card:hover {
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}

.card-content {
  padding: 24px;
}

.card-header {
  display: flex;
  align-items: center;
  margin-bottom: 16px;
}

.header-icon {
  margin-right: 8px;
}

.header-title {
  font-weight: 600;
  margin: 0;
}

.divider {
  margin-bottom: 24px;
}

.metadata-container {
  margin-bottom: 24px;
}

.metadata-item {
  padding: 16px;
  border-radius: 8px;
  background-color: rgba(255, 255, 255, 0.03);
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: center;
}

.metadata-label {
  display: flex;
  align-items: center;
  margin-bottom: 4px;
}

.metadata-icon {
  margin-right: 8px;
  opacity: 0.7;
}

.metadata-value {
  font-weight: 500;
}

.author-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 8px;
}

.author-chip {
  border-radius: 4px;
}

.author-chip .MuiChip-label {
  padding: 0 8px;
}

.date-range {
  display: flex;
  align-items: center;
}

.date-chip {
  border-radius: 4px;
}

.date-separator {
  margin: 0 8px;
} 

---
File: frontend/src/components/PagePartials/ViewReport/ReportMetadata/ViewReportReportMetadataComponent.jsx
---
import React from 'react';
import {
  Box,
  Card,
  CardContent,
  Chip,
  Divider,
  Grid,
  Paper,
  Typography,
  useTheme
} from '@mui/material';
import GitHubIcon from '@mui/icons-material/GitHub';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import PersonIcon from '@mui/icons-material/Person';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import VisibilityIcon from '@mui/icons-material/Visibility';
import './ViewReportReportMetadataComponent.css';

const ViewReportReportMetadataComponentTemplate = ({ report, formatDate }) => {
  const theme = useTheme();

  return (
    <Card 
      className="metadata-card"
      sx={{
        backgroundImage: theme.palette.background.cardGradient,
      }}
    >
      <CardContent className="card-content">
        <Box className="card-header">
          <GitHubIcon className="header-icon" sx={{ color: theme.palette.primary.main }} />
          <Typography 
            variant="h5" 
            component="h2" 
            className="header-title"
            sx={{ 
              background: 'linear-gradient(90deg, #fff, #81d4fa)',
              backgroundClip: 'text',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
            }}
          >
            Report Details
          </Typography>
        </Box>
        
        <Divider className="divider" />

        <Box className="metadata-container">
          <Grid container spacing={2}>
            {/* Repository Card */}
            <Grid item xs={12} sm={6}>
              <Paper
                className="metadata-item"
                elevation={0}
              >
                <Box className="metadata-label">
                  <GitHubIcon fontSize="small" className="metadata-icon" />
                  <Typography variant="body2" color="text.secondary">Repository</Typography>
                </Box>
                <Typography variant="h6" className="metadata-value">{report?.repository}</Typography>
              </Paper>
            </Grid>
            
            {/* Authors Card */}
            {report?.allAuthors && report.allAuthors.length > 0 && (
              <Grid item xs={12} sm={6}>
                <Paper
                  className="metadata-item"
                  elevation={0}
                >
                  <Box className="metadata-label">
                    <PersonIcon fontSize="small" className="metadata-icon" />
                    <Typography variant="body2" color="text.secondary">
                      {report.allAuthors.length > 1 ? 'Authors' : 'Author'}
                    </Typography>
                  </Box>
                  <Box className="author-chips">
                    {report.allAuthors.map((author, index) => (
                      <Chip
                        key={index}
                        label={author}
                        size="small"
                        className="author-chip"
                        sx={{ 
                          backgroundColor: 'rgba(77, 171, 245, 0.1)',
                          borderColor: 'rgba(77, 171, 245, 0.3)',
                        }}
                      />
                    ))}
                  </Box>
                </Paper>
              </Grid>
            )}

            {/* Date Range Card */}
            <Grid item xs={12} sm={6}>
              <Paper
                className="metadata-item"
                elevation={0}
              >
                <Box className="metadata-label">
                  <CalendarTodayIcon fontSize="small" className="metadata-icon" />
                  <Typography variant="body2" color="text.secondary">Date Range</Typography>
                </Box>
                <Box className="date-range">
                  <Chip
                    label={formatDate(report?.startDate)}
                    size="small"
                    className="date-chip"
                    sx={{ 
                      backgroundColor: 'rgba(77, 171, 245, 0.1)',
                      borderColor: 'rgba(77, 171, 245, 0.3)',
                    }}
                  />
                  <Typography variant="body2" className="date-separator">to</Typography>
                  <Chip
                    label={formatDate(report?.endDate)}
                    size="small"
                    className="date-chip"
                    sx={{ 
                      backgroundColor: 'rgba(77, 171, 245, 0.1)',
                      borderColor: 'rgba(77, 171, 245, 0.3)'
                    }}
                  />
                </Box>
              </Paper>
            </Grid>
            
            {/* Branch Card */} 
            <Grid item xs={12} sm={6}>
              <Paper
                className="metadata-item"
                elevation={0}
              >
                <Box className="metadata-label">
                  <PersonIcon fontSize="small" className="metadata-icon" />
                  <Typography variant="body2" color="text.secondary">
                    Branch
                  </Typography>
                </Box>
                <Typography variant="h6" className="metadata-value">
                  {report?.branch || 'main'}
                </Typography>
              </Paper>
            </Grid>
            
            {/* Created Card */}
            <Grid item xs={12} sm={6}>
              <Paper
                className="metadata-item"
                elevation={0}
              >
                <Box className="metadata-label">
                  <AccessTimeIcon fontSize="small" className="metadata-icon" />
                  <Typography variant="body2" color="text.secondary">Created</Typography>
                </Box>
                <Typography variant="h6" className="metadata-value">{formatDate(report?.createdAt)}</Typography>
              </Paper>
            </Grid>
            
            {/* Access Count Card */}
            {report?.accessCount && (
              <Grid item xs={12} sm={6}>
                <Paper
                  className="metadata-item"
                  elevation={0}
                >
                  <Box className="metadata-label">
                    <VisibilityIcon fontSize="small" className="metadata-icon" />
                    <Typography variant="body2" color="text.secondary">Access Count</Typography>
                  </Box>
                  <Typography variant="h6" className="metadata-value">{report.accessCount}</Typography>
                </Paper>
              </Grid>
            )}
          </Grid>
        </Box>
      </CardContent>
    </Card>
  );
};

export default ViewReportReportMetadataComponentTemplate; 

---
File: frontend/src/components/PagePartials/ViewReport/ReportMetadata/ViewReportReportMetadataComponent.js
---
import React from 'react';
import ViewReportReportMetadataComponentTemplate from './ViewReportReportMetadataComponent.jsx';

/**
 * Component that displays metadata information for a report
 */
const ViewReportReportMetadataComponent = ({ report }) => {
  // Format date for display
  const formatDate = (dateString) => {
    if (!dateString) return 'Unknown';
    
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  return (
    <ViewReportReportMetadataComponentTemplate
      report={report}
      formatDate={formatDate}
    />
  );
};

export default ViewReportReportMetadataComponent; 

---
File: frontend/src/components/PagePartials/ViewReport/ReportHeader/index.js
---
export { default } from './ViewReportReportHeaderComponent'; 

---
File: frontend/src/components/PagePartials/ViewReport/ReportHeader/ViewReportReportHeaderComponent.css
---
.report-header {
  margin-bottom: 32px;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
  align-items: flex-start;
  gap: 16px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
  padding-bottom: 24px;
}

.back-button {
  border-radius: 8px;
  transition: all 0.2s;
}

.back-button:hover {
  transform: translateX(-5px);
}

.action-buttons {
  display: flex;
  gap: 16px;
  margin-top: 8px;
}

.download-button {
  border-radius: 8px;
  transition: all 0.2s;
}

.download-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(77, 171, 245, 0.4);
}

/* Media query for medium screens and above */
@media (min-width: 960px) {
  .report-header {
    flex-direction: row;
    align-items: center;
  }
  
  .action-buttons {
    margin-top: 0;
  }
} 

---
File: frontend/src/components/PagePartials/ViewReport/ReportHeader/ViewReportReportHeaderComponent.jsx
---
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Button,
  Fade,
  Zoom,
  useTheme,
  Typography
} from '@mui/material';
import {
  ArrowBack as ArrowBackIcon,
  Download as DownloadIcon,
  Description as DescriptionIcon
} from '@mui/icons-material';
import './ViewReportReportHeaderComponent.css';

/**
 * Template component for the report header
 */
const ViewReportReportHeaderComponentTemplate = ({ report }) => {
  const theme = useTheme();

  return (
    <Box className="report-header-container">
      <Box className="report-header-top">
        <Button
          component={RouterLink}
          to="/dashboard"
          startIcon={<ArrowBackIcon />}
          className="back-button"
          variant="outlined"
          size="small"
        >
          Back to Dashboard
        </Button>
      </Box>

      <Box className="report-title-section">
        <DescriptionIcon className="report-icon" sx={{ color: theme.palette.primary.main }} />
        <Box>
          <Typography variant="h4" component="h1" className="report-title">
            {report.title || report.name || 'Untitled Report'}
          </Typography>
          <Typography variant="subtitle1" color="text.secondary" className="report-subtitle">
            {report.description || 'No description provided'}
          </Typography>
        </Box>
      </Box>
    </Box>
  );
};

export default ViewReportReportHeaderComponentTemplate; 

---
File: frontend/src/components/PagePartials/ViewReport/ReportHeader/ViewReportReportHeaderComponent.js
---
import React from 'react';
import ViewReportReportHeaderComponentTemplate from './ViewReportReportHeaderComponent.jsx';

/**
 * Component that displays the header for a report view
 */
const ViewReportReportHeaderComponent = ({ report }) => {
  return (
    <ViewReportReportHeaderComponentTemplate report={report} />
  );
};

export default ViewReportReportHeaderComponent; 

---
File: frontend/src/components/PagePartials/ViewReport/CommitList/ViewReportCommitListComponent.jsx
---
import React from 'react';
import {
  Box,
  Card,
  CardContent,
  Divider,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Tooltip,
  Typography,
  useTheme
} from '@mui/material';
import GitHubIcon from '@mui/icons-material/GitHub';
import PersonIcon from '@mui/icons-material/Person';
import './ViewReportCommitListComponent.css';

const ViewReportCommitListComponentTemplate = ({ commits = [], formatDate }) => {
  const theme = useTheme();

  return (
    <Card 
      className="commit-list-card"
      sx={{
        backgroundImage: theme.palette.background.cardGradient,
      }}
    >
      <CardContent className="card-content">
        <Box className="card-header">
          <GitHubIcon className="header-icon" sx={{ color: theme.palette.primary.main }} />
          <Typography 
            variant="h5" 
            component="h2" 
            className="header-title"
            sx={{ 
              background: 'linear-gradient(90deg, #fff, #81d4fa)',
              backgroundClip: 'text',
              WebkitBackgroundClip: 'text',
              WebkitTextFillColor: 'transparent',
            }}
          >
            Included Commits
          </Typography>
        </Box>
        
        <Divider className="divider" />

        <TableContainer>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell className="table-header-cell">Commit ID</TableCell>
                <TableCell className="table-header-cell">Author</TableCell>
                <TableCell className="table-header-cell">Message</TableCell>
                <TableCell className="table-header-cell">Date</TableCell>
                <TableCell className="table-header-cell">Summary</TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {commits.map((commit) => (
                <TableRow 
                  key={commit.id || commit._id || commit.sha}
                  className="table-row"
                >
                  <TableCell className="commit-id-cell">
                    {commit.id?.substring(0, 7) || 
                     commit.sha?.substring(0, 7) || 
                     commit.hash?.substring(0, 7) || 
                     commit.commitId?.substring(0, 7) || 
                     'N/A'}
                  </TableCell>
                  <TableCell>
                    <Box className="author-container">
                      <PersonIcon className="author-icon" />
                      <Typography variant="body2">
                        {commit.author?.name || commit.author?.login || 'Unknown'}
                      </Typography>
                    </Box>
                  </TableCell>
                  <TableCell>
                    <Tooltip 
                      title={
                        <Typography variant="body2" className="tooltip-text">
                          {commit.message || commit.description || 'No message'}
                        </Typography>
                      }
                      arrow
                      placement="top"
                    >
                      <Typography 
                        variant="body2" 
                        color="text.secondary"
                        className="truncated-text"
                      >
                        {commit.message || commit.description || 'No message'}
                      </Typography>
                    </Tooltip>
                  </TableCell>
                  <TableCell>
                    {commit.date ? formatDate(commit.date) : 
                     (commit.timestamp ? formatDate(commit.timestamp) : 'No date')}
                  </TableCell>
                  <TableCell>
                    <Tooltip 
                      title={
                        <Typography variant="body2" className="tooltip-text">
                          {commit.summary || commit.aiSummary || 'No summary available'}
                        </Typography>
                      }
                      arrow
                      placement="top"
                    >
                      <Typography 
                        variant="body2" 
                        color="text.secondary"
                        className="truncated-text"
                      >
                        {commit.summary || commit.aiSummary || 'No summary available'}
                      </Typography>
                    </Tooltip>
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      </CardContent>
    </Card>
  );
};

export default ViewReportCommitListComponentTemplate; 

---
File: frontend/src/components/PagePartials/ViewReport/CommitList/index.js
---
export { default } from './ViewReportCommitListComponent'; 

---
File: frontend/src/components/PagePartials/ViewReport/CommitList/ViewReportCommitListComponent.css
---
.commit-list-card {
  border: 1px solid rgba(255, 255, 255, 0.05);
  border-radius: 12px;
  overflow: hidden;
  transition: all 0.3s ease;
}

.commit-list-card:hover {
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
}

.card-content {
  padding: 24px;
}

.card-header {
  display: flex;
  align-items: center;
  margin-bottom: 16px;
}

.header-icon {
  margin-right: 8px;
}

.header-title {
  font-weight: 600;
  margin: 0;
}

.divider {
  margin-bottom: 24px;
}

.table-header-cell {
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  font-weight: 600;
}

.table-row {
  transition: background-color 0.2s ease;
}

.table-row:hover {
  background-color: rgba(255, 255, 255, 0.03);
}

.commit-id-cell {
  font-family: 'JetBrains Mono', monospace;
  font-size: 0.875rem;
}

.author-container {
  display: flex;
  align-items: center;
}

.author-icon {
  margin-right: 8px;
  font-size: 1rem;
  opacity: 0.7;
}

.truncated-text {
  max-width: 300px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  cursor: help;
}

.tooltip-text {
  white-space: pre-wrap;
} 

---
File: frontend/src/components/PagePartials/ViewReport/CommitList/ViewReportCommitListComponent.js
---
import React from 'react';
import ViewReportCommitListComponentTemplate from './ViewReportCommitListComponent.jsx';

/**
 * Component that displays a table of commits included in a report
 */
const ViewReportCommitListComponent = ({ commits = [] }) => {
  // Format date for display
  const formatDate = (dateString) => {
    if (!dateString) return 'No date';
    
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric'
    });
  };

  return (
    <ViewReportCommitListComponentTemplate 
      commits={commits}
      formatDate={formatDate}
    />
  );
};

export default ViewReportCommitListComponent; 

---
File: frontend/src/components/PagePartials/DiffViewer/index.js
---
export { default } from './DiffViewerComponent';


---
File: frontend/src/components/PagePartials/DiffViewer/DiffViewerComponent.js
---
import React from 'react';
import { useTheme } from '@mui/material';
import DiffViewerComponentTemplate from './DiffViewerComponent.jsx';

/**
 * DiffViewer component that displays code diffs with syntax highlighting
 * @param {string} patch - The patch/diff text from Git
 */
const DiffViewerComponent = ({ patch }) => {
  const theme = useTheme();
  
  // In this simple case, there's not much business logic,
  // but in a more complex component we could handle:
  // - Parsing and formatting the diff
  // - Collapsing/expanding sections
  // - Line highlighting logic
  // - Handling user interactions

  return <DiffViewerComponentTemplate patch={patch} theme={theme} />;
};

export default DiffViewerComponent;


---
File: frontend/src/components/PagePartials/DiffViewer/DiffViewerComponent.jsx
---
import React from 'react';
import { Box } from '@mui/material';
import './DiffViewerComponent.css';

const DiffViewerComponentTemplate = ({ patch, theme }) => {
  if (!patch) {
    return (
      <Box className="diff-viewer">
        <Box className="diff-content">
          <Box className="diff-line">
            <Box className="line-content">No diff available</Box>
          </Box>
        </Box>
      </Box>
    );
  }

  const lines = patch.split('\n');

  return (
    <Box className="diff-viewer">
      <Box className="diff-content">
        {lines.map((line, index) => {
          let lineType = '';
          if (line.startsWith('+')) {
            lineType = 'addition';
          } else if (line.startsWith('-')) {
            lineType = 'deletion';
          } else if (line.startsWith('@')) {
            lineType = 'info';
          }

          return (
            <Box key={index} className={`diff-line ${lineType}`}>
              <Box className="line-number">{index + 1}</Box>
              <Box className="line-content">{line}</Box>
            </Box>
          );
        })}
      </Box>
    </Box>
  );
};

export default DiffViewerComponentTemplate;


---
File: frontend/src/components/PagePartials/DiffViewer/DiffViewerComponent.css
---
.diff-viewer {
  font-family: Consolas, Monaco, "Andale Mono", monospace;
  font-size: 0.85rem;
  line-height: 1.5;
  white-space: pre-wrap;
  overflow: auto;
  width: 100%;
}

.diff-header {
  padding: 8px 16px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.12);
  font-weight: bold;
}

.diff-content {
  padding: 0;
}

.diff-line {
  padding: 0 8px;
  display: flex;
}

.diff-line:hover {
  background-color: rgba(0, 0, 0, 0.04);
}

.line-number {
  color: rgba(0, 0, 0, 0.6);
  padding-right: 16px;
  text-align: right;
  user-select: none;
  border-right: 1px solid rgba(0, 0, 0, 0.12);
  min-width: 2.5rem;
}

.line-content {
  padding-left: 16px;
  width: 100%;
}

.addition {
  background-color: rgba(0, 255, 0, 0.1);
}

.deletion {
  background-color: rgba(255, 0, 0, 0.1);
}

.info {
  background-color: rgba(0, 0, 255, 0.05);
}


---
File: frontend/src/components/PagePartials/PrivateRoute/index.js
---
export { default } from './PrivateRouteComponent';


---
File: frontend/src/components/PagePartials/PrivateRoute/PrivateRouteComponent.jsx
---
import React from 'react';
import { Navigate } from 'react-router-dom';
import { CircularProgress, Box } from '@mui/material';
import './PrivateRouteComponent.css';

const PrivateRouteComponentTemplate = ({ children, isLoading, isAuthenticated, location }) => {
  // Show loading spinner while checking authentication
  if (isLoading) {
    return (
      <Box
        className="auth-loading-container"
        sx={{
          backgroundColor: 'background.default'
        }}
      >
        <CircularProgress />
      </Box>
    );
  }

  // Redirect to login if not authenticated
  if (!isAuthenticated) {
    // Pass the current location to redirect back after login
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  // Render children if authenticated
  return children;
};

export default PrivateRouteComponentTemplate;


---
File: frontend/src/components/PagePartials/PrivateRoute/PrivateRouteComponent.css
---
.auth-loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  width: 100vw;
}


---
File: frontend/src/components/PagePartials/PrivateRoute/PrivateRouteComponent.js
---
import React, { useContext, useEffect, useState } from 'react';
import { useLocation } from 'react-router-dom';
import { AuthContext } from '../../../contexts/AuthContext.js';
import PrivateRouteComponentTemplate from './PrivateRouteComponent.jsx';

/**
 * Private route component to protect authenticated routes
 * @param {Object} props - Component props
 * @param {React.ReactNode} props.children - Child components to render when authenticated
 */
const PrivateRouteComponent = ({ children }) => {
  const { isAuthenticated, loading, checkAuth } = useContext(AuthContext);
  const location = useLocation();
  const [checkingAuth, setCheckingAuth] = useState(false);
  const [hasCheckedAuth, setHasCheckedAuth] = useState(false);

  // Recheck authentication when the component mounts or the route changes
  useEffect(() => {
    // Only check authentication once initially or if we explicitly need to recheck
    // (not on every route change)
    if (!loading && !checkingAuth && !hasCheckedAuth) {
      setCheckingAuth(true);
      checkAuth().finally(() => {
        setCheckingAuth(false);
        setHasCheckedAuth(true);
      });
    }
  }, [checkAuth, loading, checkingAuth, hasCheckedAuth]);

  // Determine if we're still loading
  const isLoading = loading || checkingAuth;

  // Log redirect for debugging purposes
  if (!isLoading && !isAuthenticated) {
    console.log("PrivateRoute: User not authenticated, redirecting to login");
  }

  return (
    <PrivateRouteComponentTemplate
      children={children}
      isLoading={isLoading}
      isAuthenticated={isAuthenticated}
      location={location}
    />
  );
};

export default PrivateRouteComponent;


---
File: frontend/src/components/PagePartials/Layout/index.js
---
export { default } from './LayoutComponent';


---
File: frontend/src/components/PagePartials/Layout/LayoutComponent.jsx
---
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  AppBar,
  Box,
  Button,
  Container,
  Drawer,
  IconButton,
  List,
  ListItem,
  ListItemButton,
  ListItemIcon,
  ListItemText,
  Toolbar,
  Typography,
  Avatar,
  Tooltip,
  Fade,
  Badge,
  Divider
} from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import DashboardIcon from '@mui/icons-material/Dashboard';
import NoteAddIcon from '@mui/icons-material/NoteAdd';
import LogoutIcon from '@mui/icons-material/Logout';
import GitHubIcon from '@mui/icons-material/GitHub';
import KeyboardArrowRightIcon from '@mui/icons-material/KeyboardArrowRight';
import AdminPanelSettingsIcon from '@mui/icons-material/AdminPanelSettings';
import AnalyticsIcon from '@mui/icons-material/Analytics';
import './LayoutComponent.css';

const LayoutComponentTemplate = ({
  children,
  title,
  user,
  handleLogout,
  isMobile,
  drawerOpen,
  toggleDrawer,
  activeLink,
  animate,
  theme
}) => {
  // Define menu items
  const menuItems = [
    {
      text: 'Dashboard',
      icon: <DashboardIcon />,
      path: '/dashboard'
    },
    {
      text: 'Create Report',
      icon: <NoteAddIcon />,
      path: '/create-report'
    },
    {
      text: 'Analytics',
      icon: <AnalyticsIcon />,
      path: '/analytics'
    }
  ];

  // Drawer content component
  const drawer = (
    <Box
      className="drawer-container"
      sx={{
        bgcolor: 'background.paper',
        borderColor: 'divider'
      }}
    >
      <Box className="drawer-header">
        <Typography variant="h6" sx={{ fontWeight: 600 }}>
          GitStatus
        </Typography>
      </Box>
      <Divider />
      <List className="drawer-list">
        {user?.role === 'admin' && (
          <ListItem disablePadding className="menu-item">
            <ListItemButton 
              component={RouterLink} 
              to="/admin"
              className={`menu-button-item ${activeLink === '/admin' ? 'menu-button-active' : ''}`}
              sx={{
                '&:before': activeLink === '/admin' ? {
                  backgroundColor: theme.palette.primary.main
                } : {}
              }}
            >
              <ListItemIcon sx={{ color: activeLink === '/admin' ? theme.palette.primary.main : 'inherit' }}>
                <AdminPanelSettingsIcon />
              </ListItemIcon>
              <ListItemText primary="Admin Panel" />
              {activeLink === '/admin' && (
                <KeyboardArrowRightIcon fontSize="small" className="active-link-indicator" />
              )}
            </ListItemButton>
          </ListItem>
        )}
        {menuItems.map((item) => (
          <ListItem key={item.text} disablePadding className="menu-item">
            <ListItemButton 
              component={RouterLink} 
              to={item.path}
              className={`menu-button-item ${activeLink === item.path ? 'menu-button-active' : ''}`}
              sx={{
                '&:before': activeLink === item.path ? {
                  backgroundColor: theme.palette.primary.main
                } : {}
              }}
            >
              <ListItemIcon sx={{ color: activeLink === item.path ? theme.palette.primary.main : 'inherit' }}>
                {item.icon}
              </ListItemIcon>
              <ListItemText primary={item.text} />
              {activeLink === item.path && (
                <KeyboardArrowRightIcon fontSize="small" className="active-link-indicator" />
              )}
            </ListItemButton>
          </ListItem>
        ))}
      </List>
      <Divider />
      <List sx={{ p: 2 }}>
        <ListItem disablePadding>
          <ListItemButton 
            onClick={handleLogout}
            className="logout-button"
          >
            <ListItemIcon>
              <LogoutIcon className="logout-icon" />
            </ListItemIcon>
            <ListItemText primary="Logout" />
          </ListItemButton>
        </ListItem>
      </List>
    </Box>
  );

  return (
    <Box className="layout-container">
      <AppBar position="sticky" elevation={0}>
        <Toolbar>
          {isMobile && (
            <IconButton
              color="inherit"
              aria-label="open drawer"
              edge="start"
              onClick={toggleDrawer(true)}
              className="menu-button"
            >
              <MenuIcon />
            </IconButton>
          )}
          <Box
            className="logo-container"
            component={RouterLink}
            to="/"
          >
            <GitHubIcon 
              className="logo-icon"
              sx={{ color: theme.palette.primary.main }} 
            />
            <Typography
              variant="h6"
              className="app-title"
            >
              GitStatus
            </Typography>
          </Box>
          
          <Box className="title-container">
            <Fade in={animate} timeout={500}>
              <Typography variant="h6" className="page-title">
                {title}
              </Typography>
            </Fade>
          </Box>
          
          {user && (
            <Box className="user-section">
              <Tooltip title={`Logged in as ${user.name || user.username || 'User'}`}>
                <Avatar
                  className="user-avatar"
                  alt={user.name || user.username}
                  src={user.avatar}
                  sx={{ 
                    bgcolor: theme.palette.primary.main
                  }}
                >
                  {!user.avatar && (user.name?.[0] || user.username?.[0] || 'U')}
                </Avatar>
              </Tooltip>
            </Box>
          )}
        </Toolbar>
      </AppBar>
      
      {/* Drawer for mobile */}
      {isMobile && (
        <Drawer
          anchor="left"
          open={drawerOpen}
          onClose={toggleDrawer(false)}
        >
          {drawer}
        </Drawer>
      )}
      
      {/* Desktop layout with persistent drawer */}
      <Box sx={{ display: 'flex', flex: 1 }}>
        {!isMobile && (
          <Box sx={{ width: 250, flexShrink: 0 }}>
            {drawer}
          </Box>
        )}
        
        <Box component="main" className="main-content">
          <Container>
            {children}
          </Container>
        </Box>
      </Box>
      
      <Box component="footer" className="footer">
        <Typography className="footer-text">
          © {new Date().getFullYear()} GitStatus - Analyze your GitHub commit history
        </Typography>
      </Box>
    </Box>
  );
};

export default LayoutComponentTemplate;


---
File: frontend/src/components/PagePartials/Layout/LayoutComponent.js
---
import React, { useContext, useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { useTheme, useMediaQuery } from '@mui/material';
import { AuthContext } from '../../../contexts/AuthContext.js';
import LayoutComponentTemplate from './LayoutComponent.jsx';

/**
 * Layout component - Contains the main application layout with navigation
 * @param {Object} props - Component props
 * @param {React.ReactNode} props.children - Child components to render inside the layout
 * @param {string} props.title - Page title to display in the header
 */
const LayoutComponent = ({ children, title }) => {
  const { user, logout } = useContext(AuthContext);
  const navigate = useNavigate();
  const location = useLocation();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('md'));
  const [drawerOpen, setDrawerOpen] = useState(false);
  const [activeLink, setActiveLink] = useState('');
  const [animate, setAnimate] = useState(false);

  useEffect(() => {
    // Set the active link based on current path
    const path = location.pathname;
    setActiveLink(path);
    
    // Trigger animation whenever location changes
    setAnimate(true);
  }, [location]);

  const toggleDrawer = (open) => (event) => {
    if (
      event.type === 'keydown' &&
      (event.key === 'Tab' || event.key === 'Shift')
    ) {
      return;
    }
    setDrawerOpen(open);
  };

  const handleLogout = async () => {
    await logout();
    navigate('/login');
  };

  return (
    <LayoutComponentTemplate
      children={children}
      title={title}
      user={user}
      handleLogout={handleLogout}
      isMobile={isMobile}
      drawerOpen={drawerOpen}
      toggleDrawer={toggleDrawer}
      activeLink={activeLink}
      animate={animate}
      theme={theme}
    />
  );
};

export default LayoutComponent;


---
File: frontend/src/components/PagePartials/Layout/LayoutComponent.css
---
.layout-container {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
}

.menu-button {
  margin-right: 1rem;
  transition: transform 0.2s;
}

.menu-button:hover {
  transform: rotate(180deg);
}

.logo-container {
  display: flex;
  align-items: center;
  margin-right: 1rem;
}

.logo-container:hover .logo-icon {
  transform: rotate(360deg);
}

.logo-icon {
  margin-right: 0.5rem;
  transition: transform 0.5s ease-in-out;
}

.app-title {
  color: white; 
  text-decoration: none;
  font-weight: 600;
  letter-spacing: 0.02em;
  background: linear-gradient(90deg, #fff, #81d4fa);
  background-clip: text;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.title-container {
  display: flex;
  flex: 1;
}

.page-title {
  font-weight: 600;
  margin-left: 0.5rem;
}

.user-section {
  display: flex;
  align-items: center;
}

.user-avatar {
  transition: all 0.2s ease-in-out;
}

.user-avatar:hover {
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  transform: scale(1.05);
}

.main-content {
  flex: 1;
  padding: 1.5rem;
}

.drawer-container {
  width: 250px;
  height: 100%;
  display: flex;
  flex-direction: column;
  border-right: 1px solid;
}

.drawer-header {
  padding: 1rem;
  display: flex;
  align-items: center;
  justify-content: center;
}

.drawer-list {
  flex-grow: 1;
  padding: 1rem;
}

.menu-item {
  margin-bottom: 0.5rem;
}

.menu-button-active {
  background-color: rgba(77, 171, 245, 0.1);
}

.menu-button-active:before {
  content: "";
  position: absolute;
  left: 0;
  top: 20%;
  height: 60%;
  width: 4px;
  border-radius: 0 4px 4px 0;
}

.menu-button-item {
  border-radius: 8px;
  position: relative;
}

.menu-button-item:hover {
  background-color: rgba(77, 171, 245, 0.08);
}

.active-link-indicator {
  opacity: 0.5;
}

.logout-button {
  border-radius: 8px;
}

.logout-button:hover {
  background-color: rgba(244, 67, 54, 0.08);
}

.logout-icon {
  color: #f44336;
}

.footer {
  padding: 1.5rem;
  text-align: center;
  background-color: rgba(0, 0, 0, 0.05);
}

.footer-text {
  font-size: 0.875rem;
  color: rgba(255, 255, 255, 0.6);
}


---
File: frontend/src/components/PagePartials/AdminRoute/index.js
---
export { default } from './AdminRouteComponent';


---
File: frontend/src/components/PagePartials/AdminRoute/AdminRouteComponent.css
---
.admin-loading-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  width: 100vw;
}


---
File: frontend/src/components/PagePartials/AdminRoute/AdminRouteComponent.js
---
import React, { useContext } from 'react';
import { useLocation } from 'react-router-dom';
import { AuthContext } from '../../contexts/AuthContext';
import AdminRouteComponentTemplate from './AdminRouteComponent.jsx';

/**
 * AdminRoute component to protect admin-only routes
 * @param {Object} props - Component props
 * @param {React.ReactNode} props.children - Child components to render when user is admin
 */
const AdminRouteComponent = ({ children }) => {
  const { user, isAuthenticated, loading } = useContext(AuthContext);
  const location = useLocation();

  // Check if user has admin role
  const isAdmin = user && user.role === 'admin';

  return (
    <AdminRouteComponentTemplate
      children={children}
      isLoading={loading}
      isAuthenticated={isAuthenticated}
      isAdmin={isAdmin}
      location={location}
    />
  );
};

export default AdminRouteComponent;


---
File: frontend/src/components/PagePartials/AdminRoute/AdminRouteComponent.jsx
---
import React from 'react';
import { Navigate } from 'react-router-dom';
import { CircularProgress, Box } from '@mui/material';
import './AdminRouteComponent.css';

const AdminRouteComponentTemplate = ({ children, isLoading, isAuthenticated, isAdmin, location }) => {
  if (isLoading) {
    return (
      <Box
        className="admin-loading-container"
        sx={{
          backgroundColor: 'background.default'
        }}
      >
        <CircularProgress />
      </Box>
    );
  }

  if (!isAuthenticated || !isAdmin) {
    return <Navigate to="/dashboard" state={{ from: location }} replace />;
  }

  return children;
};

export default AdminRouteComponentTemplate;


---
File: frontend/src/reportWebVitals.js
---
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;


---
File: frontend/src/App.test.js
---
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});


---
File: frontend/src/contexts/ModalContext.js
---
import React, { createContext, useState, useContext } from 'react';

const ModalContext = createContext();

export const ModalProvider = ({ children }) => {
  const [modalState, setModalState] = useState({
    createReportOpen: false,
    viewCommitsOpen: false,
    reportData: null, // Stores the form data between modals
    commits: [], // Stores commits data
    selectedCommits: [] // Stores selected commits
  });

  const openCreateReportModal = (initialData = null) => {
    console.log('Opening CreateReport modal');
    setModalState(prev => ({
      ...prev,
      createReportOpen: true,
      viewCommitsOpen: false,
      reportData: initialData || prev.reportData
    }));
  };

  const openViewCommitsModal = (reportData = null, commits = [], selectedCommits = []) => {
    console.log('Opening ViewCommits modal with', commits.length, 'commits');
    setModalState(prev => ({
      ...prev,
      createReportOpen: false,
      viewCommitsOpen: true,
      reportData: reportData || prev.reportData,
      commits: commits.length ? commits : prev.commits,
      selectedCommits: selectedCommits.length ? selectedCommits : prev.selectedCommits
    }));
  };

  const closeModals = () => {
    console.log('Closing all modals');
    setModalState(prev => ({
      ...prev,
      createReportOpen: false,
      viewCommitsOpen: false
    }));
  };

  const updateReportData = (data) => {
    setModalState(prev => ({
      ...prev,
      reportData: { ...prev.reportData, ...data }
    }));
  };

  const updateCommits = (commits, selectedCommits = null) => {
    setModalState(prev => ({
      ...prev,
      commits,
      selectedCommits: selectedCommits !== null ? selectedCommits : prev.selectedCommits
    }));
  };

  const updateSelectedCommits = (selectedCommits) => {
    setModalState(prev => ({
      ...prev,
      selectedCommits
    }));
  };

  return (
    <ModalContext.Provider
      value={{
        modalState,
        openCreateReportModal,
        openViewCommitsModal,
        closeModals,
        updateReportData,
        updateCommits,
        updateSelectedCommits
      }}
    >
      {children}
    </ModalContext.Provider>
  );
};

export const useModal = () => {
  const context = useContext(ModalContext);
  if (!context) {
    throw new Error('useModal must be used within a ModalProvider');
  }
  return context;
}; 

---
File: frontend/src/contexts/AuthContext.js
---
import React, { createContext, useState, useEffect, useContext } from 'react';
import axios from 'axios';
import authService from '../services/auth';

export const AuthContext = createContext();

// Custom hook to use the auth context
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // Set up axios defaults
  axios.defaults.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:5000';
  axios.defaults.withCredentials = true;  // Important for cookies/sessions

  // Check if user is authenticated
  const checkAuth = async () => {
    try {
      setLoading(true);
      const res = await axios.get('/api/auth/me');
      
      if (res.data.isAuthenticated) {
        setUser(res.data.user);
        setIsAuthenticated(true);
      } else {
        setUser(null);
        setIsAuthenticated(false);
      }
      
      setError(null);
      return res.data;
    } catch (err) {
      setUser(null);
      setIsAuthenticated(false);
      setError('Failed to authenticate. Please try again.');
      throw err;
    } finally {
      setLoading(false);
    }
  };

  // Logout function
  const logout = async () => {
    try {
      await axios.get('/api/auth/logout');
    } catch (err) {
      console.error('Logout failed:', err);
      setError('Failed to logout. Please try again.');
    } finally {
      // Even if the logout API call fails, we still clear the local state
      setUser(null);
      setIsAuthenticated(false);
    }
  };

  // Set up axios interceptors for authentication
  useEffect(() => {
    // Setup axios interceptors with our logout function
    authService.setupAxiosInterceptors(logout);
  }, []);

  // Check authentication on app load
  useEffect(() => {
    checkAuth();
  }, []);

  // Auth context value
  const value = {
    user,
    isAuthenticated,
    loading,
    error,
    checkAuth,
    logout
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export default AuthProvider;


---
File: frontend/src/setupTests.js
---
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';


---
File: frontend/src/App.css
---
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}


---
File: frontend/src/services/api.js
---
import axios from 'axios';
import errorHandler from '../utils/errorHandler';

// Set up axios defaults
axios.defaults.baseURL = process.env.REACT_APP_API_URL || 'http://localhost:5000';
axios.defaults.withCredentials = true; // Important for cookies/sessions

// Add response interceptor for centralized error handling
axios.interceptors.response.use(
  response => response,
  error => {
    // Parse and standardize the error
    const parsedError = errorHandler.parseApiError(error);
    
    // Enhance error with our parsed data for easier handling
    error.parsedError = parsedError;
    
    // Still throw the error so it can be caught in the calling code
    throw error;
  }
);

/**
 * Generic API request handler with standardized error handling
 * 
 * @param {Function} apiCall - The API call function to execute
 * @returns {Promise} - Resolved with data or rejected with standardized error
 */
const handleApiRequest = async (apiCall) => {
  try {
    const result = await apiCall();
    return result;
  } catch (error) {
    console.error('API request failed:', error);
    
    // If the error was already parsed by the interceptor, use that
    if (error.parsedError) {
      throw error.parsedError;
    }
    
    // Otherwise parse it now and throw the parsed version
    throw errorHandler.parseApiError(error);
  }
};

const api = {
  /**
   * Get the currently authenticated user
   */
  getCurrentUser: async () => {
    const response = await axios.get('/api/auth/me');
    return response.data;
  },

  /**
   * Logout the current user
   */
  logout: async () => {
    const response = await axios.get('/api/auth/logout');
    return response.data;
  },

  /**
   * Get repository information
   * @param {string} repository - Repository name in format 'owner/repo'
   */
  getRepositoryInfo: async (repository) => {
    try {
      const response = await axios.get('/api/commits/repository', { params: { repository } });
      return response.data;
    } catch (error) {
      console.error('Error fetching repository info:', error);
      throw error;
    }
  },

  /**
   * Get branches for a repository
   * @param {string} repository - Repository name in format 'owner/repo'
   */
  getBranches: async (repository) => {
    try {
      const response = await axios.get('/api/commits/branches', { params: { repository } });
      return response.data;
    } catch (error) {
      console.error('Error fetching branches:', error);
      throw error;
    }
  },

  /**
   * Get contributors for a repository
   * @param {string} repository - Repository name in format 'owner/repo'
   */
  getContributors: async (repository) => {
    try {
      const response = await axios.get('/api/commits/contributors', { params: { repository } });
      return response.data;
    } catch (error) {
      console.error('Error fetching contributors:', error);
      throw error;
    }
  },

  /**
   * Get authors for specific branches
   * @param {string} repository - Repository name in format 'owner/repo'
   * @param {Array<string>} branches - List of branch names
   */
  getAuthorsForBranches: async (repository, branches) => {
    try {
      const response = await axios.get('/api/commits/branch-authors', {
        params: { 
          repository,
          branches
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching authors for branches:', error);
      throw error;
    }
  },

  /**
   * Get date range for branches and authors
   * @param {string} repository - Repository name in format 'owner/repo'
   * @param {Array<string>} branches - List of branch names
   * @param {Array<string>} authors - List of author names
   */
  getDateRange: async (repository, branches, authors) => {
    try {
      const response = await axios.get('/api/commits/date-range', {
        params: { 
          repository,
          branches,
          authors
        }
      });
      return response.data;
    } catch (error) {
      console.error('Error fetching date range:', error);
      throw error;
    }
  },

  /**
   * Get commits for a repository with filters
   * @param {Object} params - Query parameters
   * @param {string} params.repository - Repository name in format 'owner/repo'
   * @param {string} [params.branch] - Branch name
   * @param {string} [params.author] - Author login
   * @param {Date} [params.startDate] - Start date
   * @param {Date} [params.endDate] - End date
   */
  getCommits: async (params) => {
    try {
      const response = await axios.get('/api/commits', { params });
      return response.data;
    } catch (error) {
      console.error('Error fetching commits:', error);
      throw error;
    }
  },

  /**
   * Get commits based on repository, branches, authors, and date range
   */
  getCommitsByFilters: async ({ repository, branches, authors, startDate, endDate }) => {
    const params = {
      repository,
      branches: branches.join(','),
      includeFiles: true // Include file diffs in the response
    };
    
    if (authors && authors.length > 0) {
      params.authors = authors.join(',');
    }
    
    if (startDate) {
      params.startDate = startDate;
    }
    
    if (endDate) {
      params.endDate = endDate;
    }
    
    const response = await axios.get('/api/commits/with-diffs', { params });
    return response.data;
  },

  /**
   * Generate a report with the selected commits
   */
  generateReport: async ({ repository, branches, authors, startDate, endDate, title, includeCode, commitIds }) => {
    const response = await axios.post('/api/reports', {
      repository,
      branches,
      authors,
      startDate,
      endDate,
      title,
      includeCode,
      commitIds
    });
    return response.data;
  },

  /**
   * Get all reports for the current user
   */
  getReports: async () => {
    const response = await axios.get('/api/reports');
    return response.data;
  },

  /**
   * Get a specific report by ID
   * @param {string} id - Report ID
   */
  getReportById: async (id) => {
    const response = await axios.get(`/api/reports/${id}`);
    return response.data;
  },

  /**
   * Delete a report by ID
   * @param {string} id - Report ID
   * @param {string} confirmationName - Name of the report (for confirmation)
   */
  deleteReport: async (id, confirmationName) => {
    try {
      const response = await axios.delete(`/api/reports/${id}`, {
        data: { confirmationName }
      });
      return response.data;
    } catch (error) {
      console.error('Error deleting report:', error);
      throw error;
    }
  },

  /**
   * Search for repositories based on a query string
   * @param {string} query - Search query
   * @returns {Promise<Array>} - List of matching repositories
   */
  searchRepositories: async (query) => {
    if (!query || query.trim().length < 2) {
      return [];
    }
    
    try {
      const response = await axios.get('/api/commits/search-repositories', {
        params: { query }
      });
      return response.data;
    } catch (error) {
      console.error('Error searching repositories:', error);
      throw error;
    }
  },

  /**
   * Get commit info with branch details
   * @param {object} params - Parameters for commit info request
   * @param {string} params.repository - Repository path (owner/repo)
   * @param {Array} params.commitIds - Array of commit IDs
   */
  getCommitInfo: async (params) => {
    try {
      const response = await axios.post('/api/reports/commit-info', params);
      return response.data.commits;
    } catch (error) {
      console.error('Error getting commit info:', error);
      throw error;
    }
  },

  /**
   * Get commit details including author and summary from commit summaries
   * @param {object} params - Parameters for commit details request
   * @param {string} params.repository - Repository path (owner/repo)
   * @param {Array} params.commitIds - Array of commit IDs
   */
  getCommitDetails: async (params) => {
    try {
      const response = await axios.post('/api/commit-summary/details', params);
      return response.data.commits;
    } catch (error) {
      console.error('Error getting commit details:', error);
      throw error;
    }
  },

  /**
   * Get all users (admin only)
   */
  getUsers: async () => {
    try {
      const response = await axios.get('/api/admin/users');
      return response.data;
    } catch (error) {
      console.error('Error fetching users:', error);
      throw error;
    }
  },

  /**
   * Update user role (admin only)
   * @param {string} userId - The user ID
   * @param {string} role - The new role ('user' or 'admin')
   */
  updateUserRole: async (userId, role) => {
    try {
      const response = await axios.put(`/api/admin/users/${userId}/role`, { role });
      return response.data;
    } catch (error) {
      console.error('Error updating user role:', error);
      throw error;
    }
  },

  /**
   * Get admin analytics (admin only)
   */
  getAdminAnalytics: async () => {
    try {
      const response = await axios.get('/api/admin/analytics');
      return response.data;
    } catch (error) {
      console.error('Error fetching admin analytics:', error);
      throw error;
    }
  },

  /**
   * Get user usage statistics
   */
  getUserStats: async () => {
    try {
      const response = await axios.get('/api/usage-stats/user');
      return response.data;
    } catch (error) {
      console.error('Error fetching user stats:', error);
      throw error;
    }
  },

  /**
   * Check if an operation would exceed rate limits
   * @param {Object} stats - Current usage statistics
   * @param {string} type - Type of operation ('reports', 'commits', 'tokens')
   * @param {number} amount - Amount to check
   * @returns {boolean} Whether operation would exceed limits
   */
  wouldExceedLimit: (stats, type, amount = 1) => {
    if (!stats?.plan?.limits) return true;

    const current = stats.currentUsage[
      type === 'reports' ? 'reportsGenerated' :
      type === 'commits' ? 'commitsAnalyzed' : 'tokensUsed'
    ] || 0;

    const limit = stats.plan.limits[`${type}PerMonth`];
    return (current + amount) > limit;
  },

  /**
   * Get remaining quota for a specific type
   * @param {Object} stats - Current usage statistics
   * @param {string} type - Type of operation ('reports', 'commits', 'tokens')
   * @returns {number} Remaining quota
   */
  getRemainingQuota: (stats, type) => {
    if (!stats?.plan?.limits) return 0;

    const current = stats.currentUsage[
      type === 'reports' ? 'reportsGenerated' :
      type === 'commits' ? 'commitsAnalyzed' : 'tokensUsed'
    ] || 0;

    const limit = stats.plan.limits[`${type}PerMonth`];
    return Math.max(0, limit - current);
  },

  // Plan management
  getPlans: () => axios.get('/api/plans').then(response => response.data),
  updatePlanLimits: (planId, limits) => 
    axios.put(`/api/plans/${planId}/limits`, { limits }).then(response => response.data),

  /**
   * Get PDF generation status
   * @param {string} reportId - Report ID
   * @returns {Promise} - API response with status information
   */
  getPdfStatus: async (reportId) => {
    try {
      const response = await axios.get(`/api/reports/${reportId}/pdf-status`);
      return response.data;
    } catch (error) {
      console.error('Error getting PDF status:', error);
      throw error;
    }
  },
};

export default api;


---
File: frontend/src/services/auth.js
---
import axios from 'axios';
import { AuthContext } from '../contexts/AuthContext';

/**
 * Auth service to handle authentication related operations
 */
const authService = {
  /**
   * Clear all authentication data and redirect to login
   */
  handleAuthError: () => {
    console.log('Auth error handler called. Current location:', window.location.pathname);
    
    // Clear any auth data from localStorage if it exists
    localStorage.removeItem('user');
    sessionStorage.removeItem('user');
    
    // Clear cookies (this is a simple approach, may need to be adjusted based on how cookies are set)
    document.cookie.split(';').forEach(cookie => {
      const [name] = cookie.trim().split('=');
      document.cookie = `${name}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;`;
    });
    
    // Check if we're already on the login page to avoid redirect loops
    if (!window.location.pathname.includes('/login') && !window.location.pathname.includes('/auth/callback')) {
      console.log('Redirecting to login page');
      // Redirect to login page
      window.location.href = '/login';
    } else {
      console.log('Not redirecting - already on login or callback page');
    }
  },
  
  /**
   * Set up axios interceptors for authentication
   * @param {Function} logoutFunction - Function to call for user logout
   */
  setupAxiosInterceptors: (logoutFunction) => {
    // Response interceptor
    axios.interceptors.response.use(
      response => response, // Return successful responses as-is
      error => {
        // Handle authentication errors (401 Unauthorized, 403 Forbidden)
        if (error.response && (error.response.status === 401 || error.response.status === 403)) {
          console.log('Authentication error detected:', error.response.status);
          console.log('URL that failed:', error.config.url);
          console.log('Current page:', window.location.pathname);
          
          // Log out the user
          if (logoutFunction) {
            try {
              logoutFunction();
            } catch (e) {
              console.error('Error during logout:', e);
            }
          }
          
          // Handle redirection and clear auth data
          authService.handleAuthError();
        }
        
        return Promise.reject(error);
      }
    );
  }
};

export default authService; 

---
File: frontend/src/services/toast.js
---
import { createRoot } from 'react-dom/client';
import { Snackbar, Alert, Box } from '@mui/material';
import CheckCircleIcon from '@mui/icons-material/CheckCircle';
import ErrorIcon from '@mui/icons-material/Error';
import InfoIcon from '@mui/icons-material/Info';
import WarningIcon from '@mui/icons-material/Warning';

// Create a container for the notifications
let notificationContainer;

// Initialize the notification container
const initContainer = () => {
  if (!notificationContainer) {
    // Create a container if it doesn't exist
    const containerElement = document.createElement('div');
    containerElement.id = 'toast-notification-container';
    document.body.appendChild(containerElement);
    
    // Apply styles to position the container
    Object.assign(containerElement.style, {
      position: 'fixed',
      top: '24px',
      right: '24px',
      zIndex: '2000',
      display: 'flex',
      flexDirection: 'column',
      gap: '8px',
      maxWidth: '400px',
      pointerEvents: 'none' // Allow clicking through when no toasts are shown
    });
    
    notificationContainer = containerElement;
  }
  
  return notificationContainer;
};

// Get the icon based on severity
const getIcon = (severity) => {
  switch (severity) {
    case 'success':
      return <CheckCircleIcon />;
    case 'error':
      return <ErrorIcon />;
    case 'info':
      return <InfoIcon />;
    case 'warning':
      return <WarningIcon />;
    default:
      return <InfoIcon />;
  }
};

// Show a toast notification
const showNotification = (message, severity, duration = 5000) => {
  // Log message to console
  console.log(`[${severity.toUpperCase()}]`, message);
  
  // Initialize container
  const container = initContainer();
  
  // Create unique ID for this notification
  const id = `toast-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
  
  // Create notification element
  const notificationElement = document.createElement('div');
  notificationElement.id = id;
  container.appendChild(notificationElement);
  
  // Create root for React
  const root = createRoot(notificationElement);
  
  // Render notification
  root.render(
    <Box sx={{ pointerEvents: 'auto' }}>
      <Snackbar
        open={true}
        autoHideDuration={duration}
        onClose={() => {
          // Unmount and remove from DOM after closing
          setTimeout(() => {
            root.unmount();
            if (notificationElement.parentNode) {
              notificationElement.parentNode.removeChild(notificationElement);
            }
          }, 300); // Small delay to allow exit animation
        }}
        sx={{ position: 'static', mb: 1 }}
      >
        <Alert
          severity={severity}
          variant="filled"
          icon={getIcon(severity)}
          elevation={6}
          sx={{ width: '100%' }}
        >
          {message}
        </Alert>
      </Snackbar>
    </Box>
  );
  
  // Auto-remove after duration + buffer
  setTimeout(() => {
    if (notificationElement.parentNode) {
      root.unmount();
      notificationElement.parentNode.removeChild(notificationElement);
    }
  }, duration + 1000);
};

/**
 * Toast notification service
 * Used to provide consistent toast messages across the application
 */
const toast = {
  /**
   * Show a success notification
   * @param {string} message - The message to show
   * @param {number} duration - How long to show the notification (ms)
   */
  success: (message, duration = 5000) => {
    showNotification(message, 'success', duration);
  },
  
  /**
   * Show an error notification
   * @param {string} message - The message to show
   * @param {number} duration - How long to show the notification (ms)
   */
  error: (message, duration = 8000) => {
    showNotification(message, 'error', duration);
  },
  
  /**
   * Show an info notification
   * @param {string} message - The message to show
   * @param {number} duration - How long to show the notification (ms)
   */
  info: (message, duration = 5000) => {
    showNotification(message, 'info', duration);
  },
  
  /**
   * Show a warning notification
   * @param {string} message - The message to show
   * @param {number} duration - How long to show the notification (ms)
   */
  warning: (message, duration = 6000) => {
    showNotification(message, 'warning', duration);
  }
};

export default toast;


---
File: frontend/src/App.js
---
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import AuthContext from './contexts/AuthContext';
import { ModalProvider } from './contexts/ModalContext';
import PrivateRouteComponent from './components/PrivateRoute';
import AdminRouteComponent from './components/AdminRoute';
import LoginPage from './pages/Login';
import DashboardPage from './pages/Dashboard';
import CreateReportPage from './pages/CreateReport';
import ViewReportPage from './pages/ViewReport';
import NotFoundPage from './pages/NotFound';
import AdminDashboardComponent from './components/AdminDashboard';
import AnalyticsDashboardPage from './pages/AnalyticsDashboard';
import CreateReportModalComponent from './components/modals/CreateReportModal';
import ViewCommitsModalComponent from './components/modals/ViewCommitsModal';
import AuthCallbackPage from './pages/AuthCallback';
import theme from './styles/theme';

function App() {
  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <AuthContext>
        <ModalProvider>
          <Router>
            <Routes>
              <Route path="/login" element={<LoginPage />} />
              <Route path="/auth/callback" element={<AuthCallbackPage />} />
              <Route path="/" element={<Navigate to="/dashboard" replace />} />
              
              <Route 
                path="/dashboard" 
                element={
                  <PrivateRouteComponent>
                    <DashboardPage />
                  </PrivateRouteComponent>
                }
              />
              
              <Route 
                path="/reports/:id" 
                element={
                  <PrivateRouteComponent>
                    <ViewReportPage />
                  </PrivateRouteComponent>
                }
              />
              
              <Route 
                path="/create-report" 
                element={
                  <PrivateRouteComponent>
                    <CreateReportPage />
                  </PrivateRouteComponent>
                }
              />
              
              <Route 
                path="/analytics" 
                element={
                  <PrivateRouteComponent>
                    <AnalyticsDashboardPage />
                  </PrivateRouteComponent>
                }
              />
              
              <Route 
                path="/admin" 
                element={
                  <AdminRouteComponent>
                    <AdminDashboardComponent />
                  </AdminRouteComponent>
                }
              />
              
              <Route path="*" element={<NotFoundPage />} />
            </Routes>
            
            {/* Global Modals */}
            <CreateReportModalComponent />
            <ViewCommitsModalComponent />
          </Router>
        </ModalProvider>
      </AuthContext>
    </ThemeProvider>
  );
}

export default App;



---
File: frontend/src/index.css
---
@import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&display=swap');
@import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;600&display=swap');

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  height: 100%;
  scroll-behavior: smooth;
}

body {
  margin: 0;
  font-family: 'JetBrains Mono', 'Roboto Mono', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  height: 100%;
  letter-spacing: 0.015em;
  overflow-x: hidden;
}

code {
  font-family: 'JetBrains Mono', source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* Custom scrollbar styling */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: rgba(0, 0, 0, 0.1);
  border-radius: 4px;
}

::-webkit-scrollbar-thumb {
  background: rgba(77, 171, 245, 0.5);
  border-radius: 4px;
  transition: background 0.2s ease-in-out;
}

::-webkit-scrollbar-thumb:hover {
  background: rgba(77, 171, 245, 0.7);
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

/* Selection styling */
::selection {
  background-color: rgba(77, 171, 245, 0.3);
  color: #ffffff;
}

/* Focus styling */
:focus {
  outline: 2px solid rgba(77, 171, 245, 0.5);
  outline-offset: 2px;
}

a, button, input, textarea, select {
  transition: all 0.2s ease-in-out;
}


---
File: frontend/src/styles/theme.js
---
import { createTheme } from '@mui/material/styles';

// Define the application theme
const theme = createTheme({
  palette: {
    mode: 'dark',
    primary: {
      main: '#4dabf5',  // Electric blue as primary color
      light: '#81d4fa',
      dark: '#2196f3',
    },
    secondary: {
      main: '#b388ff',  // Deep purple as secondary color
      light: '#e1bee7',
      dark: '#7e57c2',
    },
    accent: {
      main: '#00bcd4',  // Teal accent
      light: '#4dd0e1',
      dark: '#0097a7',
    },
    background: {
      default: '#121824',
      paper: '#1E293B',
      cardGradient: 'linear-gradient(145deg, rgba(30, 41, 59, 0.7) 0%, rgba(20, 30, 48, 0.7) 100%)',
      gradient: 'linear-gradient(180deg, #121824 0%, #0F141B 100%)',
    },
    action: {
      hover: 'rgba(77, 171, 245, 0.08)',
      selected: 'rgba(77, 171, 245, 0.16)',
    },
  },
  typography: {
    fontFamily: '"JetBrains Mono", "Roboto Mono", monospace',
    h1: {
      fontWeight: 500,
      letterSpacing: '-0.01562em',
    },
    h2: {
      fontWeight: 500,
      letterSpacing: '-0.00833em',
    },
    h3: {
      fontWeight: 500,
      letterSpacing: '0em',
    },
    h4: {
      fontWeight: 600,
      letterSpacing: '0.00735em',
    },
    h5: {
      fontWeight: 600,
      letterSpacing: '0em',
    },
    h6: {
      fontWeight: 600,
      letterSpacing: '0.0075em',
    },
    button: {
      textTransform: 'none',
      fontWeight: 500,
    },
  },
  shape: {
    borderRadius: 8,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          borderRadius: 8,
          padding: '8px 16px',
          textTransform: 'none',
          fontWeight: 500,
          transition: 'all 0.2s ease-in-out',
          '&:hover': {
            transform: 'translateY(-2px)',
            boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)',
          },
        },
        contained: {
          boxShadow: '0 2px 4px rgba(0, 0, 0, 0.1)',
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          backgroundImage: 'linear-gradient(145deg, rgba(30, 41, 59, 0.7) 0%, rgba(20, 30, 48, 0.7) 100%)',
          backdropFilter: 'blur(10px)',
          transition: 'all 0.2s ease-in-out',
          '&:hover': {
            boxShadow: '0 6px 12px rgba(0, 0, 0, 0.15)',
          },
        },
      },
    },
    MuiTextField: {
      defaultProps: {
        variant: 'outlined',
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          borderRadius: 12,
          backgroundImage: 'linear-gradient(145deg, #1e1e1e 0%, #252525 100%)',
          transition: 'all 0.2s ease-in-out',
          '&:hover': {
            boxShadow: '0 6px 12px rgba(0, 0, 0, 0.15)',
          },
        },
      },
    },
    MuiTableRow: {
      styleOverrides: {
        root: {
          transition: 'background-color 0.2s ease-in-out',
          '&:hover': {
            backgroundColor: 'rgba(77, 171, 245, 0.04)',
          },
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          borderColor: 'rgba(255, 255, 255, 0.05)',
          padding: '16px',
        },
        head: {
          fontWeight: 600,
        },
      },
    },
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundImage: 'linear-gradient(90deg, #121212 0%, #1e1e1e 100%)',
          borderBottom: '1px solid rgba(255, 255, 255, 0.05)',
        },
      },
    },
  },
});

export default theme; 

---
File: frontend/src/utils/csrf.js
---
/**
 * CSRF Token Utility Functions
 * Provides helpers for working with CSRF token in API requests
 */

// Store token in memory
let csrfToken = null;

/**
 * Fetch a CSRF token from the server
 * @returns {Promise<string>} The CSRF token
 */
export const fetchCsrfToken = async () => {
  try {
    const response = await fetch('/api/csrf-token', {
      credentials: 'include', // Important: include cookies
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch CSRF token');
    }
    
    const data = await response.json();
    csrfToken = data.csrfToken;
    return csrfToken;
  } catch (error) {
    console.error('Error fetching CSRF token:', error);
    throw error;
  }
};

/**
 * Get the current CSRF token, fetching a new one if necessary
 * @returns {Promise<string>} The CSRF token
 */
export const getCsrfToken = async () => {
  if (!csrfToken) {
    return fetchCsrfToken();
  }
  return csrfToken;
};

/**
 * Add CSRF token to the provided headers object
 * @param {Object} headers - Headers object to add the token to
 * @returns {Promise<Object>} Headers object with CSRF token
 */
export const addCsrfToken = async (headers = {}) => {
  const token = await getCsrfToken();
  return {
    ...headers,
    'csrf-token': token,
  };
};

/**
 * Enhanced fetch function that automatically adds CSRF token
 * for state-changing methods (POST, PUT, DELETE, PATCH)
 * @param {string} url - The URL to fetch
 * @param {Object} options - Fetch options
 * @returns {Promise<Response>} Fetch response
 */
export const fetchWithCsrf = async (url, options = {}) => {
  const { method = 'GET', headers = {}, ...rest } = options;
  
  // Only add CSRF token for state-changing methods
  const stateChangingMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];
  
  let requestHeaders = headers;
  if (stateChangingMethods.includes(method.toUpperCase())) {
    requestHeaders = await addCsrfToken(headers);
  }
  
  return fetch(url, {
    method,
    headers: requestHeaders,
    credentials: 'include', // Always include cookies
    ...rest,
  });
};

export default {
  fetchCsrfToken,
  getCsrfToken,
  addCsrfToken,
  fetchWithCsrf,
}; 

---
File: frontend/src/utils/DesignGuide.md
---
# GitStatus Design Guide

This guide outlines the design principles and UI patterns to maintain consistency across the GitStatus application.

## Color Palette

- **Primary**: Electric blue (`#4dabf5`) - Used for primary actions, links, and important UI elements
- **Secondary**: Deep purple (`#b388ff`) - Used for secondary actions and accents
- **Accent**: Teal (`#00bcd4`) - Used for tertiary elements and special highlights
- **Background**: Dark theme with subtle gradients
  - Base: `#121212`
  - Paper: `#1e1e1e` 
  - Gradient: `linear-gradient(145deg, #121212 0%, #1a1a1a 100%)`
  - Card Gradient: `linear-gradient(145deg, #1e1e1e 0%, #252525 100%)`

## Typography

- **Font Family**: JetBrains Mono (primary), Roboto Mono (fallback)
- **Font Weights**:
  - Headings: 500-600
  - Body: 400
  - Buttons: 500
- **Line Height**: 1.6 for better readability
- **Gradient Text**: Use for important headings with `background: linear-gradient(90deg, #fff, #81d4fa)`

## Layout Components

### Cards

```jsx
<Card 
  elevation={2}
  sx={{
    border: '1px solid rgba(255, 255, 255, 0.05)',
    backgroundImage: theme.palette.background.cardGradient,
    borderRadius: 3,
    overflow: 'hidden',
    transition: 'all 0.2s',
    '&:hover': {
      boxShadow: '0 8px 24px rgba(0, 0, 0, 0.15)'
    }
  }}
>
  <CardContent sx={{ p: 3 }}>
    {/* Card content */}
  </CardContent>
</Card>
```

### Buttons

```jsx
// Primary Button
<Button
  variant="contained"
  color="primary"
  startIcon={<Icon />}
  sx={{
    borderRadius: 2,
    boxShadow: '0 4px 12px rgba(77, 171, 245, 0.3)',
    '&:hover': {
      transform: 'translateY(-2px)',
      boxShadow: '0 6px 16px rgba(77, 171, 245, 0.4)',
    }
  }}
>
  Button Text
</Button>

// Secondary Button
<Button
  variant="outlined"
  startIcon={<Icon />}
  sx={{ 
    borderRadius: 2,
    transition: 'all 0.2s',
    '&:hover': {
      transform: 'translateY(-2px)'
    }
  }}
>
  Button Text
</Button>
```

### Data Panels

```jsx
<Paper
  elevation={0}
  sx={{
    p: 2,
    borderRadius: 2,
    backgroundColor: 'rgba(255, 255, 255, 0.03)',
    height: '100%',
    display: 'flex',
    flexDirection: 'column',
    justifyContent: 'center'
  }}
>
  <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
    <Icon fontSize="small" sx={{ mr: 1, opacity: 0.7 }} />
    <Typography variant="body2" color="text.secondary">Label</Typography>
  </Box>
  <Typography variant="h6" sx={{ fontWeight: 500 }}>Value</Typography>
</Paper>
```

### Tables

```jsx
<TableContainer 
  component={Paper} 
  elevation={0}
  sx={{
    borderRadius: 2,
    background: 'transparent',
    '& .MuiTable-root': {
      borderCollapse: 'separate',
      borderSpacing: '0 8px',
    }
  }}
>
  <Table>
    <TableHead>
      <TableRow>
        <TableCell sx={{ borderBottom: '1px solid rgba(255, 255, 255, 0.1)', fontWeight: 600 }}>
          Header Cell
        </TableCell>
      </TableRow>
    </TableHead>
    <TableBody>
      <TableRow 
        sx={{
          background: theme.palette.background.cardGradient,
          boxShadow: '0 2px 8px rgba(0, 0, 0, 0.08)',
          borderRadius: 2,
          position: 'relative',
          transition: 'all 0.2s ease-in-out',
          '&:hover': {
            transform: 'translateY(-2px)',
            boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)',
          },
          '& td:first-of-type': { 
            borderTopLeftRadius: 8, 
            borderBottomLeftRadius: 8,
          },
          '& td:last-of-type': { 
            borderTopRightRadius: 8, 
            borderBottomRightRadius: 8,
          },
        }}
      >
        <TableCell sx={{ borderBottom: 'none' }}>Cell Content</TableCell>
      </TableRow>
    </TableBody>
  </Table>
</TableContainer>
```

## Animation Guidelines

- **Transitions**: Use smooth transitions for all interactive elements (0.2-0.3s)
- **Hover Effects**: 
  - Subtle elevation changes
  - Small scale or position transforms
  - Color transitions
- **Page Transitions**: Use Fade component with 800ms timeout
- **Loading States**: Use CircularProgress with custom styling

```jsx
<CircularProgress 
  color="primary" 
  sx={{
    '& .MuiCircularProgress-circle': {
      strokeLinecap: 'round',
    }
  }}
/>
```

## Micro-interactions

- **Buttons**: Slight elevation and transform on hover
- **Cards**: Shadow increase on hover
- **Icons**: Rotation or color change on interaction
- **Form Fields**: Subtle highlight effects on focus

## Responsive Design

- Use the MUI breakpoint system consistently
- Design for mobile-first, then adapt for larger screens
- Use flexbox for responsive layouts:

```jsx
<Box 
  sx={{ 
    display: 'flex', 
    flexDirection: { xs: 'column', md: 'row' },
    alignItems: { xs: 'flex-start', md: 'center' },
    gap: 2
  }}
>
  {/* Content */}
</Box>
```

## Accessibility Guidelines

- Maintain sufficient color contrast
- Use proper semantic HTML elements
- Provide tooltips for icon-only buttons
- Include focus indicators for keyboard navigation
- Support screen readers with appropriate ARIA attributes

## Iconography

- Use Material Icons consistently
- Keep icon sizes consistent (small: 18px, medium: 24px, large: 36px)
- Add subtle effects to icons for interactive elements

By adhering to these guidelines, we maintain a cohesive, modern, and professional user experience across the GitStatus application. 

---
File: frontend/src/utils/errorHandler.js
---
/**
 * Frontend Error Handling Utilities
 * 
 * This file provides standardized error handling for the frontend application.
 * It includes utilities for parsing API errors, handling specific error types,
 * and displaying consistent error messages to users.
 */

/**
 * Standard error types for client-side handling
 */
export const ErrorTypes = {
  AUTHENTICATION: 'AUTHENTICATION_REQUIRED',
  AUTHORIZATION: 'AUTHORIZATION_DENIED',
  VALIDATION: 'VALIDATION_ERROR',
  NETWORK: 'NETWORK_ERROR',
  RATE_LIMIT: 'RATE_LIMIT_EXCEEDED',
  NOT_FOUND: 'RESOURCE_NOT_FOUND',
  SERVER: 'SERVER_ERROR',
  UNKNOWN: 'UNKNOWN_ERROR'
};

/**
 * Parse and normalize API error responses
 * 
 * @param {Error} error - Error object from API call
 * @returns {Object} Normalized error with type, message, and details
 */
export const parseApiError = (error) => {
  // Default error structure
  const parsedError = {
    type: ErrorTypes.UNKNOWN,
    message: 'An unexpected error occurred',
    details: null,
    originalError: error
  };

  // Handle axios error responses
  if (error.response) {
    const { status, data } = error.response;
    
    // Check if the response follows our API error format
    if (data && data.error) {
      parsedError.message = data.error.message || 'An error occurred';
      parsedError.details = data.error.details || null;
      
      // Map API error codes to client error types
      switch (data.error.code) {
        case 'AUTHENTICATION_REQUIRED':
          parsedError.type = ErrorTypes.AUTHENTICATION;
          parsedError.message = error.message || 'You need to be logged in to access this resource';
          break;
        case 'AUTHORIZATION_DENIED':
          parsedError.type = ErrorTypes.AUTHORIZATION;
          break;
        case 'VALIDATION_ERROR':
          parsedError.type = ErrorTypes.VALIDATION;
          break;
        case 'RATE_LIMIT_EXCEEDED':
          parsedError.type = ErrorTypes.RATE_LIMIT;
          break;
        case 'RESOURCE_NOT_FOUND':
          parsedError.type = ErrorTypes.NOT_FOUND;
          break;
        default:
          parsedError.type = ErrorTypes.SERVER;
      }
    } else {
      // Handle HTTP status codes for non-standard responses
      switch (status) {
        case 401:
          parsedError.type = ErrorTypes.AUTHENTICATION;
          parsedError.message = 'Authentication required';
          break;
        case 403:
          parsedError.type = ErrorTypes.AUTHORIZATION;
          parsedError.message = 'You do not have permission to perform this action';
          break;
        case 404:
          parsedError.type = ErrorTypes.NOT_FOUND;
          parsedError.message = 'Resource not found';
          break;
        case 429:
          parsedError.type = ErrorTypes.RATE_LIMIT;
          parsedError.message = 'Rate limit exceeded. Please try again later.';
          break;
        case 500:
        case 502:
        case 503:
        case 504:
          parsedError.type = ErrorTypes.SERVER;
          parsedError.message = 'Server error. Please try again later.';
          break;
        default:
          parsedError.message = data?.message || 'An error occurred';
      }
    }
  } else if (error.request) {
    // Request was made but no response received (network error)
    parsedError.type = ErrorTypes.NETWORK;
    parsedError.message = 'Network error. Please check your connection and try again.';
  }

  return parsedError;
};

/**
 * Get user-friendly error message
 * 
 * @param {Error|Object} error - Error object (raw or parsed)
 * @returns {string} User-friendly error message
 */
export const getFriendlyErrorMessage = (error) => {
  // If already parsed, use the message
  if (error.type && error.message) {
    return error.message;
  }
  
  // Otherwise parse the error first
  const parsedError = parseApiError(error);
  return parsedError.message;
};

/**
 * Check if the error is an authentication error
 * 
 * @param {Error|Object} error - Error object (raw or parsed)
 * @returns {boolean} Whether it's an authentication error
 */
export const isAuthError = (error) => {
  const parsedError = error.type ? error : parseApiError(error);
  return parsedError.type === ErrorTypes.AUTHENTICATION;
};

/**
 * Get validation error details if available
 * 
 * @param {Error|Object} error - Error object (raw or parsed)
 * @returns {Array|null} Array of validation errors or null
 */
export const getValidationErrors = (error) => {
  const parsedError = error.type ? error : parseApiError(error);
  return parsedError.type === ErrorTypes.VALIDATION ? parsedError.details : null;
};

/**
 * Handle common error scenarios
 * 
 * @param {Error} error - Original error
 * @param {Object} options - Error handling options
 * @param {Function} options.navigate - React Router navigate function
 * @param {Function} options.showNotification - Function to show UI notification
 * @param {boolean} options.redirectOnAuth - Whether to redirect on auth errors
 * @returns {Object} Parsed error
 */
export const handleError = (error, options = {}) => {
  const { navigate, showNotification, redirectOnAuth = true } = options;
  const parsedError = parseApiError(error);
  
  // Log detailed error to console for debugging
  console.error('Error:', {
    type: parsedError.type,
    message: parsedError.message,
    details: parsedError.details,
    originalError: error
  });
  
  // Handle authentication errors - redirect to login
  if (parsedError.type === ErrorTypes.AUTHENTICATION && redirectOnAuth && navigate) {
    navigate('/login', { 
      state: { 
        from: window.location.pathname,
        authRequired: true
      } 
    });
  }
  
  // Show notification if function provided
  if (showNotification) {
    showNotification({
      message: parsedError.message,
      type: 'error'
    });
  }
  
  return parsedError;
};

export default {
  ErrorTypes,
  parseApiError,
  getFriendlyErrorMessage,
  isAuthError,
  getValidationErrors,
  handleError
}; 

---
File: backend/config/passport.js
---
const passport = require('passport');
const GitHubStrategy = require('passport-github2').Strategy;
const AuthService = require('../services/authService');

passport.serializeUser((user, done) => {
  done(null, user.id);
});

passport.deserializeUser(async (id, done) => {
  try {
    const user = await AuthService.getUserById(id);
    done(null, user);
  } catch (err) {
    done(err, null);
  }
});

passport.use(new GitHubStrategy({
    clientID: process.env.GITHUB_CLIENT_ID,
    clientSecret: process.env.GITHUB_CLIENT_SECRET,
    callbackURL: process.env.GITHUB_CALLBACK_URL || 'http://localhost:5000/api/auth/github/callback',
    scope: ['user', 'repo']
  },
  async (accessToken, refreshToken, profile, done) => {
    try {
      const user = await AuthService.handleGitHubAuth(profile, accessToken);
      return done(null, user);
    } catch (err) {
      return done(err, null);
    }
  }
));

module.exports = passport;


---
File: backend/routes/CommitSummaryRoutes.js
---
const express = require('express');
const router = express.Router();
const commitSummaryController = require('../controllers/CommitSummaryController');
const { isAuthenticated } = require('../middleware/auth');

// All routes require authentication
router.use(isAuthenticated);

// Get all commit summaries (with optional filtering)
router.get('/', commitSummaryController.getSummaries);

// Get a specific commit summary by repository and commitId
router.get('/:repository/:commitId', commitSummaryController.getSummaryByCommitId);

// Get commit details by commitIds (batch)
router.post('/details', commitSummaryController.getCommitDetails);

module.exports = router;


---
File: backend/routes/UsageStatsRoutes.js
---
const express = require('express');
const router = express.Router();
const UsageStatsController = require('../controllers/UsageStatsController');
const { authenticate } = require('../middleware/auth');

// Apply authentication middleware to all routes
router.use(authenticate);

// Get the current user's usage statistics
router.get('/user', UsageStatsController.getUserStats);

// Check if user has reached their report generation limit
router.get('/check-limit', UsageStatsController.checkReportLimit);

// Get admin analytics dashboard data (admin only)
router.get('/admin', UsageStatsController.getAdminStats);

module.exports = router;

---
File: backend/routes/PlanRoutes.js
---
const express = require('express');
const router = express.Router();
const planController = require('../controllers/PlanController');
const { isAdmin } = require('../middleware/auth');

// All routes require admin privileges
router.use(isAdmin);

// Get all plans
router.get('/', planController.getPlans);

// Update plan limits
router.put('/:planId/limits', planController.updatePlanLimits);

module.exports = router; 

---
File: backend/routes/AuthRoutes.js
---
const express = require('express');
const passport = require('passport');
const router = express.Router();
const authController = require('../controllers/AuthController');

// GitHub OAuth routes
router.get('/github', passport.authenticate('github', { scope: ['user', 'repo'] }));

router.get(
  '/github/callback',
  passport.authenticate('github', { 
    failureRedirect: `${process.env.FRONTEND_URL || 'http://localhost:3000'}/login?error=auth_failed` 
  }),
  authController.githubCallback
);

// Get current user
router.get('/me', authController.getCurrentUser);

// Logout
router.get('/logout', authController.logout);

module.exports = router;


---
File: backend/routes/ReportsRoutes.js
---
const express = require('express');
const router = express.Router();
const {
  ReportGenerationController,
  ReportViewController,
  ReportManagementController,
  ReportCacheController
} = require('../controllers/Report');
const { isAuthenticated } = require('../middleware/auth');
const {
  getReportsValidation,
  generateReportValidation,
  getCommitInfoValidation,
  getReportByIdValidation,
  deleteReportValidation,
  getCacheStatsValidation,
  cleanupReportsCacheValidation,
  cleanupInvalidReportsValidation
} = require('../middleware/validationMiddleware');

// Get reports for a user
router.get('/', isAuthenticated, getReportsValidation, ReportViewController.getReports);

// Create a new report
router.post('/', isAuthenticated, generateReportValidation, ReportGenerationController.generateReport);

// Get commit info with branch details
router.post('/commit-info', isAuthenticated, getCommitInfoValidation, ReportGenerationController.getCommitInfo);

// Cleanup invalid reports
router.post('/cleanup', isAuthenticated, cleanupInvalidReportsValidation, ReportManagementController.cleanupInvalidReports);

// Get cache statistics (admin only)
router.get('/cache/stats', isAuthenticated, getCacheStatsValidation, ReportCacheController.getCacheStats);

// Cleanup old/unused cached reports (admin only)
router.post('/cache/cleanup', isAuthenticated, cleanupReportsCacheValidation, ReportCacheController.cleanupReportsCache);

// Get a specific report
router.get('/:id', isAuthenticated, getReportByIdValidation, ReportViewController.getReportById);

// Delete a report
router.delete('/:id', isAuthenticated, deleteReportValidation, ReportManagementController.deleteReport);

// Get PDF generation status
router.get('/:id/pdf-status', isAuthenticated, getReportByIdValidation, ReportGenerationController.getPdfStatus);

module.exports = router;


---
File: backend/routes/CommitsRoutes.js
---
const express = require('express');
const router = express.Router();
const { 
  GitHubRepositoryController, 
  GitHubBranchController, 
  GitHubCommitController 
} = require('../controllers/GitHub');
const { isAuthenticated } = require('../middleware/auth');

// Get commits based on filters
router.get('/', isAuthenticated, GitHubCommitController.getCommits);

// Search for repositories
router.get('/search-repositories', isAuthenticated, GitHubRepositoryController.searchRepositories);

// Get repository information
router.get('/repository', isAuthenticated, GitHubRepositoryController.getRepositoryInfo);

// Get branches for a repository
router.get('/branches', isAuthenticated, GitHubBranchController.getBranches);

// Get contributors for a repository
router.get('/contributors', isAuthenticated, GitHubRepositoryController.getContributors);

// Get authors for a branch
router.get('/branch-authors', isAuthenticated, GitHubBranchController.getAuthorsForBranches);

// Get commits for a date range
router.get('/date-range', isAuthenticated, GitHubCommitController.getDateRange);

// Get commits with diffs
router.get('/with-diffs', isAuthenticated, GitHubCommitController.getCommitsWithDiffs);

module.exports = router;


---
File: backend/routes/AdminRoutes.js
---
const express = require('express');
const router = express.Router();
const { isAdmin } = require('../middleware/auth');
const AdminController = require('../controllers/AdminController');

// Get all users (admin only)
router.get('/users', isAdmin, AdminController.getUsers);

// Update user role (admin only)
router.put('/users/:userId/role', isAdmin, AdminController.updateUserRole);

// Get admin analytics (admin only)
router.get('/analytics', isAdmin, AdminController.getAnalytics);

module.exports = router; 

---
File: backend/server.js
---
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const mongoose = require('mongoose');
const session = require('express-session');
const passport = require('passport');
const cookieParser = require('cookie-parser');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const { doubleCsrf } = require('csrf-csrf');
const { selectiveCsrfProtection } = require('./middleware/csrfMiddleware');
const authRoutes = require('./routes/AuthRoutes');
const commitRoutes = require('./routes/CommitsRoutes');
const reportRoutes = require('./routes/ReportsRoutes');
const usageStatsRoutes = require('./routes/UsageStatsRoutes');
const adminRoutes = require('./routes/AdminRoutes');
const planRoutes = require('./routes/PlanRoutes');
const commitSummaryRoutes = require('./routes/CommitSummaryRoutes');
const PlanService = require('./services/planService');
const { errorHandler, notFoundHandler } = require('./middleware/errorHandler');
require('./config/passport');

const app = express();
const PORT = process.env.PORT || 5000;

// Initialize services that need to be started with the app
(async () => {
  try {
    // Initialize default plan
    await PlanService.initializeDefaultPlan();
    console.log('Plan initialization complete');
    
    // Run scheduled queue cleanup (once a day)
    const queueService = require('./services/queue');
    setInterval(async () => {
      try {
        await queueService.cleanupJobs();
        console.log('Queue cleanup completed');
      } catch (error) {
        console.error('Error during queue cleanup:', error);
      }
    }, 24 * 60 * 60 * 1000); // Once a day
    
    console.log('Queue service initialized');
  } catch (error) {
    console.error('Error initializing services:', error);
    process.exit(1);
  }
})();

// Security middlewares
app.use(helmet());

// Rate limiting
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  // TODO: Re-enable proper rate limiting before deployment.
  // Temporarily increased for development to avoid network errors.
  max: 1000, // Increased from 100 to 1000 for development
  message: 'Too many requests from this IP, please try again later',
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
});

// Apply rate limiting to all API routes
// TODO: For development only - conditionally apply rate limiting
if (process.env.NODE_ENV === 'production') {
  app.use('/api/', apiLimiter);
} else {
  console.log('Rate limiting disabled for development');
}

// Middleware
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json());
app.use(cookieParser());

// Apply input sanitization to all requests
const { sanitizeRequest } = require('./middleware/sanitizationMiddleware');
app.use(sanitizeRequest);

app.use(session({
  secret: process.env.SESSION_SECRET || 'gitstatus-secret',
  resave: false,
  saveUninitialized: false,
  cookie: {
    secure: process.env.NODE_ENV === 'production',
    maxAge: 24 * 60 * 60 * 1000, // 24 hours
    httpOnly: true, // Prevents client-side JS from reading the cookie
    sameSite: 'lax' // Provides some CSRF protection
  }
}));

// Initialize Passport
app.use(passport.initialize());
app.use(passport.session());

// CSRF Protection setup
const { generateToken, doubleCsrfProtection } = doubleCsrf({
  getSecret: () => process.env.CSRF_SECRET || 'gitstatus-csrf-secret',
  cookieName: 'csrf-token',
  cookieOptions: {
    httpOnly: true,
    sameSite: 'lax',
    secure: process.env.NODE_ENV === 'production',
    path: '/'
  },
  size: 64, // token size in bytes
});

// Create middleware that only applies CSRF protection to state-changing methods
const csrfProtection = selectiveCsrfProtection(doubleCsrfProtection);

// Endpoint to get CSRF token
app.get('/api/csrf-token', (req, res) => {
  res.json({ csrfToken: generateToken(req, res) });
});

// Database connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/gitstatus')
  .then(() => console.log('Connected to MongoDB'))
  .catch(err => console.error('MongoDB connection error:', err));

// Apply CSRF protection to all API routes that might have state-changing operations
app.use('/api/auth', csrfProtection, authRoutes);
app.use('/api/commits', csrfProtection, commitRoutes);
app.use('/api/reports', csrfProtection, reportRoutes);
app.use('/api/usage-stats', csrfProtection, usageStatsRoutes);
app.use('/api/admin', csrfProtection, adminRoutes);
app.use('/api/plans', csrfProtection, planRoutes);
app.use('/api/commit-summary', csrfProtection, commitSummaryRoutes);

// Routes without CSRF protection (read-only operations, OAuth flow)
app.use('/api/auth', authRoutes);
app.use('/api/commits', commitRoutes);
app.use('/api/usage-stats', usageStatsRoutes);

// Base route
app.get('/', (req, res) => {
  res.json({ message: 'Welcome to GitStatus API' });
});

// Handle 404 for routes that don't exist
app.use(notFoundHandler);

// Global error handler
app.use(errorHandler);

app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

module.exports = app;


---
File: backend/middleware/rateLimiter.js
---
const UsageStats = require('../models/UsageStats');
const User = require('../models/User');

const rateLimiter = {
  async checkReportLimit(req, res, next) {
    try {
      const user = await User.findById(req.user._id).populate('plan');
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }

      const currentMonth = new Date();
      currentMonth.setDate(1);
      currentMonth.setHours(0, 0, 0, 0);

      const monthlyStats = await UsageStats.findOne({
        user: user._id,
        month: currentMonth
      });

      const reportsGenerated = monthlyStats?.reports?.total || 0;
      const limit = user.plan.limits.reportsPerMonth;

      if (reportsGenerated >= limit) {
        return res.status(429).json({
          error: 'Monthly report limit exceeded',
          limit,
          current: reportsGenerated
        });
      }

      next();
    } catch (error) {
      console.error('Error checking report limit:', error);
      res.status(500).json({ error: 'Error checking report limit' });
    }
  },

  async checkCommitLimit(req, res, next) {
    try {
      const user = await User.findById(req.user._id).populate('plan');
      if (!user) {
        return res.status(404).json({ error: 'User not found' });
      }

      const { reportType } = req.body; // 'small' or 'big'
      const commitsPerReport = reportType === 'big' 
        ? user.plan.limits.commitsPerBigReport 
        : user.plan.limits.commitsPerSmallReport;

      const { commitCount } = req.body;
      if (commitCount > commitsPerReport) {
        return res.status(429).json({
          error: `Commit limit exceeded for ${reportType} report`,
          limit: commitsPerReport,
          current: commitCount
        });
      }

      // Get the appropriate commit limit based on report type
      const commitLimit = reportType === 'large' 
        ? user.plan.limits.commitsPerLargeReport
        : user.plan.limits.commitsPerStandardReport;

      const commits = req.body.commits || [];
      if (commits.length > commitLimit) {
        return res.status(429).json({
          error: `Report exceeds maximum commits allowed for ${reportType} reports (${commitLimit} commits)`,
          limit: commitLimit,
          type: reportType
        });
      }

      next();
    } catch (error) {
      console.error('Error checking commit limit:', error);
      res.status(500).json({ error: 'Error checking commit limit' });
    }
  }
};

module.exports = rateLimiter; 

---
File: backend/middleware/validationMiddleware.js
---
const { body, param, query, validationResult } = require('express-validator');
const mongoose = require('mongoose');

/**
 * Middleware to check if validation errors exist
 * If errors exist, return a 400 Bad Request with the error messages
 */
const validateRequest = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ 
      error: 'Validation failed',
      details: errors.array() 
    });
  }
  next();
};

/**
 * Check if a string is a valid MongoDB ObjectId
 */
const isValidObjectId = (value) => {
  return mongoose.Types.ObjectId.isValid(value);
};

/**
 * Validation rules for getReports endpoint
 */
const getReportsValidation = [
  // No specific validation needed for this endpoint as it doesn't take parameters
  validateRequest
];

/**
 * Validation rules for generateReport endpoint
 */
const generateReportValidation = [
  body('repository')
    .notEmpty().withMessage('Repository is required')
    .isString().withMessage('Repository must be a string')
    .matches(/^[a-zA-Z0-9-_.]+\/[a-zA-Z0-9-_.]+$/).withMessage('Repository should be in the format owner/repo'),
  
  body('branches')
    .optional()
    .isArray().withMessage('Branches must be an array'),
  
  body('branches.*')
    .optional()
    .isString().withMessage('Each branch must be a string')
    .trim(),
  
  body('authors')
    .optional()
    .isArray().withMessage('Authors must be an array'),
  
  body('authors.*')
    .optional()
    .isString().withMessage('Each author must be a string')
    .trim(),
  
  body('startDate')
    .optional()
    .isISO8601().withMessage('Start date must be a valid ISO8601 date')
    .toDate(),
  
  body('endDate')
    .optional()
    .isISO8601().withMessage('End date must be a valid ISO8601 date')
    .toDate()
    .custom((value, { req }) => {
      if (req.body.startDate && new Date(value) < new Date(req.body.startDate)) {
        throw new Error('End date must be after start date');
      }
      return true;
    }),
  
  body('title')
    .notEmpty().withMessage('Title is required')
    .isString().withMessage('Title must be a string')
    .trim()
    .isLength({ min: 1, max: 200 }).withMessage('Title must be between 1 and 200 characters'),
  
  body('includeCode')
    .optional()
    .isBoolean().withMessage('includeCode must be a boolean'),
  
  body('commitIds')
    .notEmpty().withMessage('Commit IDs are required')
    .isArray().withMessage('Commit IDs must be an array')
    .custom(value => {
      if (value.length === 0) {
        throw new Error('At least one commit ID is required');
      }
      return true;
    }),
  
  body('commitIds.*')
    .isString().withMessage('Each commit ID must be a string')
    .matches(/^[a-f0-9]{7,40}$/).withMessage('Invalid commit ID format')
    .trim(),
  
  validateRequest
];

/**
 * Validation rules for getCommitInfo endpoint
 */
const getCommitInfoValidation = [
  body('repository')
    .notEmpty().withMessage('Repository is required')
    .isString().withMessage('Repository must be a string')
    .matches(/^[a-zA-Z0-9-_.]+\/[a-zA-Z0-9-_.]+$/).withMessage('Repository should be in the format owner/repo'),
  
  body('commitIds')
    .notEmpty().withMessage('Commit IDs are required')
    .isArray().withMessage('Commit IDs must be an array')
    .custom(value => {
      if (value.length === 0) {
        throw new Error('At least one commit ID is required');
      }
      return true;
    }),
  
  body('commitIds.*')
    .isString().withMessage('Each commit ID must be a string')
    .matches(/^[a-f0-9]{7,40}$/).withMessage('Invalid commit ID format')
    .trim(),
  
  validateRequest
];

/**
 * Validation rules for cleanupInvalidReports endpoint
 */
const cleanupInvalidReportsValidation = [
  // No specific validation needed for this endpoint
  validateRequest
];

/**
 * Validation rules for getReportById endpoint
 */
const getReportByIdValidation = [
  param('id')
    .notEmpty().withMessage('Report ID is required')
    .custom(isValidObjectId).withMessage('Invalid report ID format'),
  
  validateRequest
];

/**
 * Validation rules for getCacheStats endpoint
 */
const getCacheStatsValidation = [
  // No specific validation needed for this endpoint
  validateRequest
];

/**
 * Validation rules for cleanupReportsCache endpoint
 */
const cleanupReportsCacheValidation = [
  query('olderThan')
    .optional()
    .isInt({ min: 1 }).withMessage('olderThan must be a positive integer')
    .toInt(),
  
  query('accessCountLessThan')
    .optional()
    .isInt({ min: 1 }).withMessage('accessCountLessThan must be a positive integer')
    .toInt(),
  
  validateRequest
];

/**
 * Validation rules for deleteReport endpoint
 */
const deleteReportValidation = [
  param('id')
    .notEmpty().withMessage('Report ID is required')
    .custom(isValidObjectId).withMessage('Invalid report ID format'),
  
  body('confirmationName')
    .notEmpty().withMessage('Confirmation name is required')
    .isString().withMessage('Confirmation name must be a string'),
  
  validateRequest
];

module.exports = {
  getReportsValidation,
  generateReportValidation,
  getCommitInfoValidation,
  cleanupInvalidReportsValidation,
  getReportByIdValidation,
  getCacheStatsValidation,
  cleanupReportsCacheValidation,
  deleteReportValidation,
  validateRequest
}; 

---
File: backend/middleware/auth.js
---
// Authentication middleware

exports.isAuthenticated = (req, res, next) => {
  if (req.isAuthenticated()) {
    return next();
  }
  
  res.status(401).json({ message: 'Unauthorized. Please log in.' });
};

// Middleware to check if the user is an admin
exports.isAdmin = (req, res, next) => {
  if (req.isAuthenticated() && req.user.role === 'admin') {
    return next();
  }
  
  res.status(403).json({ message: 'Forbidden. Admin privileges required.' });
};

// Authentication middleware that attaches user object to requests
exports.authenticate = (req, res, next) => {
  if (req.isAuthenticated()) {
    // User is already authenticated, continue
    return next();
  } else {
    // User is not authenticated
    res.status(401).json({ message: 'Unauthorized. Please log in.' });
  }
};


---
File: backend/middleware/sanitizationMiddleware.js
---
/**
 * Middleware for sanitizing user input
 * Applies basic sanitization to request body, query params, and URL params
 */

const sanitizeInput = (obj) => {
  if (!obj || typeof obj !== 'object') return obj;
  
  Object.keys(obj).forEach(key => {
    const value = obj[key];
    
    // Sanitize strings
    if (typeof value === 'string') {
      // Remove any HTML tags
      obj[key] = value.replace(/<[^>]*>/g, '');
      
      // Normalize whitespace
      obj[key] = obj[key].replace(/\s+/g, ' ').trim();
    } 
    // Recursively sanitize nested objects
    else if (value && typeof value === 'object' && !Buffer.isBuffer(value)) {
      // Check if value is array
      if (Array.isArray(value)) {
        obj[key] = value.map(item => {
          if (typeof item === 'string') {
            return item.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
          } else if (item && typeof item === 'object') {
            return sanitizeInput(item);
          }
          return item;
        });
      } else {
        // Handle nested objects
        obj[key] = sanitizeInput(value);
      }
    }
  });
  
  return obj;
};

/**
 * Express middleware that sanitizes req.body, req.query, and req.params
 */
const sanitizeRequest = (req, res, next) => {
  // Sanitize request body, query parameters, and URL parameters
  req.body = sanitizeInput(req.body);
  req.query = sanitizeInput(req.query);
  req.params = sanitizeInput(req.params);
  
  next();
};

module.exports = {
  sanitizeRequest
}; 

---
File: backend/middleware/csrfMiddleware.js
---
/**
 * Middleware that selectively applies CSRF protection based on HTTP method
 * Only applies protection to state-changing methods (POST, PUT, DELETE, PATCH)
 */
const selectiveCsrfProtection = (csrfProtection) => {
  return (req, res, next) => {
    // Only check CSRF token for state-changing operations
    const stateChangingMethods = ['POST', 'PUT', 'DELETE', 'PATCH'];
    
    if (stateChangingMethods.includes(req.method)) {
      // Apply CSRF protection
      return csrfProtection(req, res, next);
    }
    
    // Skip CSRF check for GET and other methods
    return next();
  };
};

module.exports = { selectiveCsrfProtection }; 

---
File: backend/middleware/errorHandler.js
---
/**
 * Global Error Handler Middleware
 * 
 * This middleware catches all errors thrown in the application and formats them
 * into a standardized response format.
 */

const { isApplicationError, toApplicationError } = require('../utils/errors');

/**
 * Error response formatter
 * Ensures all error responses follow the same structure
 * 
 * @param {Error} err - The error object
 * @returns {Object} - Formatted error response
 */
const formatErrorResponse = (err) => {
  // Convert to ApplicationError if it's not already
  const appError = isApplicationError(err) ? err : toApplicationError(err);
  
  // Basic error response structure
  const errorResponse = {
    status: 'error',
    error: {
      code: appError.errorCode,
      message: appError.message
    }
  };
  
  // Add validation errors if they exist
  if (appError.errors && appError.errors.length > 0) {
    errorResponse.error.details = appError.errors;
  }
  
  // Add service info for external service errors
  if (appError.service) {
    errorResponse.error.service = appError.service;
  }
  
  // Add rate limit info
  if (appError.limit) {
    errorResponse.error.limit = appError.limit;
    
    if (appError.reset) {
      errorResponse.error.reset = appError.reset;
    }
  }
  
  return errorResponse;
};

/**
 * Main error handling middleware
 */
const errorHandler = (err, req, res, next) => {
  // Log the error for server-side debugging
  console.error('Error:', {
    message: err.message,
    stack: err.stack,
    path: req.path,
    method: req.method,
    timestamp: new Date().toISOString()
  });
  
  // Convert to ApplicationError if needed
  const appError = isApplicationError(err) ? err : toApplicationError(err);
  
  // Format the error response
  const errorResponse = formatErrorResponse(appError);
  
  // Send the response with the appropriate status code
  res.status(appError.statusCode || 500).json(errorResponse);
};

/**
 * 404 handler for routes that don't exist
 */
const notFoundHandler = (req, res, next) => {
  const err = new Error(`Route not found: ${req.originalUrl}`);
  err.statusCode = 404;
  err.errorCode = 'ROUTE_NOT_FOUND';
  next(err);
};

module.exports = {
  errorHandler,
  notFoundHandler
}; 

---
File: backend/docs/INPUT_VALIDATION.md
---
# Input Validation in GitStatus

## Overview

GitStatus implements comprehensive input validation to ensure data integrity, prevent security vulnerabilities, and improve API reliability. This document outlines the validation approach and implementation details.

## Implementation Details

### Validation Middleware

All API endpoints in GitStatus use express-validator for request validation:

1. **Route-specific validation rules** are defined in `middleware/validationMiddleware.js`
2. **Global input sanitization** is applied via `middleware/sanitizationMiddleware.js`

### Validation Process Flow

1. **Request received** → Express parses the request body, query parameters, and URL parameters
2. **Sanitization middleware** removes potentially malicious content (HTML tags, excessive whitespace)
3. **Validation middleware** checks that all parameters meet the required constraints
4. **Controller action** processes the request only if validation passes

### Validation Rules

Each endpoint has specific validation rules tailored to its requirements. Common validation checks include:

- **Required fields**: Ensures mandatory parameters are present
- **Type checking**: Verifies parameters have the correct data type
- **Format validation**: Confirms data meets expected patterns (e.g., email format, date format)
- **Range validation**: Ensures numeric values fall within acceptable ranges
- **Logical validation**: Checks business logic constraints (e.g., end date after start date)

### Error Handling

When validation fails:

1. A 400 Bad Request response is returned
2. The response body contains detailed error information:
   ```json
   {
     "error": "Validation failed",
     "details": [
       {
         "param": "email",
         "msg": "Must be a valid email address",
         "location": "body"
       }
     ]
   }
   ```

## Sanitization Details

The sanitization middleware provides defense against common injection attacks by:

1. Removing HTML tags from string inputs
2. Normalizing whitespace
3. Recursively processing nested objects and arrays
4. Preserving non-string data types

## Testing Validation Rules

Validation rules are tested through:

1. Unit tests for each validation rule set
2. Integration tests that verify API behavior with valid and invalid input
3. Security tests that attempt common injection patterns

## Adding New Validation Rules

When adding new API endpoints, follow these steps:

1. Define validation rules in `middleware/validationMiddleware.js`
2. Apply validation middleware to the route in the appropriate route file
3. Update controller code to handle validation errors
4. Add tests to verify validation behavior

## Best Practices

- Always validate and sanitize all user input
- Apply the principle of least privilege - only accept what you expect
- Include validation in the API documentation to help client developers
- Return clear, helpful error messages 

---
File: backend/docs/DATABASE_INDEXES.md
---
# Database Indexes in GitStatus

## Overview

GitStatus uses MongoDB as its primary database and implements strategic indexes to optimize query performance. This document outlines the indexing strategy and provides guidance on adding new indexes.

## Indexes by Collection

### Report Collection

| Index | Fields | Description | Use Cases |
|-------|--------|-------------|-----------|
| `user_createdAt` | `{ user: 1, createdAt: -1 }` | Compound index on user ID (ascending) and creation date (descending) | - Retrieving a user's reports sorted by most recent<br>- Filtering reports by user with date sorting |
| `commitsHash` | `{ commitsHash: 1 }` | Single-field index on the hash of commit IDs | - Finding reports with identical sets of commits<br>- Preventing duplicate report generation |

### User Collection (Default)

| Index | Fields | Description |
|-------|--------|-------------|
| `_id` | `{ _id: 1 }` | Default primary key index |
| `email` | `{ email: 1 }` | Unique index on email field |
| `githubId` | `{ githubId: 1 }` | Unique index on GitHub ID |

## Performance Considerations

1. **Index Selection**: MongoDB selects the most efficient index for a given query. The query planner evaluates available indexes and execution plans to find the optimal approach.

2. **Covered Queries**: When possible, create indexes that cover the entire query (all fields in the query are part of an index), eliminating the need to fetch documents.

3. **Index Size**: Indexes consume memory and storage. Monitor index size using `db.collection.stats()` to ensure optimal resource usage.

4. **Write Performance**: While indexes speed up reads, they slightly impact write performance as each index must be updated when a document changes.

## Creating and Managing Indexes

### Adding Indexes to Models

Indexes are defined in the Mongoose schema for each model. For example:

```javascript
const ReportSchema = new mongoose.Schema({
  // Schema fields...
});

// Add indexes
ReportSchema.index({ user: 1, createdAt: -1 });
ReportSchema.index({ commitsHash: 1 });
```

### Applying Indexes

To apply indexes to existing data, run the index creation script:

```bash
node scripts/createIndexes.js
```

This script creates all indexes defined in the models and displays a list of current indexes on each collection.

### Monitoring Index Usage

To monitor whether indexes are being used effectively:

1. Enable MongoDB profiling with `db.setProfilingLevel(1, 100)` to log slow queries
2. Use `db.collection.explain()` to analyze query execution plans
3. Review query performance in MongoDB Atlas or other monitoring tools

## Best Practices

1. **Index for Query Patterns**: Create indexes based on common query patterns and access patterns
2. **Compound Indexes**: Use compound indexes for queries that filter on multiple fields
3. **Avoid Redundant Indexes**: Remove unused or redundant indexes
4. **Periodic Review**: Regularly review index usage and query performance

## Adding New Indexes

When adding new indexes, follow these steps:

1. Identify slow queries or frequently used access patterns
2. Profile the query to confirm the need for an index
3. Add the index to the appropriate model schema
4. Run the index creation script to apply the index
5. Verify improved query performance
6. Document the new index in this document

---
File: backend/docs/CSRF_PROTECTION.md
---
# CSRF Protection in GitStatus

## Overview

Cross-Site Request Forgery (CSRF) is an attack that forces authenticated users to execute unwanted actions on a web application in which they're currently authenticated. GitStatus implements CSRF protection using the `csrf-csrf` package to prevent such attacks.

## Implementation Details

### Token-Based Protection

Our CSRF protection uses a double submit cookie pattern:

1. A secure, HTTP-only cookie containing a CSRF token is set on the client
2. For state-changing operations (POST, PUT, DELETE, PATCH), clients must include the CSRF token in the request headers
3. The server validates that the token in the request header matches the token in the cookie

### Selective Application

CSRF protection is selectively applied:

- Only state-changing HTTP methods (POST, PUT, DELETE, PATCH) require CSRF token validation
- GET requests and other read-only operations don't require token validation

This is implemented through the `selectiveCsrfProtection` middleware in `middleware/csrfMiddleware.js`.

## How to Use CSRF Protection in Frontend Code

### Getting a CSRF Token

To obtain a CSRF token, make a GET request to `/api/csrf-token`:

```javascript
// Example using fetch API
async function getCsrfToken() {
  const response = await fetch('/api/csrf-token', {
    credentials: 'include', // Important: include cookies
  });
  const data = await response.json();
  return data.csrfToken;
}
```

### Including CSRF Token in Requests

For all state-changing operations, include the CSRF token in the request headers:

```javascript
// Example using fetch API
async function postData(url, data) {
  const csrfToken = await getCsrfToken();
  
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'csrf-token': csrfToken, // Include CSRF token in header
    },
    credentials: 'include', // Important: include cookies
    body: JSON.stringify(data),
  });
  
  return response.json();
}
```

## Best Practices

1. Always include the CSRF token for state-changing operations
2. Implement automatic token inclusion in your API client
3. Handle CSRF validation errors by refreshing the token and retrying the request
4. Consider adding CSRF token refresh logic in your error handling middleware

## Security Considerations

- The CSRF token is stored in an HTTP-only cookie to prevent access by JavaScript
- Token validation only happens for state-changing operations to avoid performance overhead
- The cookie has the `SameSite=Lax` attribute for additional protection
- In production environments, the `Secure` flag is set to ensure the cookie is only sent over HTTPS

## Configuration

The CSRF protection is configured in `server.js` with the following options:

- Token size: 64 bytes
- Cookie name: `csrf-token`
- Secret: Uses `CSRF_SECRET` environment variable or falls back to a default value
- Cookie options: `httpOnly`, `sameSite: 'lax'`, and `secure` in production 

---
File: backend/scripts/makeAdmin.js
---
const mongoose = require('mongoose');
const User = require('../models/User');

// Connect to MongoDB
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/gitstatus')
  .then(async () => {
    try {
      // Get all users
      const users = await User.find({});
      
      if (users.length === 0) {
        console.log('No users found in the database.');
        process.exit(1);
      }

      // If there's only one user, make them an admin
      if (users.length === 1) {
        const user = users[0];
        user.role = 'admin';
        await user.save();
        console.log(`Made user ${user.username} an admin.`);
      } else {
        console.log('Multiple users found. Please specify which user to make admin:');
        users.forEach((user, index) => {
          console.log(`${index + 1}. ${user.username} (${user.name})`);
        });
      }

      process.exit(0);
    } catch (error) {
      console.error('Error:', error);
      process.exit(1);
    }
  })
  .catch(err => {
    console.error('MongoDB connection error:', err);
    process.exit(1);
  }); 

---
File: backend/services/PlanService.js
---
const Plan = require('../models/Plan');

class PlanService {
  /**
   * Initialize default plan if it doesn't exist
   */
  static async initializeDefaultPlan() {
    try {
      const defaultPlan = await Plan.findOne({ isDefault: true });
      
      if (!defaultPlan) {
        await Plan.create({
          name: 'free',
          displayName: 'Free Plan',
          description: 'Basic GitHub analytics for individual developers',
          limits: {
            reportsPerMonth: 50,
            commitsPerStandardReport: 5,
            commitsPerLargeReport: 20
          },
          isDefault: true
        });
        console.log('Default plan created successfully');
      }
    } catch (error) {
      console.error('Error initializing default plan:', error);
      throw error;
    }
  }

  /**
   * Get default plan
   * @returns {Promise<Object>} Default plan
   */
  static async getDefaultPlan() {
    try {
      const defaultPlan = await Plan.findOne({ isDefault: true });
      if (!defaultPlan) {
        throw new Error('Default plan not found');
      }
      return defaultPlan;
    } catch (error) {
      console.error('Error getting default plan:', error);
      throw error;
    }
  }

  /**
   * Get plan by ID
   * @param {string} planId - Plan ID
   * @returns {Promise<Object>} Plan
   */
  static async getPlanById(planId) {
    try {
      const plan = await Plan.findById(planId);
      if (!plan) {
        throw new Error('Plan not found');
      }
      return plan;
    } catch (error) {
      console.error('Error getting plan:', error);
      throw error;
    }
  }

  /**
   * Get all plans
   * @returns {Promise<Array>} Array of plans
   */
  static async getAllPlans() {
    try {
      return await Plan.find({});
    } catch (error) {
      console.error('Error getting plans:', error);
      throw error;
    }
  }

  /**
   * Update plan
   * @param {string} planId - Plan ID
   * @param {Object} updates - Plan updates
   * @returns {Promise<Object>} Updated plan
   */
  static async updatePlan(planId, updates) {
    try {
      const plan = await Plan.findByIdAndUpdate(
        planId,
        { ...updates, updatedAt: new Date() },
        { new: true, runValidators: true }
      );
      
      if (!plan) {
        throw new Error('Plan not found');
      }
      
      return plan;
    } catch (error) {
      console.error('Error updating plan:', error);
      throw error;
    }
  }

  static async updatePlanLimits(planId, limits) {
    try {
      const plan = await Plan.findById(planId);
      if (!plan) {
        throw new Error('Plan not found');
      }

      plan.limits = {
        ...plan.limits,
        ...limits
      };

      await plan.save();
      return plan;
    } catch (error) {
      console.error('Error updating plan limits:', error);
      throw error;
    }
  }
}

module.exports = PlanService; 

---
File: backend/services/PDFService.js
---
/**
 * PDF Generation Service
 * 
 * Uses Puppeteer to generate PDF files from HTML content
 * which allows for proper rendering of Markdown and better formatting
 */
const puppeteer = require('puppeteer');
const marked = require('marked');
const fs = require('fs').promises;
const path = require('path');
const os = require('os');
const queueService = require('./queue');

// Configure marked for GFM (GitHub Flavored Markdown)
marked.setOptions({
  gfm: true,
  breaks: true,
  headerIds: true,
  sanitize: false
});

/**
 * HTML template for PDF generation
 * @param {object} options - Template options
 * @returns {string} - Complete HTML template
 */
const getHtmlTemplate = (options) => {
  const { content, title, repository, startDate, endDate } = options;
  
  return `
  <!DOCTYPE html>
  <html>
  <head>
    <meta charset="UTF-8">
    <title>${title || repository}</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        margin: 0;
        padding: 0;
        background-color: white;
      }
      
      .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 40px 20px;
      }
      
      h1 {
        font-size: 24px;
        color: #2c3e50;
        margin-top: 30px;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
      }
      
      h2 {
        font-size: 20px;
        color: #34495e;
        margin-top: 25px;
      }
      
      h3 {
        font-size: 18px;
        color: #34495e;
      }
      
      p {
        margin-bottom: 16px;
      }
      
      ul, ol {
        margin-bottom: 20px;
        padding-left: 20px;
      }
      
      li {
        margin-bottom: 8px;
      }
      
      code {
        font-family: 'Courier New', Courier, monospace;
        background-color: #f5f5f5;
        padding: 2px 4px;
        border-radius: 3px;
        font-size: 14px;
      }
      
      pre {
        background-color: #f5f5f5;
        padding: 12px;
        border-radius: 4px;
        overflow-x: auto;
        margin-bottom: 20px;
      }
      
      pre code {
        padding: 0;
        background-color: transparent;
      }
      
      blockquote {
        border-left: 4px solid #ddd;
        padding-left: 16px;
        margin-left: 0;
        color: #666;
      }
      
      table {
        border-collapse: collapse;
        width: 100%;
        margin-bottom: 20px;
      }
      
      th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
        text-align: left;
      }
      
      th {
        background-color: #f5f5f5;
      }
      
      .footer {
        margin-top: 40px;
        padding-top: 20px;
        border-top: 1px solid #eee;
        font-size: 12px;
        color: #7f8c8d;
        text-align: center;
      }
      
      .highlight {
        background-color: #ffffcc;
        padding: 0 2px;
      }
      
      .page-break {
        page-break-after: always;
      }
    </style>
  </head>
  <body>
    <div class="container">
      ${content}
    </div>
  </body>
  </html>
  `;
};

/**
 * Generate a PDF file from Markdown content
 * This implementation is used directly by the PDF job queue processor
 * 
 * @param {object} options - PDF generation options
 * @returns {Buffer} - PDF file buffer
 */
const _generatePDF = async (options) => {
  const { title, content, repository, startDate, endDate } = options;
  
  if (!content) {
    throw new Error('No content provided for PDF generation');
  }
  
  // Ensure content is a string
  const contentStr = typeof content === 'string' 
    ? content 
    : (content?.content || JSON.stringify(content, null, 2));
  
  // Convert markdown to HTML
  const htmlContent = marked.parse(contentStr);
  
  // Create full HTML document
  const htmlTemplate = getHtmlTemplate({
    title,
    content: htmlContent,
    repository,
    date: new Date(),
    startDate,
    endDate
  });
  
  // Create a temporary file for the HTML
  const tempDir = await fs.mkdtemp(path.join(os.tmpdir(), 'gitstatus-'));
  const htmlPath = path.join(tempDir, 'report.html');
  
  try {
    // Write HTML to temporary file
    await fs.writeFile(htmlPath, htmlTemplate, 'utf8');
    
    // Launch browser and create PDF
    let browser;
    let resultBuffer = null;
    
    try {
      browser = await puppeteer.launch({
        headless: 'new',
        args: [
          '--no-sandbox',
          '--disable-setuid-sandbox',
          '--disable-dev-shm-usage',
          '--disable-accelerated-2d-canvas',
          '--no-first-run',
          '--no-zygote',
          '--single-process',
          '--disable-gpu'
        ]
      });
    } catch (browserError) {
      console.error('Error launching puppeteer browser:', browserError);
      throw new Error('Failed to launch browser: ' + browserError.message);
    }
    
    try {
      const page = await browser.newPage();
      
      try {
        await page.goto(`file://${htmlPath}`, { 
          waitUntil: 'networkidle0',
          timeout: 30000
        });
      } catch (navError) {
        console.error('Navigation error:', navError);
        throw new Error('Failed to load HTML in browser: ' + navError.message);
      }
      
      // Generate PDF
      try {
        const pdfBuffer = await page.pdf({
          format: 'A4',
          printBackground: true,
          margin: {
            top: '30px',
            right: '30px',
            bottom: '30px',
            left: '30px'
          },
          displayHeaderFooter: true,
          headerTemplate: '<div></div>', // Empty header
          footerTemplate: '<div style="font-size: 10px; text-align: right; width: 100%; padding-right: 30px; color: #95a5a6;">Page <span class="pageNumber"></span> of <span class="totalPages"></span></div>',
          timeout: 60000
        });
        
        // Always create a Buffer from the result (even if it's not a proper Buffer instance)
        if (!pdfBuffer || pdfBuffer.length === 0) {
          console.error('PDF buffer is empty or undefined');
          throw new Error('Generated PDF buffer is empty');
        }
        
        // Create a Buffer from the ArrayBuffer/Uint8Array that Puppeteer returns
        resultBuffer = Buffer.from(pdfBuffer);
      } catch (pdfError) {
        console.error('PDF generation error:', pdfError);
        throw new Error('Failed to generate PDF: ' + pdfError.message);
      }
    } finally {
      if (browser) {
        await browser.close();
      }
    }
    
    // Return the buffer after browser is closed
    if (!resultBuffer) {
      throw new Error('PDF generation failed - no buffer was created');
    }
    
    return resultBuffer;
  } finally {
    // Cleanup temporary files
    try {
      await fs.unlink(htmlPath);
      await fs.rmdir(tempDir);
    } catch (error) {
      console.error('Error cleaning up temporary files:', error);
    }
  }
};

/**
 * Public interface for PDF generation that returns a job ID
 * and triggers background processing
 * 
 * @param {object} options - PDF generation options
 * @param {string} reportId - Report ID to update when complete
 * @returns {Promise<Object>} - Job information with ID and status
 */
const generatePDF = async (options, reportId) => {
  if (!reportId) {
    throw new Error('Report ID is required for background PDF generation');
  }
  
  // Add job to the queue
  const jobInfo = await queueService.addPdfGenerationJob(options, reportId);
  
  return jobInfo;
};

/**
 * Get the status of a PDF generation job
 * 
 * @param {string} jobId - Job ID to check
 * @returns {Promise<Object>} - Job status information
 */
const getPdfJobStatus = async (jobId) => {
  return await queueService.getPdfJobStatus(jobId);
};

module.exports = {
  generatePDF,
  _generatePDF,
  getPdfJobStatus
};


---
File: backend/services/GitHub/index.js
---
/**
 * Exports all GitHub-related services
 */

const GitHubRepositoryService = require('./GitHubRepositoryService');
const GitHubCommitService = require('./GitHubCommitService');
const GitHubBranchService = require('./GitHubBranchService');
const GitHubSearchService = require('./GitHubSearchService');

module.exports = {
  GitHubRepositoryService,
  GitHubCommitService,
  GitHubBranchService,
  GitHubSearchService
}; 

---
File: backend/services/GitHub/GitHubSearchService.js
---
const axios = require('axios');

/**
 * Service for search-related GitHub API operations
 */
class GitHubSearchService {
  /**
   * Search for repositories based on a query
   */
  async searchRepositories({ accessToken, query, limit = 10 }) {
    try {
      // First try to search specifically for the user's repositories
      const userReposUrl = 'https://api.github.com/user/repos';
      
      const headers = {
        Authorization: `token ${accessToken}`,
        Accept: 'application/vnd.github.v3+json'
      };
      
      const userReposResponse = await axios.get(userReposUrl, { 
        headers, 
        params: { 
          perPage: 100,
          sort: 'updated',
          direction: 'desc'
        } 
      });
      
      // Filter user repos by the query
      const matchingUserRepos = userReposResponse.data
        .filter(repo => repo.fullName.toLowerCase().includes(query.toLowerCase()))
        .slice(0, limit)
        .map(repo => ({
          id: repo.id,
          fullName: repo.fullName,
          name: repo.name,
          owner: repo.owner.login,
          description: repo.description,
          isPrivate: repo.private,
          stars: repo.stargazersCount,
          defaultBranch: repo.defaultBranch
        }));
      
      // If we have enough user repos, just return those
      if (matchingUserRepos.length >= limit) {
        return matchingUserRepos;
      }
      
      // Otherwise, search all GitHub repositories the user has access to
      const searchUrl = 'https://api.github.com/search/repositories';
      
      // Search for repositories the user might have access to
      const searchResponse = await axios.get(searchUrl, { 
        headers, 
        params: { 
          q: query,
          perPage: limit - matchingUserRepos.length
        } 
      });
      
      const searchResults = searchResponse.data.items.map(repo => ({
        id: repo.id,
        fullName: repo.fullName,
        name: repo.name,
        owner: repo.owner.login,
        description: repo.description,
        isPrivate: repo.private,
        stars: repo.stargazersCount,
        defaultBranch: repo.defaultBranch
      }));
      
      // Combine results, prioritizing user's own repos
      return [...matchingUserRepos, ...searchResults];
    } catch (error) {
      console.error('Error searching repositories:', error);
      return [];
    }
  }

  /**
   * Search for repositories based on a query string
   */
  async searchRepositoriesByName({ accessToken, query }) {
    if (!query || query.trim().length < 2) {
      return [];
    }

    const headers = { Authorization: `token ${accessToken}` };
    const userRepos = [];
    let searchRepos = [];

    try {
      // First search the user's repositories for a faster initial result
      const userReposResponse = await axios.get('https://api.github.com/user/repos', {
        headers,
        params: {
          perPage: 100
        }
      });

      userRepos.push(...userReposResponse.data
        .filter(repo => repo.fullName.toLowerCase().includes(query.toLowerCase()))
        .map(repo => ({
          id: repo.id,
          fullName: repo.fullName,
          name: repo.name,
          owner: repo.owner.login,
          ownerAvatar: repo.owner.avatarUrl,
          description: repo.description,
          isPrivate: repo.private,
          defaultBranch: repo.defaultBranch
        }))
      );
    } catch (error) {
      console.error('Error searching user repositories:', error.message);
    }

    try {
      // Then search all GitHub repos
      const searchResponse = await axios.get('https://api.github.com/search/repositories', {
        headers,
        params: {
          q: query,
          perPage: 10
        }
      });

      searchRepos = searchResponse.data.items
        .map(repo => ({
          id: repo.id,
          fullName: repo.fullName,
          name: repo.name,
          owner: repo.owner.login,
          ownerAvatar: repo.owner.avatarUrl,
          description: repo.description,
          isPrivate: repo.private,
          defaultBranch: repo.defaultBranch
        }))
        // Filter out duplicates that might be in userRepos
        .filter(searchRepo => !userRepos.some(userRepo => userRepo.id === searchRepo.id));
    } catch (error) {
      console.error('Error searching GitHub repositories:', error.message);
    }

    // Prioritize user repos in the results
    return [...userRepos, ...searchRepos].slice(0, 10);
  }
}

module.exports = new GitHubSearchService(); 

---
File: backend/services/GitHub/GitHubBranchService.js
---
const axios = require('axios');

// Import the custom error classes
const { 
  NotFoundError, 
  ExternalServiceError
} = require('../utils/errors');

/**
 * Service for branch-related GitHub API operations
 */
class GitHubBranchService {
  /**
   * Get all branches for a repository
   */
  async getBranches({ accessToken, repository }) {
    try {
      const url = `https://api.github.com/repos/${repository}/branches`;
      
      const headers = {
        Authorization: `token ${accessToken}`,
        Accept: 'application/vnd.github.v3+json'
      };
      
      const response = await axios.get(url, { 
        headers,
        params: { perPage: 100 }
      });
      
      return response.data.map(branch => ({
        name: branch.name,
        protected: branch.protected
      }));
    } catch (error) {
      if (error.response && error.response.status === 404) {
        throw new NotFoundError('Repository not found or you do not have access to it');
      }
      throw error;
    }
  }

  /**
   * Get authors who contributed to specific branches
   */
  async getAuthorsForBranches({ accessToken, repository, branches }) {
    if (!repository || !branches || branches.length === 0) {
      return [];
    }

    const headers = { Authorization: `token ${accessToken}` };
    const allAuthors = new Set();
    const [owner, repo] = repository.split('/');

    try {
      // For each branch, fetch commits and collect unique authors
      for (const branch of branches) {
        let page = 1;
        let hasMore = true;

        while (hasMore) {
          const response = await axios.get(`https://api.github.com/repos/${owner}/${repo}/commits`, {
            headers,
            params: {
              sha: branch,
              perPage: 100,
              page
            }
          });

          // Extract authors from commits
          response.data.forEach(commit => {
            if (commit.author && commit.author.login) {
              allAuthors.add(commit.author.login);
            }
          });

          // Check if there are more pages
          hasMore = response.data.length === 100;
          page++;

          // Safety check to prevent too many API calls
          if (page > 5) {
            break;
          }
        }
      }

      return Array.from(allAuthors);
    } catch (error) {
      console.error(`Error fetching authors for branches in ${repository}:`, error.message);
      throw error;
    }
  }

  /**
   * Get branches that contain a specific commit
   * This is a more accurate way to determine which branches contain a commit
   * @param {Object} options - Options
   * @returns {Promise<Array>} - List of branch names
   */
  async getBranchesForCommit({ accessToken, repository, commitSha }) {
    try {
      console.log(`Getting branches for commit ${commitSha} in ${repository}`);
      
      // First, verify the commit exists
      try {
        const commitUrl = `https://api.github.com/repos/${repository}/commits/${commitSha}`;
        const headers = {
          Authorization: `token ${accessToken}`,
          Accept: 'application/vnd.github.v3+json'
        };
        
        await axios.get(commitUrl, { headers });
      } catch (error) {
        console.error(`Error verifying commit ${commitSha}:`, error.message);
        return [];
      }
      
      // Get all repository branches
      const url = `https://api.github.com/repos/${repository}/branches`;
      
      const headers = {
        Authorization: `token ${accessToken}`,
        Accept: 'application/vnd.github.v3+json'
      };
      
      const response = await axios.get(url, { headers });
      const branches = response.data;
      
      // First, try the direct GitHub API endpoint for branch containing commit
      // Not all GitHub instances support this, so we'll fall back to our existing method if it fails
      try {
        const containingBranchesUrl = `https://api.github.com/repos/${repository}/commits/${commitSha}/branches-where-head`;
        const containingResponse = await axios.get(containingBranchesUrl, { headers });
        
        if (containingResponse.data && Array.isArray(containingResponse.data)) {
          const branchNames = containingResponse.data.map(branch => branch.name);
          if (branchNames.length > 0) {
            // Limit to max 5 branches per commit to avoid overwhelming the system
            return branchNames.slice(0, 5);
          }
          // If we get an empty array, fall through to the manual check
        }
      } catch (error) {
        console.log('API endpoint not supported, falling back to manual check:', error.message);
        // Fall through to our manual check
      }
      
      // For each branch, check if the commit is reachable
      // Only check the first 5 branches to avoid overwhelming the API
      const branchesToCheck = branches.slice(0, 5);
      console.log(`Checking ${branchesToCheck.length} branches for commit ${commitSha}`);
      
      const branchPromises = branchesToCheck.map(async (branch) => {
        try {
          // First try to get the commit directly in this branch
          try {
            const commitInBranchUrl = `https://api.github.com/repos/${repository}/git/refs/heads/${branch.name}`;
            const branchHeadResponse = await axios.get(commitInBranchUrl, { headers });
            const branchHeadSha = branchHeadResponse.data.object.sha;
            
            // If the branch head SHA matches our commit SHA, it's definitely in this branch
            if (branchHeadSha === commitSha) {
              return branch.name;
            }
            
            // If not, we need to check if it's in the branch history
            try {
              // Use the git/commits API to check commit ancestry
              const commitAncestryUrl = `https://api.github.com/repos/${repository}/commits?sha=${branch.name}&perPage=100`;
              const ancestryResponse = await axios.get(commitAncestryUrl, { headers });
              
              // Check if our commit is in the returned commits
              if (ancestryResponse.data.some(c => c.sha === commitSha)) {
                return branch.name;
              }
            } catch (ancestryError) {
              console.error(`Error checking ancestry for ${branch.name}:`, ancestryError.message);
            }
          } catch (branchError) {
            console.error(`Error getting branch head for ${branch.name}:`, branchError.message);
          }
          
          return null;
        } catch (error) {
          console.error(`Error checking if commit ${commitSha} is in branch ${branch.name}:`, error);
          return null;
        }
      });
      
      const branchResults = await Promise.all(branchPromises);
      return branchResults.filter(branch => branch !== null);
    } catch (error) {
      console.error(`Error getting branches for commit ${commitSha}:`, error);
      return [];
    }
  }
}

module.exports = new GitHubBranchService(); 

---
File: backend/services/GitHub/GitHubCommitService.js
---
const axios = require('axios');

// Import the custom error classes
const { 
  NotFoundError, 
  ExternalServiceError, 
  AuthenticationError,
  ValidationError
} = require('../utils/errors');

/**
 * Service for commit-related GitHub API operations
 */
class GitHubCommitService {
  /**
   * Get commits based on filter criteria
   */
  async getCommits({ accessToken, repository, branch = 'main', author, startDate, endDate }) {
    // Construct the GitHub API URL
    const url = `https://api.github.com/repos/${repository}/commits`;
    
    // Set up the parameters for the API request
    const params = {
      sha: branch,
      perPage: 100
    };
    
    if (author) {
      params.author = author;
    }
    
    // Set up the headers with the access token
    const headers = {
      Authorization: `token ${accessToken}`,
      Accept: 'application/vnd.github.v3+json'
    };
    
    // Make the request to the GitHub API
    const response = await axios.get(url, { params, headers });
    
    // Filter commits by date if needed
    let commits = response.data;
    
    if (startDate) {
      const startDateTime = new Date(startDate).getTime();
      commits = commits.filter(commit => {
        const commitDate = new Date(commit.commit.author.date).getTime();
        return commitDate >= startDateTime;
      });
    }
    
    if (endDate) {
      const endDateTime = new Date(endDate).getTime();
      commits = commits.filter(commit => {
        const commitDate = new Date(commit.commit.author.date).getTime();
        return commitDate <= endDateTime;
      });
    }
    
    // Map the commits to a simpler format
    return commits.map(commit => ({
      sha: commit.sha,
      message: commit.commit.message,
      author: commit.commit.author.name,
      date: commit.commit.author.date,
      url: commit.htmlUrl
    }));
  }
  
  /**
   * Get details for a specific commit, including the diff
   */
  async getCommitDetails({ accessToken, repository, commitId }) {
    // Get the commit details
    const url = `https://api.github.com/repos/${repository}/commits/${commitId}`;
    
    const headers = {
      Authorization: `token ${accessToken}`,
      Accept: 'application/vnd.github.v3+json'
    };
    
    const response = await axios.get(url, { headers });
    const commit = response.data;
    
    // Get the diff
    const diffUrl = `https://api.github.com/repos/${repository}/commits/${commitId}`;
    const diffHeaders = {
      ...headers,
      Accept: 'application/vnd.github.v3.diff'
    };
    
    const diffResponse = await axios.get(diffUrl, { headers: diffHeaders });
    const diff = diffResponse.data;
    
    return {
      sha: commit.sha,
      message: commit.commit.message,
      author: commit.commit.author.name,
      date: commit.commit.author.date,
      url: commit.htmlUrl,
      diff
    };
  }

  // Get commits with file diffs
  async getCommitsWithDiffs({ accessToken, repository, branches, authors, startDate, endDate, includeFiles }) {
    // Get commits for each branch
    let allCommits = [];
    
    for (const branch of branches) {
      // Construct the GitHub API URL
      const url = `https://api.github.com/repos/${repository}/commits`;
      
      // Set up query parameters
      const params = {
        sha: branch,
        perPage: 100 // Maximum per page
      };
      
      // Add date range if provided
      if (startDate) {
        params.since = startDate.toISOString();
      }
      
      if (endDate) {
        params.until = endDate.toISOString();
      }
      
      // Set up headers with authentication
      const headers = {
        Authorization: `token ${accessToken}`,
        Accept: 'application/vnd.github.v3+json'
      };
      
      try {
        // Get commits for this branch
        const response = await axios.get(url, { params, headers });
        const branchCommits = response.data;
        
        // Filter by authors if specified
        let filteredCommits = branchCommits;
        if (authors && authors.length > 0) {
          filteredCommits = branchCommits.filter(commit => {
            // Check if commit author matches any of the specified authors
            const authorName = commit.author?.login || commit.commit.author.name;
            return authors.includes(authorName);
          });
        }
        
        // Fetch file diffs for each commit if requested
        if (includeFiles) {
          for (const commit of filteredCommits) {
            // Check if we already have this commit with files
            const existingCommit = allCommits.find(c => c.sha === commit.sha);
            if (existingCommit && existingCommit.files) {
              continue;
            }
            
            // Fetch commit details with files
            const commitUrl = `https://api.github.com/repos/${repository}/commits/${commit.sha}`;
            const commitResponse = await axios.get(commitUrl, { headers });
            
            // Add files to commit object
            commit.files = commitResponse.data.files;
          }
        }
        
        // Add filtered commits to all commits, avoiding duplicates
        for (const commit of filteredCommits) {
          if (!allCommits.some(c => c.sha === commit.sha)) {
            // Format the commit object for frontend consumption
            const formattedCommit = {
              sha: commit.sha,
              message: commit.commit.message,
              author: {
                login: commit.author?.login,
                name: commit.commit.author.name,
                email: commit.commit.author.email,
                avatarUrl: commit.author?.avatarUrl
              },
              date: commit.commit.author.date,
              htmlUrl: commit.htmlUrl,
              files: commit.files ? commit.files.map(file => ({
                filename: file.filename,
                status: file.status,
                additions: file.additions,
                deletions: file.deletions,
                changes: file.changes,
                patch: file.patch
              })) : []
            };
            
            allCommits.push(formattedCommit);
          }
        }
      } catch (error) {
        console.error(`Error fetching commits for branch ${branch}:`, error);
        throw error;
      }
    }
    
    // Sort commits by date (newest first)
    allCommits.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    return allCommits;
  }

  // Get specific commits by their IDs
  async getCommitsByIds({ accessToken, repository, commitIds }) {
    const headers = {
      Authorization: `token ${accessToken}`,
      Accept: 'application/vnd.github.v3+json'
    };
    
    const commits = [];
    
    for (const commitId of commitIds) {
      try {
        // Fetch the commit
        const url = `https://api.github.com/repos/${repository}/commits/${commitId}`;
        const response = await axios.get(url, { headers });
        const commit = response.data;
        
        // Format the commit
        const formattedCommit = {
          sha: commit.sha,
          message: commit.commit.message,
          author: {
            login: commit.author?.login,
            name: commit.commit.author.name,
            email: commit.commit.author.email,
            avatarUrl: commit.author?.avatarUrl
          },
          date: commit.commit.author.date,
          htmlUrl: commit.htmlUrl,
          files: commit.files ? commit.files.map(file => ({
            filename: file.filename,
            status: file.status,
            additions: file.additions,
            deletions: file.deletions,
            changes: file.changes,
            patch: file.patch
          })) : []
        };
        
        commits.push(formattedCommit);
      } catch (error) {
        console.error(`Error fetching commit ${commitId}:`, error);
        // Continue with other commits even if one fails
      }
    }
    
    // Sort commits by date (newest first)
    commits.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    return commits;
  }

  // Get date range (first and last commit dates) based on branches and authors
  async getDateRangeForBranchesAndAuthors({ accessToken, repository, branches, authors }) {
    if (!repository || !branches || branches.length === 0) {
      return { firstCommitDate: null, lastCommitDate: null };
    }

    const headers = { Authorization: `token ${accessToken}` };
    const [owner, repo] = repository.split('/');
    let firstCommitDate = null;
    let lastCommitDate = null;

    try {
      // For each branch, get the first and last commits
      for (const branch of branches) {
        // Get latest commits first
        const latestResponse = await axios.get(`https://api.github.com/repos/${owner}/${repo}/commits`, {
          headers,
          params: {
            sha: branch,
            perPage: 1,
            page: 1,
            ...(authors && authors.length > 0 ? { author: authors.join(',') } : {})
          }
        });

        if (latestResponse.data.length > 0) {
          const latestCommitDate = new Date(latestResponse.data[0].commit.committer.date);
          if (!lastCommitDate || latestCommitDate > lastCommitDate) {
            lastCommitDate = latestCommitDate;
          }
        }

        // Now get the earliest commits - this is more complex as we need to search backwards
        // For simplicity, we'll get all commits and find the oldest
        // In a production scenario, you might want to optimize this with pagination
        let page = 1;
        let hasMore = true;
        let earliestCommitDate = null;

        while (hasMore) {
          const earliestResponse = await axios.get(`https://api.github.com/repos/${owner}/${repo}/commits`, {
            headers,
            params: {
              sha: branch,
              perPage: 100,
              page,
              ...(authors && authors.length > 0 ? { author: authors.join(',') } : {})
            }
          });

          if (earliestResponse.data.length > 0) {
            // Get the earliest commit date from this batch
            const batchEarliestDate = earliestResponse.data
              .map(commit => new Date(commit.commit.committer.date))
              .reduce((earliest, date) => (!earliest || date < earliest) ? date : earliest, null);

            if (batchEarliestDate && (!earliestCommitDate || batchEarliestDate < earliestCommitDate)) {
              earliestCommitDate = batchEarliestDate;
            }
          }

          // Check if there are more pages
          hasMore = earliestResponse.data.length === 100;
          page++;

          // Safety check to prevent too many API calls
          if (page > 5) {
            break;
          }
        }

        if (earliestCommitDate && (!firstCommitDate || earliestCommitDate < firstCommitDate)) {
          firstCommitDate = earliestCommitDate;
        }
      }

      return { 
        firstCommitDate: firstCommitDate ? firstCommitDate.toISOString() : null, 
        lastCommitDate: lastCommitDate ? lastCommitDate.toISOString() : null 
      };
    } catch (error) {
      console.error(`Error fetching date range for repository ${repository}:`, error.message);
      throw error;
    }
  }
}

module.exports = new GitHubCommitService(); 

---
File: backend/services/GitHub/GitHubRepositoryService.js
---
const axios = require('axios');
const { Octokit } = require('@octokit/core');

// Import the custom error classes
const { 
  NotFoundError, 
  ExternalServiceError, 
  AuthenticationError,
  ValidationError
} = require('../utils/errors');

/**
 * Service for repository-related GitHub API operations
 */
class GitHubRepositoryService {
  /**
   * Validate and get basic information about a repository
   */
  async getRepositoryInfo({ accessToken, repository }) {
    if (!accessToken) {
      throw new AuthenticationError('GitHub access token is required');
    }

    if (!repository) {
      throw new ValidationError('Repository name is required');
    }

    try {
      // Create an Octokit instance
      const octokit = new Octokit({
        auth: accessToken
      });

      // Extract owner and repo from repository string
      const [owner, repo] = repository.split('/');

      if (!owner || !repo) {
        throw new ValidationError('Invalid repository format. Must be owner/repo');
      }

      // Get repository information
      const response = await octokit.rest.repos.get({
        owner,
        repo,
      });

      return {
        name: response.data.name,
        fullName: response.data.fullName,
        description: response.data.description,
        defaultBranch: response.data.defaultBranch,
        isPrivate: response.data.private,
        avatarUrl: response.data.owner.avatarUrl
      };
    } catch (error) {
      // Handle GitHub API errors
      if (error.status === 404) {
        throw new NotFoundError('Repository not found or you do not have access to it');
      }

      if (error.status === 401 || error.status === 403) {
        throw new AuthenticationError('GitHub authentication failed or token has insufficient permissions');
      }

      // For other GitHub API errors
      throw new ExternalServiceError(
        `GitHub API error: ${error.message}`,
        'github'
      );
    }
  }

  /**
   * Get contributors (authors) for a repository
   */
  async getContributors({ accessToken, repository }) {
    try {
      const url = `https://api.github.com/repos/${repository}/contributors`;
      
      const headers = {
        Authorization: `token ${accessToken}`,
        Accept: 'application/vnd.github.v3+json'
      };
      
      const response = await axios.get(url, { 
        headers,
        params: { perPage: 100 }
      });
      
      return response.data.map(contributor => ({
        login: contributor.login,
        avatarUrl: contributor.avatarUrl,
        contributions: contributor.contributions
      }));
    } catch (error) {
      if (error.response && error.response.status === 404) {
        throw new Error('Repository not found or you do not have access to it');
      }
      throw error;
    }
  }

  // Utility function to format dates in ISO format
  formatDate(date) {
    return date ? date.toISOString() : null;
  }
}

module.exports = new GitHubRepositoryService(); 

---
File: backend/services/S3Service.js
---
const AWS = require('aws-sdk');
const { v4: uuidv4 } = require('uuid');
const path = require('path');
const fs = require('fs');
const { promisify } = require('util');
const readFileAsync = promisify(fs.readFile);
const unlinkAsync = promisify(fs.unlink);

// Import the custom error classes
const { 
  ExternalServiceError, 
  ValidationError 
} = require('../utils/errors');

/**
 * Service for interacting with AWS S3
 */
class S3Service {
  constructor() {
    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });
    this.bucket = process.env.S3_BUCKET_NAME;
  }

  /**
   * Upload a file to S3
   * @param {Object} options - Upload options
   * @param {string} options.filePath - Path to file
   * @param {string} options.key - S3 key (path)
   * @param {string} options.contentType - MIME type
   * @returns {Promise<Object>} - S3 upload result
   */
  async uploadFile({ filePath, key, contentType }) {
    try {
      if (!filePath) {
        throw new ValidationError('File path is required');
      }

      if (!key) {
        throw new ValidationError('S3 key is required');
      }

      // Read the file
      const fileContent = await readFileAsync(filePath);

      // Upload parameters
      const params = {
        Bucket: this.bucket,
        Key: key,
        Body: fileContent,
        ContentType: contentType || 'application/octet-stream',
        ContentDisposition: 'inline'
      };

      // Upload to S3
      const upload = await this.s3.upload(params).promise();
      
      // Delete the local file after successful upload
      try {
        await unlinkAsync(filePath);
      } catch (deleteError) {
        console.error('Error deleting temporary file:', deleteError);
        // Continue even if delete fails
      }

      return {
        key: upload.Key,
        url: upload.Location,
        bucket: upload.Bucket
      };
    } catch (error) {
      console.error('Error uploading file to S3:', error);
      
      if (error instanceof ValidationError) {
        throw error;
      }
      
      throw new ExternalServiceError(
        `Failed to upload file to S3: ${error.message}`,
        's3'
      );
    }
  }

  /**
   * Upload a buffer to S3
   * @param {Object} options - Upload options
   * @param {Buffer} options.buffer - File buffer
   * @param {string} options.key - S3 key (path)
   * @param {string} options.contentType - MIME type
   * @returns {Promise<Object>} - S3 upload result
   */
  async uploadBuffer({ buffer, key, contentType }) {
    try {
      if (!buffer) {
        throw new ValidationError('Buffer is required');
      }

      if (!key) {
        throw new ValidationError('S3 key is required');
      }

      // Upload parameters
      const params = {
        Bucket: this.bucket,
        Key: key,
        Body: buffer,
        ContentType: contentType || 'application/octet-stream',
        ContentDisposition: 'inline'
      };

      // Upload to S3
      const upload = await this.s3.upload(params).promise();

      return {
        key: upload.Key,
        url: upload.Location,
        bucket: upload.Bucket
      };
    } catch (error) {
      console.error('Error uploading buffer to S3:', error);
      
      if (error instanceof ValidationError) {
        throw error;
      }
      
      throw new ExternalServiceError(
        `Failed to upload buffer to S3: ${error.message}`,
        's3'
      );
    }
  }

  /**
   * Get a file from S3
   * @param {Object} options - Options
   * @param {string} options.key - S3 key
   * @returns {Promise<Object>} - S3 object with data
   */
  async getFile({ key }) {
    try {
      if (!key) {
        throw new ValidationError('S3 key is required');
      }

      const params = {
        Bucket: this.bucket,
        Key: key
      };

      const data = await this.s3.getObject(params).promise();
      
      return {
        body: data.Body,
        contentType: data.ContentType,
        metadata: data.Metadata
      };
    } catch (error) {
      console.error('Error getting file from S3:', error);
      
      if (error.code === 'NoSuchKey') {
        throw new ValidationError(`File with key ${key} not found in S3`);
      }
      
      throw new ExternalServiceError(
        `Failed to get file from S3: ${error.message}`,
        's3'
      );
    }
  }

  /**
   * Delete a file from S3
   * @param {Object} options - Options
   * @param {string} options.key - S3 key
   * @returns {Promise<boolean>} - Success status
   */
  async deleteFile({ key }) {
    try {
      if (!key) {
        throw new ValidationError('S3 key is required');
      }

      const params = {
        Bucket: this.bucket,
        Key: key
      };

      await this.s3.deleteObject(params).promise();
      return true;
    } catch (error) {
      console.error('Error deleting file from S3:', error);
      throw new ExternalServiceError(
        `Failed to delete file from S3: ${error.message}`,
        's3'
      );
    }
  }

  /**
   * Generate a presigned URL for an object
   * @param {Object} options - Options
   * @param {string} options.key - S3 key
   * @param {number} options.expiresIn - Expiration in seconds
   * @returns {Promise<string>} - Presigned URL
   */
  async getSignedUrl({ key, expiresIn = 3600 }) {
    try {
      if (!key) {
        throw new ValidationError('S3 key is required');
      }

      const params = {
        Bucket: this.bucket,
        Key: key,
        Expires: expiresIn
      };

      const url = await this.s3.getSignedUrlPromise('getObject', params);
      return url;
    } catch (error) {
      console.error('Error generating presigned URL:', error);
      throw new ExternalServiceError(
        `Failed to generate presigned URL: ${error.message}`,
        's3'
      );
    }
  }

  /**
   * Generate a unique key for S3 with a provided prefix
   * @param {Object} options - Options
   * @param {string} options.prefix - Key prefix
   * @param {string} options.extension - File extension
   * @returns {string} - Unique S3 key
   */
  generateUniqueKey({ prefix = '', extension = '' }) {
    const uuid = uuidv4();
    const ext = extension.startsWith('.') ? extension : `.${extension}`;
    
    if (prefix) {
      // Ensure prefix ends with a slash
      const formattedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;
      return `${formattedPrefix}${uuid}${ext}`;
    }
    
    return `${uuid}${ext}`;
  }

  /**
   * Check if a file exists in S3
   * @param {Object} options - Options
   * @param {string} options.key - S3 key
   * @returns {Promise<boolean>} - Whether the file exists
   */
  async fileExists({ key }) {
    try {
      if (!key) {
        throw new ValidationError('S3 key is required');
      }

      const params = {
        Bucket: this.bucket,
        Key: key
      };

      await this.s3.headObject(params).promise();
      return true;
    } catch (error) {
      if (error.code === 'NotFound' || error.code === 'NoSuchKey') {
        return false;
      }
      
      console.error('Error checking if file exists in S3:', error);
      throw new ExternalServiceError(
        `Failed to check if file exists in S3: ${error.message}`,
        's3'
      );
    }
  }
}

module.exports = new S3Service(); 

---
File: backend/services/AuthService.js
---
const User = require('../models/User');
const PlanService = require('./planService');

class AuthService {
  /**
   * Create or update user from GitHub profile
   * @param {Object} profile - GitHub profile
   * @param {string} accessToken - GitHub access token
   * @returns {Promise<Object>} User object
   */
  static async handleGitHubAuth(profile, accessToken) {
    try {
      let user = await User.findOne({ githubId: profile.id });
      
      if (user) {
        // Update existing user
        user.accessToken = accessToken;
        user.name = profile.displayName || profile.username;
        user.avatarUrl = profile._json.avatarUrl;
        if (profile.emails && profile.emails.length > 0) {
          user.email = profile.emails[0].value;
        }

        // Ensure user has a plan
        if (!user.plan) {
          const defaultPlan = await PlanService.getDefaultPlan();
          user.plan = defaultPlan._id;
        }

        await user.save();
      } else {
        // Get default plan for new user
        const defaultPlan = await PlanService.getDefaultPlan();
        console.log('Default plan:', defaultPlan);
        
        // Create new user
        user = await User.create({
          githubId: profile.id,
          username: profile.username,
          name: profile.displayName || profile.username,
          email: profile.emails?.[0]?.value,
          avatarUrl: profile._json.avatarUrl,
          accessToken,
          plan: defaultPlan._id
        });
      }

      return user;
    } catch (error) {
      console.error('Error in handleGitHubAuth:', error);
      throw error;
    }
  }

  /**
   * Get user by ID with plan details
   * @param {string} userId - User ID
   * @returns {Promise<Object>} User object with plan
   */
  static async getUserById(userId) {
    try {
      const user = await User.findById(userId).populate('plan');
      if (!user) {
        throw new Error('User not found');
      }
      return user;
    } catch (error) {
      console.error('Error getting user:', error);
      throw error;
    }
  }
}

module.exports = AuthService; 

---
File: backend/services/QueueService.js
---
/**
 * Queue Service
 * 
 * Handles background job processing using Bull queue
 */
const Bull = require('bull');
const { _generatePDF } = require('./pdf');
const s3Service = require('./s3');
const Report = require('../models/Report');

// Create Redis connection configuration
const redisConfig = {
  redis: {
    port: process.env.REDIS_PORT || 6379,
    host: process.env.REDIS_HOST || 'localhost',
    password: process.env.REDIS_PASSWORD
  }
};

// Create Bull queues
const pdfQueue = new Bull('pdf-generation', redisConfig);

// Process PDF generation jobs
pdfQueue.process(async (job) => {
  try {
    console.log(`Processing PDF generation job ${job.id}`);
    const { options, reportId } = job.data;
    
    // Update job progress
    await job.progress(10);
    
    // Generate PDF
    const pdfBuffer = await _generatePDF(options);
    
    await job.progress(50);
    
    // Upload PDF to S3
    const pdfUrl = await s3Service.uploadFile({
      fileName: `report-${reportId}.pdf`,
      fileContent: pdfBuffer,
      contentType: 'application/pdf'
    }).then(res => res.key);
    
    await job.progress(80);
    
    // Update report with PDF URL
    await Report.findByIdAndUpdate(reportId, { pdfUrl });
    
    await job.progress(100);
    
    // Return the PDF URL
    return { pdfUrl };
  } catch (error) {
    console.error('Error processing PDF generation job:', error);
    throw error;
  }
});

// Handle completed jobs
pdfQueue.on('completed', (job, result) => {
  console.log(`Job ${job.id} completed with result:`, result);
});

// Handle failed jobs
pdfQueue.on('failed', (job, error) => {
  console.error(`Job ${job.id} failed with error:`, error);
  
  // Update the report to indicate failure
  const { reportId } = job.data;
  if (reportId) {
    Report.findByIdAndUpdate(reportId, { 
      pdfUrl: 'failed',
      pdfError: error.message || 'PDF generation failed'
    }).catch(err => {
      console.error(`Failed to update report ${reportId} status:`, err);
    });
  }
});

// Queue service
const queueService = {
  /**
   * Add a PDF generation job to the queue
   * 
   * @param {Object} options - PDF generation options
   * @param {string} reportId - The report ID to update when complete
   * @returns {Promise<Object>} - Job information with id
   */
  async addPdfGenerationJob(options, reportId) {
    const job = await pdfQueue.add({
      options,
      reportId
    }, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 5000
      },
      removeOnComplete: 100, // Keep last 100 completed jobs
      removeOnFail: 100      // Keep last 100 failed jobs
    });
    
    return {
      id: job.id,
      status: 'pending'
    };
  },
  
  /**
   * Get the status of a PDF generation job
   * 
   * @param {string} jobId - The job ID
   * @returns {Promise<Object>} - Job status information
   */
  async getPdfJobStatus(jobId) {
    const job = await pdfQueue.getJob(jobId);
    
    if (!job) {
      return { status: 'not-found' };
    }
    
    const state = await job.getState();
    const progress = job._progress || 0;
    
    return {
      id: job.id,
      status: state,
      progress,
      data: job.data,
      createdAt: job.timestamp
    };
  },
  
  /**
   * Clean up old jobs
   */
  async cleanupJobs() {
    await pdfQueue.clean(24 * 60 * 60 * 1000, 'completed'); // Clean completed jobs older than 1 day
    await pdfQueue.clean(7 * 24 * 60 * 60 * 1000, 'failed'); // Clean failed jobs older than 7 days
  }
};

module.exports = queueService; 

---
File: backend/services/OpenAIService.js
---
const { OpenAI } = require('openai');
const path = require('path');
const fs = require('fs').promises;
const CommitSummary = require('../models/CommitSummary');
const { getReportPrompt } = require('../templates/reportPrompt');
const { getCommitSummaryPrompt } = require('../templates/commitSummaryPrompt');

// Initialize OpenAI client
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

/**
 * Get or create a commit summary
 * @param {Object} commit - Commit data
 * @param {string} repository - Repository name
 * @param {boolean} trackTokens - Whether to track token usage
 * @returns {Promise<Object>} - The commit summary with usage statistics if trackTokens is enabled
 */
const getOrCreateCommitSummary = async (commit, repository, trackTokens = true) => {
  try {
    // Check if this commit summary already exists in the database
    const existingSummary = await CommitSummary.findOne({
      repository,
      commitId: commit.sha
    });

    // If the summary exists, update the lastAccessed timestamp and return it
    if (existingSummary) {
      console.log(`Using cached summary for commit ${commit.sha.substring(0, 7)}`);
      
      // Update the lastAccessed timestamp
      existingSummary.lastAccessed = new Date();
      await existingSummary.save();
      
      return {
        sha: existingSummary.commitId,
        message: existingSummary.message,
        author: existingSummary.author,
        date: existingSummary.date,
        summary: existingSummary.summary,
        filesChanged: existingSummary.filesChanged || 0,
        fromCache: true
      };
    }

    // Summary doesn't exist, so we need to generate it
    console.log(`Generating new summary for commit ${commit.sha.substring(0, 7)}`);
    
    // Get a simple summary from the commit message as a fallback
    const fallbackSummary = commit.message ? 
      commit.message.split('\n')[0].substring(0, 100) : 
      'No summary available';
    
    let summary = fallbackSummary;
    let usage = null;
    let model = null;
    
    try {
      // Use the new template for the OpenAI analysis
      const prompt = getCommitSummaryPrompt({
        repository,
        commitSha: commit.sha,
        authorName: commit.author?.name || commit.author?.login || 'Unknown',
        message: commit.message,
        diff: commit.diff
      });

      // Call the OpenAI API
      const response = await openai.chat.completions.create({
        model: process.env.OPENAI_MODEL || 'gpt-4o',
        messages: [
          { role: 'system', content: 'You are a technical expert analyzing code changes. Provide clear, accurate, and concise summaries of what work was accomplished in a commit.' },
          { role: 'user', content: prompt }
        ],
        maxTokens: 300
      });

      // Extract the summary from the response
      summary = response.choices[0].message.content.trim();
      
      // Track token usage if requested
      if (trackTokens && response.usage) {
        usage = {
          promptTokens: response.usage.prompt_tokens,
          completionTokens: response.usage.completion_tokens,
          totalTokens: response.usage.total_tokens
        };
        model = response.model || process.env.OPENAI_MODEL || 'gpt-4o';
      }
      
      if (!summary || summary.length === 0) {
        console.log(`No summary generated for commit ${commit.sha.substring(0, 7)}, using fallback`);
        summary = fallbackSummary;
      }
    } catch (error) {
      console.error(`Error generating summary for commit ${commit.sha.substring(0, 7)}:`, error);
      // Use the fallback summary if OpenAI fails
      console.log(`Using fallback summary for commit ${commit.sha.substring(0, 7)}`);
    }

    // Save the summary to the database
    const newSummary = new CommitSummary({
      commitId: commit.sha,
      repository,
      message: commit.message || 'No message',
      author: commit.author?.name || commit.author?.login || 'Unknown',
      date: commit.date || new Date(),
      summary,
      filesChanged: commit.filesChanged || 0,
      lastAccessed: new Date(),
      createdAt: new Date()
    });

    await newSummary.save();
    console.log(`Saved new summary for commit ${commit.sha.substring(0, 7)}`);

    // Return the analyzed commit data with usage info if available
    const result = {
      sha: commit.sha,
      message: commit.message || 'No message',
      author: commit.author?.name || commit.author?.login || 'Unknown',
      date: commit.date || new Date(),
      summary,
      filesChanged: commit.filesChanged || 0,
      fromCache: false
    };
    
    // Add token usage if tracked
    if (trackTokens && usage) {
      result.usage = usage;
      result.model = model;
    }
    
    return result;
  } catch (error) {
    console.error(`Error in commit summary cache for ${commit.sha}:`, error);
    // If caching fails, still return the commit with a default summary
    return {
      sha: commit.sha,
      message: commit.message || 'No message',
      author: commit.author?.name || commit.author?.login || 'Unknown',
      date: commit.date || new Date(),
      summary: commit.message ? commit.message.split('\n')[0].substring(0, 100) : 'No summary available',
      filesChanged: commit.filesChanged || 0,
      fromCache: false
    };
  }
};

/**
 * Service for interacting with the OpenAI API
 */
const openaiService = {
  /**
   * Analyze a commit using OpenAI
   */
  async analyzeCommit({ commitMessage, diff, repository, commitSha, authorName }) {
    try {
      // Truncate the diff if it's too large
      const maxDiffLength = 15000;
      const truncatedDiff = diff.length > maxDiffLength 
        ? diff.substring(0, maxDiffLength) + '... [diff truncated due to size]'
        : diff;
      
      // Use the template for OpenAI
      const prompt = getCommitSummaryPrompt({
        repository: repository || 'unknown',
        commitSha: commitSha || 'unknown',
        authorName: authorName || 'Unknown',
        message: commitMessage,
        diff: truncatedDiff
      });

      // Call the OpenAI API
      const response = await openai.chat.completions.create({
        model: process.env.OPENAI_MODEL || 'gpt-4o',
        messages: [
          { role: 'system', content: 'You are a technical expert analyzing code changes. Provide clear, accurate, and concise summaries of what work was accomplished in a commit.' },
          { role: 'user', content: prompt }
        ],
        maxTokens: 150,
        temperature: 0.7
      });

      // Return the generated summary
      return response.choices[0].message.content.trim();
    } catch (error) {
      console.error('Error analyzing commit with OpenAI:', error);
      return 'Could not analyze this commit due to an error.';
    }
  },
  
  /**
   * Analyze a list of commits using OpenAI
   * @param {Object} options - Analysis options
   * @returns {Promise<Array>} - Analyzed commits
   */
  analyzeCommits: async (options) => {
    const { repository, commits, trackTokens = false } = options;
    
    try {
      // Process commits in parallel with a concurrency limit of 3
      const analyzedCommits = [];
      const concurrencyLimit = 3;
      
      // Process commits in batches
      for (let i = 0; i < commits.length; i += concurrencyLimit) {
        const batch = commits.slice(i, i + concurrencyLimit);
        const batchResults = await Promise.all(
          batch.map(commit => getOrCreateCommitSummary(commit, repository, trackTokens))
        );
        analyzedCommits.push(...batchResults);
      }
      
      return analyzedCommits;
    } catch (error) {
      console.error('Error analyzing commits:', error);
      // If OpenAI analysis fails, return the original commits
      return commits.map(commit => ({
        sha: commit.sha,
        message: commit.message,
        author: commit.author?.name || commit.author?.login || 'Unknown',
        date: commit.date || new Date(),
        summary: 'OpenAI analysis failed.',
        filesChanged: commit.filesChanged || 0,
        fromCache: false
      }));
    }
  },
  
  /**
   * Generate a comprehensive report from a list of commits
   * @param {Object} options - Report generation options
   * @param {string} options.repository - Repository name
   * @param {Array} options.commits - List of commits
   * @param {string} options.title - Report title
   * @param {boolean} options.includeCode - Whether to include code snippets
   * @param {string} options.branchInfo - Branch information
   * @param {string} options.authorInfo - Author information
   * @param {boolean} options.trackTokens - Whether to track token usage
   * @returns {Promise<Object>} - Generated report with usage statistics if trackTokens is enabled
   */
  async generateReportFromCommits({ repository, commits, title, includeCode, branchInfo, authorInfo, trackTokens = true }) {
    try {
      console.log(`Generating report for ${repository} with ${commits.length} commits`);

      // First, ensure all commits have summaries using our caching system
      const analyzedCommits = await this.analyzeCommits({
        repository,
        commits,
        trackTokens
      });

      // Format the commits for the prompt
      const commitsText = analyzedCommits.map((commit, index) => {
        return `
Commit ${index + 1}:
- SHA: ${commit.sha}
- Author: ${commit.author}
- Message: ${commit.message}
- Summary: ${commit.summary}
- Date: ${new Date(commit.date).toISOString().split('T')[0]}
${includeCode && commit.diff ? `\nChanges:\n${commit.diff.substring(0, 500)}${commit.diff.length > 500 ? '...(truncated)' : ''}` : ''}
`;
      }).join('\n');

      // Extract date range information
      const startDate = new Date(Math.min(...analyzedCommits.map(c => new Date(c.date).getTime())));
      const endDate = new Date(Math.max(...analyzedCommits.map(c => new Date(c.date).getTime())));

      const dateRangeFormatted = `${startDate.toISOString().split('T')[0]} to ${endDate.toISOString().split('T')[0]}`;

      // Construct the prompt for the report generation
      const prompt = getReportPrompt({
        repository,
        title,
        dateRangeFormatted,
        includeCode,
        commitsText,
        branchInfo,
        authorInfo
      });

      console.log('Sending report generation request to OpenAI');
      
      // Call the OpenAI API for report generation
      const response = await openai.chat.completions.create({
        model: process.env.OPENAI_MODEL || 'gpt-4o-mini',
        messages: [
          { 
            role: 'system', 
            content: 'You are a technical writer and expert at creating executive summary reports that translate technical development work into business value. Your reports are concise, well-structured, and focus on outcomes rather than implementation details.'
          },
          { role: 'user', content: prompt }
        ],
        maxTokens: 2500,
        temperature: 0.7
      });

      // Create the result object
      const result = {
        title,
        content: response.choices[0].message.content.trim(),
        repository,
        commitCount: commits.length,
        dateGenerated: new Date()
      };
      
      // Add token usage information if requested
      if (trackTokens && response.usage) {
        result.usage = {
          promptTokens: response.usage.prompt_tokens,
          completionTokens: response.usage.completion_tokens,
          totalTokens: response.usage.total_tokens
        };
        result.model = response.model || process.env.OPENAI_MODEL || 'gpt-4o-mini';
      }
      
      console.log('OpenAI report generated:', {
        resultType: typeof result,
        hasContent: !!result.content,
        contentType: typeof result.content,
        contentLength: result.content.length,
        contentSample: result.content.substring(0, 200) + '...',
        trackingTokens: trackTokens,
        tokenUsage: trackTokens ? result.usage : 'Not tracked'
      });
      
      return result;
    } catch (error) {
      console.error('Error generating report with OpenAI:', error);
      throw new Error('Failed to generate report: ' + error.message);
    }
  }
};

module.exports = openaiService;

---
File: backend/services/ReportService.js
---
const Report = require('../models/Report');
const s3Service = require('./s3');
const crypto = require('crypto');
const { NotFoundError } = require('../utils/errors');

/**
 * Generate a hash from an array of commit IDs
 * This will be used to identify unique sets of commits
 * 
 * @param {Array} commits - Array of commit objects
 * @returns {string} - SHA-256 hash of sorted commit IDs
 */
const generateCommitsHash = (commits) => {
  // Sort commit IDs to ensure consistent hash regardless of order
  const commitIds = commits
    .map(commit => commit.commitId || commit.sha)
    .sort();
  
  // Generate a SHA-256 hash of the sorted commit IDs
  const hash = crypto.createHash('sha256');
  hash.update(commitIds.join(','));
  return hash.digest('hex');
};

/**
 * Find an existing report with the same commits
 * 
 * @param {string} commitsHash - Hash of commits
 * @returns {Promise<Object|null>} - Existing report or null
 */
const findReportByCommitsHash = async (commitsHash) => {
  try {
    const existingReport = await Report.findOne({ commitsHash });
    return existingReport;
  } catch (error) {
    console.error('Error finding report by hash:', error);
    return null;
  }
};

/**
 * Update access stats for a report
 * 
 * @param {Object} report - Report document
 * @returns {Promise<void>}
 */
const updateReportAccessStats = async (report) => {
  try {
    report.accessCount += 1;
    report.lastAccessed = new Date();
    await report.save();
    console.log(`Updated access stats for report ${report.id}, count: ${report.accessCount}`);
  } catch (error) {
    console.error('Error updating report access stats:', error);
    throw error;
  }
};

/**
 * Get report by ID with validated user
 * 
 * @param {string} reportId - Report ID
 * @param {string} userId - User ID
 * @returns {Promise<Object>} - Report document
 * @throws {NotFoundError} - If report not found
 */
const getReportById = async (reportId, userId) => {
  const report = await Report.findOne({
    _id: reportId,
    user: userId
  });
  
  if (!report) {
    throw new NotFoundError('Report not found');
  }
  
  return report;
};

/**
 * Generate download and view URLs for a report
 * 
 * @param {Object} report - Report document
 * @returns {Promise<Object>} - Object with viewUrl and downloadUrl
 */
const generateReportUrls = async (report) => {
  if (!report.pdfUrl || report.pdfUrl === 'pending' || report.pdfUrl === 'failed') {
    return { viewUrl: null, downloadUrl: null };
  }

  const [viewUrl, downloadUrl] = await Promise.all([
    s3Service.getSignedUrl(report.pdfUrl),
    s3Service.getDownloadUrl(
      report.pdfUrl,
      `${report.name.replace(/[^a-z0-9-]/gi, '-').toLowerCase()}.pdf`
    )
  ]);
  
  return { viewUrl, downloadUrl };
};

/**
 * Format report for client response
 * 
 * @param {Object} report - Report document
 * @param {Object} urls - Object with viewUrl and downloadUrl
 * @returns {Object} - Formatted report
 */
const formatReportResponse = (report, urls = {}) => {
  return {
    id: report.id,
    title: report.name,
    repository: report.repository,
    branch: report.branch,
    author: report.author,
    startDate: report.startDate,
    endDate: report.endDate,
    pdfUrl: report.pdfUrl,
    downloadUrl: urls.downloadUrl || '',
    viewUrl: urls.viewUrl || '',
    createdAt: report.createdAt,
    accessCount: report.accessCount || 1,
    lastAccessed: report.lastAccessed || report.createdAt,
    commits: report.commits || []
  };
};

module.exports = {
  generateCommitsHash,
  findReportByCommitsHash,
  updateReportAccessStats,
  getReportById,
  generateReportUrls,
  formatReportResponse
}; 

---
File: backend/services/UsageStatsService.js
---
const User = require('../models/User');
const UsageStats = require('../models/UsageStats');
const mongoose = require('mongoose');

/**
 * Service for handling usage statistics tracking
 */
class UsageStatsService {
  /**
   * Get the current month in YYYY-MM format
   * @returns {string} Current month in YYYY-MM format
   */
  static getCurrentMonth() {
    const now = new Date();
    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
  }

  /**
   * Track report generation
   * @param {string} userId - User ID
   * @param {string} reportType - Type of report ('small' or 'big')
   */
  static async trackReportGeneration(userId, reportType) {
    try {
      console.log('Tracking report generation:', {
        userId,
        reportType,
        timestamp: new Date().toISOString()
      });

      const currentMonth = this.getCurrentMonth();

      // Update monthly stats
      const updateResult = await UsageStats.findOneAndUpdate(
        { user: userId, month: currentMonth },
        {
          $inc: {
            [`reports.${reportType}`]: 1
          }
        },
        { upsert: true, new: true }
      );

      console.log('Usage stats update result:', {
        userId,
        reportType,
        currentMonth,
        updateResult
      });
    } catch (error) {
      console.error('Error tracking report generation:', error);
    }
  }

  /**
   * Track commit analysis events
   * @param {string} userId - The user ID
   * @param {number} commitCount - Number of commits analyzed
   * @param {number} summarizedCount - Number of commits summarized
   * @returns {Promise<void>}
   */
  static async trackCommitAnalysis(userId, commitCount, summarizedCount = 0) {
    try {
      const currentMonth = this.getCurrentMonth();

      // Update monthly stats only
      await UsageStats.findOneAndUpdate(
        { user: userId, month: currentMonth },
        {
          $inc: {
            'commits.total': commitCount  // Use actual commit count
          }
        },
        { upsert: true, new: true }
      );
    } catch (error) {
      console.error('Error tracking commit analysis:', error);
    }
  }

  /**
   * Track token usage for AI services
   * @param {string} userId - The user ID
   * @param {number} inputTokens - Number of input tokens used
   * @param {number} outputTokens - Number of output tokens used
   * @param {string} model - Model name used
   * @param {number} totalCost - Total cost of the operation
   * @param {number} inputCost - Cost of input tokens
   * @param {number} outputCost - Cost of output tokens
   * @returns {Promise<void>}
   */
  static async trackTokenUsage(userId, inputTokens, outputTokens, model, totalCost, inputCost, outputCost) {
    try {
      const currentMonth = this.getCurrentMonth();
      const totalTokens = inputTokens + outputTokens;

      // Update monthly stats only
      const updateQuery = {
        $inc: {
          'tokenUsage.total': totalTokens,
          'tokenUsage.input': inputTokens,
          'tokenUsage.output': outputTokens,
          'costEstimate.total': totalCost,
          'costEstimate.input': inputCost,
          'costEstimate.output': outputCost
        }
      };

      // Add model-specific token usage
      updateQuery.$inc[`tokenUsage.byModel.${model}`] = totalTokens;
      updateQuery.$inc[`tokenUsage.inputByModel.${model}`] = inputTokens;
      updateQuery.$inc[`tokenUsage.outputByModel.${model}`] = outputTokens;

      await UsageStats.findOneAndUpdate(
        { user: userId, month: currentMonth },
        updateQuery,
        { upsert: true, new: true }
      );
    } catch (error) {
      console.error('Error tracking token usage:', error);
    }
  }

  /**
   * Check if user has reached their monthly report limit
   * @param {string} userId - The user ID
   * @returns {Promise<boolean>} True if limit reached
   */
  static async hasReachedReportLimit(userId) {
    try {
      const user = await User.findById(userId).populate('plan');
      if (!user) throw new Error('User not found');
      if (!user.plan) throw new Error('User plan not found');

      // Get current month's stats
      const currentMonth = this.getCurrentMonth();
      const currentMonthStats = await UsageStats.findOne({
        user: userId,
        month: currentMonth
      });

      // If no stats for this month, user hasn't reached limit
      if (!currentMonthStats) return false;

      // Check standard and large report limits separately
      const standardReports = currentMonthStats.reports.standard || 0;
      const largeReports = currentMonthStats.reports.large || 0;
      
      // Large reports are limited to 10% of standard report limit
      const largeReportLimit = Math.floor(user.plan.limits.reportsPerMonth * 0.1);
      
      return standardReports >= user.plan.limits.reportsPerMonth ||
             largeReports >= largeReportLimit;
    } catch (error) {
      console.error('Error checking report limit:', error);
      // Default to false to prevent blocking users due to errors
      return false;
    }
  }

  /**
   * Get user's current usage statistics
   * @param {string} userId - The user ID
   * @returns {Promise<Object>} User usage data
   */
  static async getUserUsageStats(userId) {
    try {
      // Get user's plan
      const user = await User.findById(userId).populate('plan');
      if (!user) {
        throw new Error('User not found');
      }

      // Get current month's stats
      const currentMonth = this.getCurrentMonth();
      const currentMonthStats = await UsageStats.findOne({
        user: userId,
        month: currentMonth
      });

      // Get all-time stats using aggregation
      const allTimeStats = await UsageStats.aggregate([
        { $match: { user: new mongoose.Types.ObjectId(userId) } },
        {
          $group: {
            _id: null,
            reports: { 
              $sum: {
                $add: [
                  { $ifNull: ['$reports.standard', 0] },
                  { $ifNull: ['$reports.large', 0] }
                ]
              }
            },
            commits: { 
              $sum: { $ifNull: ['$commits.total', 0] }
            },
            tokenUsage: { $sum: '$tokenUsage.total' }
          }
        }
      ]);

      return {
        plan: user.plan,
        currentMonthStats: currentMonthStats || {
          reports: { 
            standard: 0,
            large: 0
          },
          commits: { 
            total: 0
          },
          tokenUsage: { 
            total: 0,
            input: 0,
            output: 0
          }
        },
        allTimeStats: allTimeStats[0] || {
          reports: 0,
          commits: 0,
          tokenUsage: 0
        }
      };
    } catch (error) {
      console.error('Error in getUserUsageStats:', error);
      throw error;
    }
  }

  /**
   * Get admin analytics overview
   * @returns {Promise<Object>} System-wide usage statistics
   */
  static async getAdminAnalytics() {
    try {
      const currentMonth = this.getCurrentMonth();
      
      // Get aggregated stats for current month
      let monthlyStats = await UsageStats.aggregate([
        { $match: { month: currentMonth } },
        { 
          $group: {
            _id: null,
            reportsStandard: { $sum: { $ifNull: ['$reports.standard', 0] } },
            reportsLarge: { $sum: { $ifNull: ['$reports.large', 0] } },
            commitsTotal: { $sum: { $ifNull: ['$commits.total', 0] } },
            totalTokens: { $sum: { $ifNull: ['$tokenUsage.total', 0] } },
            inputTokens: { $sum: { $ifNull: ['$tokenUsage.input', 0] } },
            outputTokens: { $sum: { $ifNull: ['$tokenUsage.output', 0] } },
            totalCost: { $sum: { $ifNull: ['$costEstimate.total', 0] } },
            inputCost: { $sum: { $ifNull: ['$costEstimate.input', 0] } },
            outputCost: { $sum: { $ifNull: ['$costEstimate.output', 0] } },
            uniqueUsers: { $addToSet: '$user' }
          }
        }
      ]);

      monthlyStats = monthlyStats[0] || {
        reportsStandard: 0,
        reportsLarge: 0,
        commitsTotal: 0,
        totalTokens: 0,
        inputTokens: 0,
        outputTokens: 0,
        totalCost: 0,
        inputCost: 0,
        outputCost: 0,
        uniqueUsers: []
      };

      monthlyStats.totalReports = monthlyStats.reportsStandard + monthlyStats.reportsLarge;

      // Get user breakdown
      let userBreakdown = await UsageStats.aggregate([
        { $match: { month: currentMonth } },
        {
          $project: {
            user: 1,
            reportsStandard: { $ifNull: ['$reports.standard', 0] },
            reportsLarge: { $ifNull: ['$reports.large', 0] },
            commitsTotal: { $ifNull: ['$commits.total', 0] },
            tokensTotal: { $ifNull: ['$tokenUsage.total', 0] },
            inputTokens: { $ifNull: ['$tokenUsage.input', 0] },
            outputTokens: { $ifNull: ['$tokenUsage.output', 0] },
            costTotal: { $ifNull: ['$costEstimate.total', 0] },
            inputCost: { $ifNull: ['$costEstimate.input', 0] },
            outputCost: { $ifNull: ['$costEstimate.output', 0] }
          }
        },
        { $sort: { reportsStandard: -1 } },
        { $limit: 10 }
      ]);

      // Map user IDs to usernames
      const userIds = userBreakdown.map(item => item.user);
      const users = await User.find({ _id: { $in: userIds } }, { username: 1 });
      const userMap = users.reduce((map, user) => {
        map[user._id.toString()] = user.username;
        return map;
      }, {});

      const userStats = userBreakdown.map(item => ({
        username: userMap[item.user.toString()] || 'Unknown',
        reports: item.reportsStandard + item.reportsLarge,
        commits: item.commitsTotal,
        tokens: {
          total: item.tokensTotal,
          input: item.inputTokens,
          output: item.outputTokens
        },
        cost: {
          total: item.costTotal,
          input: item.inputCost,
          output: item.outputCost
        }
      }));

      return {
        currentMonth,
        summary: monthlyStats,
        topUsers: userStats
      };
    } catch (error) {
      console.error('Error fetching admin analytics:', error);
      throw error;
    }
  }
}

module.exports = UsageStatsService;

---
File: backend/package.json
---
{
  "name": "gitstatus-backend",
  "version": "1.0.0",
  "description": "Backend for GitStatus - GitHub commit history analyzer",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon --config nodemon.json server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "github",
    "git",
    "commits",
    "analysis",
    "report"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@anthropic-ai/sdk": "^0.39.0",
    "@octokit/core": "^6.1.4",
    "aws-sdk": "^2.1195.0",
    "axios": "^1.3.4",
    "bull": "^4.16.5",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "csrf-csrf": "^3.1.0",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-rate-limit": "^7.5.0",
    "express-session": "^1.17.3",
    "express-validator": "^7.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.0",
    "marked": "^15.0.7",
    "mongoose": "^7.0.3",
    "openai": "^4.16.1",
    "passport": "^0.6.0",
    "passport-github2": "^0.1.12",
    "pdfkit": "^0.13.0",
    "puppeteer": "^24.4.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22",
    "open": "^10.1.0"
  }
}


---
File: backend/models/User.js
---
const mongoose = require('mongoose');

const UserSchema = new mongoose.Schema({
  githubId: {
    type: String,
    required: true,
    unique: true
  },
  name: {
    type: String,
    required: true
  },
  username: {
    type: String,
    required: true
  },
  email: {
    type: String
  },
  avatarUrl: {
    type: String
  },
  accessToken: {
    type: String,
    required: true
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },
  plan: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Plan',
    required: true
  }
});

// Method to check if user has exceeded their monthly limits
UserSchema.methods.hasExceededLimits = async function(type, amount = 1) {
  await this.populate('plan');
  
  // Get current month's stats
  const currentMonth = `${new Date().getFullYear()}-${String(new Date().getMonth() + 1).padStart(2, '0')}`;
  const currentMonthStats = await UsageStats.findOne({
    user: this._id,
    month: currentMonth
  });

  // If no stats for this month, user hasn't reached limit
  if (!currentMonthStats) return false;

  switch (type) {
    case 'reports':
      const totalReports = (currentMonthStats.reports.standard || 0) + 
                          (currentMonthStats.reports.large || 0);
      return (totalReports + amount) > this.plan.limits.reportsPerMonth;
    case 'commits':
      return (currentMonthStats.commits.total + amount) > this.plan.limits.commitsPerMonth;
    case 'tokens':
      return (currentMonthStats.tokenUsage.total + amount) > this.plan.limits.tokensPerMonth;
    default:
      throw new Error('Invalid limit type');
  }
};

// Method to increment usage
UserSchema.methods.incrementUsage = async function(type, amount = 1, reportType = 'standard') {
  if (await this.hasExceededLimits(type, amount)) {
    throw new Error(`Monthly ${type} limit exceeded`);
  }

  switch (type) {
    case 'reports':
      this.currentUsage.reportsGenerated[reportType] += amount;
      break;
    case 'commits':
      this.currentUsage.commitsAnalyzed += amount;
      break;
    case 'tokens':
      this.currentUsage.tokensUsed += amount;
      break;
    default:
      throw new Error('Invalid usage type');
  }

  return this.save();
};

module.exports = mongoose.model('User', UserSchema);


---
File: backend/models/CommitSummary.js
---
const mongoose = require('mongoose');

/**
 * CommitSummary model schema
 * Used to cache OpenAI-generated summaries for commits
 */
const commitSummarySchema = new mongoose.Schema({
  // Unique identifier for the commit
  commitId: {
    type: String,
    required: true,
    index: true
  },
  
  // Repository this commit belongs to
  repository: {
    type: String,
    required: true,
    index: true
  },
  
  // The commit message
  message: {
    type: String,
    required: true
  },
  
  // Author of the commit
  author: {
    type: String,
    required: true
  },
  
  // Date of the commit
  date: {
    type: Date,
    required: true
  },
  
  // OpenAI-generated summary
  summary: {
    type: String,
    required: true
  },
  
  // Files changed in this commit
  filesChanged: {
    type: Number,
    default: 0
  },
  
  // Tracking when this summary was last accessed
  lastAccessed: {
    type: Date,
    default: Date.now
  },
  
  // Tracking when this summary was created
  createdAt: {
    type: Date,
    default: Date.now
  }
});

// Create a compound index on repository and commitId for faster lookups
commitSummarySchema.index({ repository: 1, commitId: 1 }, { unique: true });

module.exports = mongoose.model('CommitSummary', commitSummarySchema);


---
File: backend/models/UsageStats.js
---
const mongoose = require('mongoose');

/**
 * UsageStats model schema
 * Used to track detailed analytics of system usage
 */
const UsageStatsSchema = new mongoose.Schema({
  // User reference
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
    index: true
  },
  
  // Month this record pertains to (YYYY-MM format)
  month: {
    type: String,
    required: true,
    index: true
  },
  
  // Report generation metrics
  reports: {
    standard: {
      type: Number,
      default: 0
    },
    large: {
      type: Number,
      default: 0
    }
  },
  
  // Commit analysis metrics
  commits: {
    total: {
      type: Number,
      default: 0
    }
  },
  
  // Token usage tracking for AI services
  tokenUsage: {
    // Total tokens (input + output)
    total: {
      type: Number,
      default: 0
    },
    // Input tokens (prompts)
    input: {
      type: Number,
      default: 0
    },
    // Output tokens (completions)
    output: {
      type: Number,
      default: 0
    },
    // Breakdown by model/service for total tokens
    byModel: {
      type: Map,
      of: Number,
      default: () => ({})
    },
    // Breakdown by model/service for input tokens
    inputByModel: {
      type: Map,
      of: Number,
      default: () => ({})
    },
    // Breakdown by model/service for output tokens
    outputByModel: {
      type: Map,
      of: Number,
      default: () => ({})
    }
  },
  
  // Estimated cost analysis (in USD)
  costEstimate: {
    total: {
      type: Number,
      default: 0
    },
    // Input token costs
    input: {
      type: Number,
      default: 0
    },
    // Output token costs 
    output: {
      type: Number,
      default: 0
    },
    // Breakdown by service type
    byService: {
      type: Map,
      of: Number,
      default: () => ({})
    },
    // Breakdown by service for input costs
    inputByService: {
      type: Map,
      of: Number,
      default: () => ({})
    },
    // Breakdown by service for output costs
    outputByService: {
      type: Map,
      of: Number,
      default: () => ({})
    }
  },
  
  // Creation and last update timestamps
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Create a compound index on user and month for faster lookups
UsageStatsSchema.index({ user: 1, month: 1 }, { unique: true });

// Set the updatedAt field before saving
UsageStatsSchema.pre('save', function(next) {
  this.updatedAt = Date.now();
  next();
});

module.exports = mongoose.model('UsageStats', UsageStatsSchema);

---
File: backend/models/Report.js
---
const mongoose = require('mongoose');

const ReportSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  name: {
    type: String,
    required: true
  },
  repository: {
    type: String,
    required: true
  },
  branch: {
    type: String,
    required: true
  },
  author: {
    type: String
  },
  startDate: {
    type: Date,
    required: true
  },
  endDate: {
    type: Date,
    required: true
  },
  commits: [{
    commitId: {
      type: String,
      required: true
    },
    message: {
      type: String,
      required: true
    },
    author: {
      type: String,
      required: true
    },
    date: {
      type: Date,
      required: true
    },
    summary: {
      type: String
    }
  }],
  pdfUrl: {
    type: String,
    default: 'pending'
  },
  pdfJobId: {
    type: String,
    default: null
  },
  pdfError: {
    type: String,
    default: null
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  // Hash to identify unique sets of commits
  commitsHash: {
    type: String,
    index: true
  },
  // Track how many times this report has been accessed
  accessCount: {
    type: Number,
    default: 1
  },
  // Track when this report was last accessed
  lastAccessed: {
    type: Date,
    default: Date.now
  }
});

// Add index on user field with createdAt for optimizing queries that filter by user and sort by date
ReportSchema.index({ user: 1, createdAt: -1 });

module.exports = mongoose.model('Report', ReportSchema);


---
File: backend/models/Plan.js
---
const mongoose = require('mongoose');

const planSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true,
    unique: true
  },
  displayName: {
    type: String,
    required: true
  },
  description: {
    type: String,
    required: true
  },
  limits: {
    reportsPerMonth: {
      type: Number,
      required: true,
      default: 50
    },
    commitsPerStandardReport: {
      type: Number,
      required: true,
      default: 5
    },
    commitsPerLargeReport: {
      type: Number,
      required: true,
      default: 20
    },
    tokensPerMonth: {
      type: Number
    },
    maxReportSize: {
      type: Number
    }
  },
  isDefault: {
    type: Boolean,
    default: false
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Update timestamps on save
planSchema.pre('save', function(next) {
  this.updatedAt = new Date();
  next();
});

module.exports = mongoose.model('Plan', planSchema); 

---
File: backend/templates/commitSummaryPrompt.js
---
/**
 * OpenAI prompt template for generating commit summaries
 * This ensures consistent formatting and prevents redundant text in summaries
 */

const getCommitSummaryPrompt = ({ repository, commitSha, authorName, message, diff }) => {
  return `
Analyze this commit and provide a concise technical summary of the changes made.

IMPORTANT INSTRUCTIONS:
1. Focus ONLY on describing what was changed and why
2. DO NOT start with phrases like "This commit" or mention the commit hash, repository, or author name
3. Write 2-3 concise, information-dense sentences
4. Focus on the technical purpose and impact of the changes
5. Be specific about what was implemented, fixed, or modified
6. If the commit message is clear and specific, incorporate its information

Repository: ${repository}
Commit: ${commitSha}
Author: ${authorName}
Message: ${message}

${diff ? `Changes:\n${diff}` : 'No diff available'}
`;
};

module.exports = { getCommitSummaryPrompt }; 

---
File: backend/templates/reportPrompt.js
---
/**
 * OpenAI prompt template for generating reports
 * This ensures consistent formatting across all generated reports
 */

const getReportPrompt = ({ repository, title, dateRangeFormatted, includeCode, commitsText, branchInfo, authorInfo }) => {
  return `
Generate a clean, focused report for the GitHub repository work. Follow this exact structure:

# ${title || repository + ' Report'}

Repository: ${repository}
${branchInfo ? `Branches: ${branchInfo}` : ''}
${authorInfo ? `Authors: ${authorInfo}` : ''}
Generated: ${new Date().toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' })}
Date Range: ${dateRangeFormatted}

## Executive Overview

{executiveSummary}

## Major Improvements and Features

{major_improvements_section}

## Implementation Details

{implementationDetails}

## Conclusion

{conclusion}

Generated by GitStatus

INSTRUCTIONS:
1. Replace all placeholders in {curlyBraces} with appropriate content
2. Fill in the executive summary, major improvements, implementation details, and conclusion sections based on the commits data
3. DO NOT add any additional title sections before or after this format
4. Keep the structure exactly as shown with these section headings
5. Ensure "Generated by GitStatus" appears at the end
6. IMPORTANT: DO NOT list individual commits or commit details. Instead, organize changes by themes/features 
7. Focus on WHAT was accomplished, not individual commits that accomplished it
8. Group related changes together by functionality or feature area
9. Use bullet points for clarity where appropriate

Commits:
${commitsText}

Focus on business value and accomplishments. Group related commits into logical sections. Be concise and clear.
Organize by themes and features rather than individual commits.
DO NOT modify the structure of the template.
`;
};

module.exports = { getReportPrompt };


---
File: backend/utils/errors.js
---
/**
 * GitStatus Error Classes
 * 
 * This file defines standardized error classes for consistent error handling across the application.
 * Each custom error type extends the base Error class with specific properties for different scenarios.
 */

/**
 * Base application error class that all other custom errors extend
 */
class ApplicationError extends Error {
  constructor(message, statusCode = 500, errorCode = 'INTERNAL_ERROR') {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    Error.captureStackTrace(this, this.constructor);
  }
}

/**
 * Error for when a resource is not found
 */
class NotFoundError extends ApplicationError {
  constructor(message = 'Resource not found') {
    super(message, 404, 'RESOURCE_NOT_FOUND');
  }
}

/**
 * Error for invalid or bad user input
 */
class ValidationError extends ApplicationError {
  constructor(message = 'Validation failed', errors = []) {
    super(message, 400, 'VALIDATION_ERROR');
    this.errors = errors;
  }
}

/**
 * Error for unauthorized access (not authenticated)
 */
class AuthenticationError extends ApplicationError {
  constructor(message = 'Authentication required') {
    super(message, 401, 'AUTHENTICATION_REQUIRED');
  }
}

/**
 * Error for forbidden access (authenticated but not authorized)
 */
class AuthorizationError extends ApplicationError {
  constructor(message = 'You do not have permission to perform this action') {
    super(message, 403, 'FORBIDDEN');
  }
}

/**
 * Error for external service failures (GitHub, OpenAI, etc.)
 */
class ExternalServiceError extends ApplicationError {
  constructor(message = 'External service error', service = 'unknown') {
    super(message, 502, 'EXTERNAL_SERVICE_ERROR');
    this.service = service;
  }
}

/**
 * Error for when a user exceeds rate limits or quotas
 */
class RateLimitError extends ApplicationError {
  constructor(message = 'Rate limit exceeded', limit = null, reset = null) {
    super(message, 429, 'RATE_LIMIT_EXCEEDED');
    this.limit = limit;
    this.reset = reset;
  }
}

/**
 * Error for database operations
 */
class DatabaseError extends ApplicationError {
  constructor(message = 'Database operation failed', operation = null) {
    super(message, 500, 'DATABASE_ERROR');
    this.operation = operation;
  }
}

/**
 * Error for PDF generation failures
 */
class PdfGenerationError extends ApplicationError {
  constructor(message = 'PDF generation failed', details = null) {
    super(message, 500, 'PDF_GENERATION_ERROR');
    this.details = details;
  }
}

/**
 * Error for when feature is not implemented
 */
class NotImplementedError extends ApplicationError {
  constructor(message = 'This feature is not implemented yet') {
    super(message, 501, 'NOT_IMPLEMENTED');
  }
}

/**
 * Function to determine if an error is an instance of ApplicationError
 * @param {Error} error - The error to check
 * @returns {boolean} - True if it's an ApplicationError or subclass
 */
const isApplicationError = (error) => {
  return error instanceof ApplicationError;
};

/**
 * Converts a generic Error to an ApplicationError
 * @param {Error} error - The error to convert
 * @param {string} defaultMessage - Default message if none is provided
 * @returns {ApplicationError} - A standardized application error
 */
const toApplicationError = (error, defaultMessage = 'An unexpected error occurred') => {
  if (isApplicationError(error)) {
    return error;
  }
  
  const message = error.message || defaultMessage;
  
  // Try to determine appropriate error type based on message content
  if (error.code === 'ENOTFOUND' || error.code === 'ECONNREFUSED') {
    return new ExternalServiceError(`Service connection error: ${message}`);
  }
  
  if (error.code === 'ETIMEDOUT' || error.code === 'ESOCKETTIMEDOUT') {
    return new ExternalServiceError(`Service timeout: ${message}`);
  }
  
  return new ApplicationError(message);
};

module.exports = {
  ApplicationError,
  NotFoundError,
  ValidationError,
  AuthenticationError,
  AuthorizationError,
  ExternalServiceError,
  RateLimitError,
  DatabaseError,
  PdfGenerationError,
  NotImplementedError,
  isApplicationError,
  toApplicationError
}; 

---
File: backend/controllers/UsageStatsController.js
---
const UsageStatsService = require('../services/UsageStatsService');
const User = require('../models/User');

/**
 * Controller for usage statistics
 */
class UsageStatsController {
  /**
   * Get the current user's usage statistics
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  static async getUserStats(req, res) {
    try {
      const userId = req.user.id;
      const user = await User.findById(userId).populate('plan');
      
      if (!user) {
        return res.status(404).json({
          success: false,
          message: 'User not found'
        });
      }

      const stats = await UsageStatsService.getUserUsageStats(userId);
      
      // Include plan information in response
      const response = {
        success: true,
        data: {
          ...stats,
          plan: {
            name: user.plan.name,
            displayName: user.plan.displayName,
            limits: user.plan.limits
          }
        }
      };

      res.status(200).json(response);
    } catch (error) {
      console.error('Error fetching user stats:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch usage statistics',
        error: error.message
      });
    }
  }

  /**
   * Get admin analytics dashboard data
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  static async getAdminStats(req, res) {
    try {
      // Check if user is admin
      const userId = req.user.id;
      const user = await User.findById(userId);
      
      if (!user || user.role !== 'admin') {
        return res.status(403).json({
          success: false,
          message: 'Access denied. Admin privileges required.'
        });
      }
      
      const stats = await UsageStatsService.getAdminAnalytics();
      
      res.status(200).json({
        success: true,
        data: stats
      });
    } catch (error) {
      console.error('Error fetching admin stats:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to fetch admin statistics',
        error: error.message
      });
    }
  }

  /**
   * Check if user has reached their report limit
   * @param {Object} req - Express request object
   * @param {Object} res - Express response object
   */
  static async checkReportLimit(req, res) {
    try {
      const userId = req.user.id;
      const hasReachedLimit = await UsageStatsService.hasReachedReportLimit(userId);
      
      res.status(200).json({
        success: true,
        hasReachedLimit,
        data: {
          canGenerateReport: !hasReachedLimit
        }
      });
    } catch (error) {
      console.error('Error checking report limit:', error);
      res.status(500).json({
        success: false,
        message: 'Failed to check usage limits',
        error: error.message
      });
    }
  }
}

module.exports = UsageStatsController;

---
File: backend/controllers/PlanController.js
---
const Plan = require('../models/Plan');
const PlanService = require('../services/PlanService');

const planController = {
  // Get all plans
  async getPlans(req, res) {
    try {
      const plans = await Plan.find();
      res.json({ plans });
    } catch (error) {
      console.error('Error fetching plans:', error);
      res.status(500).json({ error: 'Failed to fetch plans' });
    }
  },

  // Update plan limits
  async updatePlanLimits(req, res) {
    try {
      const { planId } = req.params;
      const { limits } = req.body;

      const updatedPlan = await PlanService.updatePlanLimits(planId, limits);
      res.json({ plan: updatedPlan });
    } catch (error) {
      console.error('Error updating plan limits:', error);
      res.status(500).json({ error: 'Failed to update plan limits' });
    }
  }
};

module.exports = planController; 

---
File: backend/controllers/AuthController.js
---
// Authentication controller

exports.githubCallback = (req, res) => {
  // Successful authentication, redirect to the frontend callback handler
  res.redirect(`${process.env.FRONTEND_URL || 'http://localhost:3000'}/auth/callback`);
};

exports.getCurrentUser = (req, res) => {
  if (req.isAuthenticated()) {
    return res.json({
      isAuthenticated: true,
      user: {
        id: req.user.id,
        name: req.user.name,
        username: req.user.username,
        email: req.user.email,
        avatarUrl: req.user.avatarUrl,
        role: req.user.role
      }
    });
  }
  
  res.json({ 
    isAuthenticated: false,
    user: null
  });
};

exports.logout = (req, res) => {
  req.logout(function(err) {
    if (err) { return next(err); }
    res.json({ message: 'Logged out successfully' });
  });
};


---
File: backend/controllers/AdminController.js
---
const User = require('../models/User');
const UsageStatsService = require('../services/UsageStatsService');

/**
 * Admin controller for user management and analytics
 */
class AdminController {
  /**
   * Get all users (admin only)
   */
  static async getUsers(req, res) {
    try {
      const users = await User.find({}, { accessToken: 0 }); // Exclude access token
      res.json({ users });
    } catch (error) {
      res.status(500).json({ message: 'Error fetching users', error: error.message });
    }
  }

  /**
   * Update user role (admin only)
   */
  static async updateUserRole(req, res) {
    try {
      const { role } = req.body;
      if (!['user', 'admin'].includes(role)) {
        return res.status(400).json({ message: 'Invalid role' });
      }

      const user = await User.findByIdAndUpdate(
        req.params.userId,
        { role },
        { new: true, select: '-accessToken' }
      );

      if (!user) {
        return res.status(404).json({ message: 'User not found' });
      }

      res.json({ user });
    } catch (error) {
      res.status(500).json({ message: 'Error updating user role', error: error.message });
    }
  }

  /**
   * Get admin analytics (admin only)
   */
  static async getAnalytics(req, res) {
    try {
      const analytics = await UsageStatsService.getAdminAnalytics();
      res.json({ analytics });
    } catch (error) {
      res.status(500).json({ message: 'Error fetching analytics', error: error.message });
    }
  }
}

module.exports = AdminController; 

---
File: backend/controllers/CommitSummaryController.js
---
const CommitSummary = require('../models/CommitSummary');

/**
 * Get all commit summaries, with optional filtering
 */
exports.getSummaries = async (req, res) => {
  try {
    const { repository, limit = 100, offset = 0 } = req.query;
    
    // Build the query
    const query = {};
    if (repository) {
      query.repository = repository;
    }
    
    // Get total count first (for pagination info)
    const totalCount = await CommitSummary.countDocuments(query);
    
    // Get the summaries
    const summaries = await CommitSummary.find(query)
      .sort({ lastAccessed: -1 })
      .skip(parseInt(offset))
      .limit(parseInt(limit));
    
    res.json({
      total: totalCount,
      offset: parseInt(offset),
      limit: parseInt(limit),
      summaries
    });
  } catch (error) {
    console.error('Error fetching commit summaries:', error);
    res.status(500).json({ error: 'Failed to fetch commit summaries' });
  }
};

/**
 * Get a commit summary by repository and commitId
 */
exports.getSummaryByCommitId = async (req, res) => {
  try {
    const { repository, commitId } = req.params;
    
    // Find the summary
    const summary = await CommitSummary.findOne({
      repository,
      commitId
    });
    
    if (!summary) {
      return res.status(404).json({ error: 'Commit summary not found' });
    }
    
    // Update last accessed timestamp
    summary.lastAccessed = new Date();
    await summary.save();
    
    res.json(summary);
  } catch (error) {
    console.error('Error fetching commit summary:', error);
    res.status(500).json({ error: 'Failed to fetch commit summary' });
  }
};

/**
 * Get commit details by commitIds
 */
exports.getCommitDetails = async (req, res) => {
  try {
    const { repository, commitIds } = req.body;
    
    if (!repository || !commitIds || !Array.isArray(commitIds) || commitIds.length === 0) {
      return res.status(400).json({ error: 'Repository and array of commitIds are required' });
    }
    
    console.log(`Fetching details for ${commitIds.length} commits in ${repository}`);
    
    // Find all summaries that match the repository and commitIds
    const summaries = await CommitSummary.find({
      repository,
      commitId: { $in: commitIds }
    });
    
    console.log(`Found ${summaries.length} matching commit summaries in database`);
    
    // Map the results to include only necessary fields
    const commitDetails = summaries.map(summary => {
      // Handle different author formats
      let author;
      
      console.log('Processing commit:', summary.commitId);
      console.log('Author data in DB:', JSON.stringify(summary.author));
      console.log('Author name in DB:', summary.authorName);
      
      if (summary.author) {
        if (typeof summary.author === 'object') {
          author = summary.author;
          console.log('Using author object:', JSON.stringify(author));
        } else if (typeof summary.author === 'string') {
          author = { name: summary.author };
          console.log('Converting author string to object:', JSON.stringify(author));
        }
      } else if (summary.authorName) {
        author = { name: summary.authorName, email: summary.authorEmail };
        console.log('Using authorName/Email fields:', JSON.stringify(author));
      } else {
        author = { name: 'Unknown' };
        console.log('No author information found, using Unknown');
      }
      
      return {
        id: summary.commitId,
        summary: summary.summary,
        author: author,
        date: summary.date || summary.timestamp,
        message: summary.message
      };
    });
    
    console.log('Commit details response:', commitDetails);
    
    res.json({
      commits: commitDetails
    });
  } catch (error) {
    console.error('Error fetching commit details:', error);
    res.status(500).json({ error: 'Failed to fetch commit details' });
  }
};




---
File: backend/controllers/GitHub/index.js
---
/**
 * Exports all GitHub-related controllers
 */

const GitHubRepositoryController = require('./GitHubRepositoryController');
const GitHubBranchController = require('./GitHubBranchController');
const GitHubCommitController = require('./GitHubCommitController');

module.exports = {
  GitHubRepositoryController,
  GitHubBranchController,
  GitHubCommitController
}; 

---
File: backend/controllers/GitHub/GitHubBranchController.js
---
const { GitHubBranchService } = require('../../services/GitHub');

/**
 * Controller for handling GitHub branch-related operations
 */
class GitHubBranchController {
  /**
   * Get branches for a repository
   */
  async getBranches(req, res) {
    try {
      const { repository } = req.query;

      if (!repository) {
        return res.status(400).json({ message: 'Repository is required' });
      }

      const accessToken = req.user.accessToken;
      const branches = await GitHubBranchService.getBranches({
        accessToken,
        repository
      });

      res.json(branches);
    } catch (error) {
      console.error('Error getting branches:', error);
      res.status(500).json({ message: 'Failed to get branches', error: error.message });
    }
  }

  /**
   * Get authors for specific branches in a repository
   */
  async getAuthorsForBranches(req, res) {
    try {
      const { repository, branches } = req.query;

      if (!repository) {
        return res.status(400).json({ message: 'Repository is required' });
      }

      if (!branches) {
        return res.status(400).json({ message: 'At least one branch is required' });
      }

      const branchesArray = Array.isArray(branches) ? branches : [branches];
      const accessToken = req.user.accessToken;
      
      const authors = await GitHubBranchService.getAuthorsForBranches({ 
        accessToken, 
        repository,
        branches: branchesArray
      });

      res.json(authors);
    } catch (error) {
      console.error('Error getting authors for branches:', error);
      res.status(500).json({ message: 'Failed to get authors for branches', error: error.message });
    }
  }
}

module.exports = new GitHubBranchController(); 

---
File: backend/controllers/GitHub/GitHubRepositoryController.js
---
const { GitHubRepositoryService, GitHubSearchService } = require('../../services/GitHub');

/**
 * Controller for handling GitHub repository-related operations
 */
class GitHubRepositoryController {
  /**
   * Get basic information about a repository
   */
  async getRepositoryInfo(req, res) {
    try {
      const { repository } = req.query;

      if (!repository) {
        return res.status(400).json({ message: 'Repository is required' });
      }

      const accessToken = req.user.accessToken;
      const repoInfo = await GitHubRepositoryService.getRepositoryInfo({
        accessToken,
        repository
      });

      res.json(repoInfo);
    } catch (error) {
      console.error('Error getting repository info:', error);
      res.status(500).json({ message: 'Failed to get repository info', error: error.message });
    }
  }

  /**
   * Get contributors for a repository
   */
  async getContributors(req, res) {
    try {
      const { repository } = req.query;

      if (!repository) {
        return res.status(400).json({ message: 'Repository is required' });
      }

      const accessToken = req.user.accessToken;
      const contributors = await GitHubRepositoryService.getContributors({ 
        accessToken, 
        repository 
      });

      res.json(contributors);
    } catch (error) {
      console.error('Error getting contributors:', error);
      res.status(500).json({ message: 'Failed to get contributors', error: error.message });
    }
  }

  /**
   * Search for repositories
   */
  async searchRepositories(req, res) {
    try {
      const { query } = req.query;

      if (!query) {
        return res.status(400).json({ message: 'Search query is required' });
      }

      const accessToken = req.user.accessToken;
      const repositories = await GitHubSearchService.searchRepositoriesByName({ 
        accessToken, 
        query 
      });

      res.json(repositories);
    } catch (error) {
      console.error('Error searching repositories:', error);
      res.status(500).json({ message: 'Failed to search repositories', error: error.message });
    }
  }
}

module.exports = new GitHubRepositoryController(); 

---
File: backend/controllers/GitHub/GitHubCommitController.js
---
const { GitHubCommitService } = require('../../services/GitHub');
const UsageStatsService = require('../../services/UsageStatsService');

/**
 * Controller for handling GitHub commit-related operations
 */
class GitHubCommitController {
  /**
   * Get commits from GitHub
   */
  async getCommits(req, res) {
    try {
      const { repository, branch, author, startDate, endDate } = req.query;

      if (!repository) {
        return res.status(400).json({ message: 'Repository is required' });
      }

      const accessToken = req.user.accessToken;
      const userId = req.user.id;
      
      const commits = await GitHubCommitService.getCommits({
        accessToken,
        repository,
        branch: branch || 'main',
        author,
        startDate: startDate ? new Date(startDate) : null,
        endDate: endDate ? new Date(endDate) : null
      });

      // No need to track commits here since we're just fetching them
      // They will be tracked when actually analyzed in report generation

      res.json(commits);
    } catch (error) {
      console.error('Error getting commits:', error);
      res.status(500).json({ message: 'Failed to get commits', error: error.message });
    }
  }

  /**
   * Get date range for branches and authors
   */
  async getDateRange(req, res) {
    try {
      const { repository, branches, authors } = req.query;

      if (!repository) {
        return res.status(400).json({ message: 'Repository is required' });
      }

      if (!branches) {
        return res.status(400).json({ message: 'At least one branch is required' });
      }

      const branchesArray = Array.isArray(branches) ? branches : [branches];
      const authorsArray = authors ? (Array.isArray(authors) ? authors : [authors]) : [];
      
      const accessToken = req.user.accessToken;
      const dateRange = await GitHubCommitService.getDateRangeForBranchesAndAuthors({ 
        accessToken, 
        repository, 
        branches: branchesArray,
        authors: authorsArray
      });

      res.json(dateRange);
    } catch (error) {
      console.error('Error getting date range:', error);
      res.status(500).json({ message: 'Failed to get date range', error: error.message });
    }
  }

  /**
   * Get commits with files/diffs based on filters
   */
  async getCommitsWithDiffs(req, res) {
    try {
      const { repository, branches, authors, startDate, endDate, includeFiles } = req.query;
      
      if (!repository || !branches) {
        return res.status(400).json({ error: 'Repository and branches are required' });
      }
      
      // Get user access token
      const accessToken = req.user.accessToken;
      const userId = req.user.id;
      
      // Parse branch names
      const branchNames = branches.split(',');
      
      // Parse author names if present
      const authorNames = authors ? authors.split(',') : [];
      
      // Call GitHub service to get commits with file diffs
      const commits = await GitHubCommitService.getCommitsWithDiffs({
        accessToken,
        repository,
        branches: branchNames,
        authors: authorNames,
        startDate: startDate ? new Date(startDate) : null,
        endDate: endDate ? new Date(endDate) : null,
        includeFiles: includeFiles === 'true'
      });
      
      // No need to track commits here since we're just fetching them
      // They will be tracked when actually analyzed in report generation

      res.json(commits);
    } catch (error) {
      console.error('Error getting commits with diffs:', error);
      res.status(500).json({ error: 'Failed to get commits' });
    }
  }
}

module.exports = new GitHubCommitController(); 

---
File: backend/controllers/Report/index.js
---
const ReportGenerationController = require('./ReportGenerationController');
const ReportViewController = require('./ReportViewController');
const ReportManagementController = require('./ReportManagementController');
const ReportCacheController = require('./ReportCacheController');

module.exports = {
  ReportGenerationController,
  ReportViewController,
  ReportManagementController,
  ReportCacheController
}; 

---
File: backend/controllers/Report/ReportManagementController.js
---
const Report = require('../../models/Report');
const s3Service = require('../../services/s3');
const reportService = require('../../services/reportService');
const { NotFoundError } = require('../../utils/errors');

/**
 * Delete a report
 */
exports.deleteReport = async (req, res) => {
  try {
    const { id } = req.params;
    const { confirmationName } = req.body;
    
    // Find the report
    const report = await reportService.getReportById(id, req.user.id);
    
    // Verify confirmation name matches
    if (!confirmationName || confirmationName !== report.name) {
      return res.status(400).json({ 
        error: 'Confirmation name does not match report name',
        reportName: report.name 
      });
    }
    
    // Delete PDF from S3 if it exists
    if (report.pdfUrl && report.pdfUrl !== 'pending') {
      try {
        await s3Service.deleteObject(report.pdfUrl);
        console.log(`Deleted PDF from S3: ${report.pdfUrl}`);
      } catch (s3Error) {
        console.error(`Error deleting PDF from S3: ${report.pdfUrl}`, s3Error);
        // Continue with report deletion even if S3 deletion fails
      }
    }
    
    // Delete report from database
    await Report.findByIdAndDelete(id);
    
    res.json({ 
      message: 'Report deleted successfully',
      reportId: id,
      reportName: report.name
    });
  } catch (error) {
    console.error('Error deleting report:', error);
    if (error instanceof NotFoundError) {
      return res.status(404).json({ error: 'Report not found' });
    }
    res.status(500).json({ error: 'Failed to delete report' });
  }
};

/**
 * Clean up invalid reports that reference missing S3 files
 */
exports.cleanupInvalidReports = async (req, res) => {
  try {
    // Get all reports for the current user
    const reports = await Report.find({ user: req.user.id });
    
    if (!reports || reports.length === 0) {
      return res.json({ message: 'No reports found to clean up', cleaned: 0 });
    }
    
    // Track cleanup statistics
    const stats = {
      checked: 0,
      pending: 0,
      invalid: 0,
      valid: 0,
      deleted: 0,
      errors: 0
    };
    
    // Check each report
    for (const report of reports) {
      stats.checked++;
      
      try {
        if (report.pdfUrl === 'pending') {
          // Report with pending status that was never completed
          stats.pending++;
          await Report.findByIdAndDelete(report.id);
          stats.deleted++;
          console.log(`Deleted pending report ${report.id}`);
        } else {
          // Check if PDF file exists in S3
          const exists = await s3Service.objectExists(report.pdfUrl);
          
          if (!exists) {
            stats.invalid++;
            await Report.findByIdAndDelete(report.id);
            stats.deleted++;
            console.log(`Deleted report ${report.id} with missing S3 file: ${report.pdfUrl}`);
          } else {
            stats.valid++;
          }
        }
      } catch (error) {
        console.error(`Error checking report ${report.id}:`, error);
        stats.errors++;
      }
    }
    
    res.json({
      message: 'Cleanup completed successfully',
      stats
    });
  } catch (error) {
    console.error('Error cleaning up reports:', error);
    res.status(500).json({ error: `Failed to clean up reports: ${error.message}` });
  }
}; 

---
File: backend/controllers/Report/ReportCacheController.js
---
const Report = require('../../models/Report');
const s3Service = require('../../services/s3');

/**
 * Get report cache statistics
 */
exports.getCacheStats = async (req, res) => {
  try {
    // Get stats for all reports
    const allReportsCount = await Report.countDocuments({});
    
    // Get total cached accesses (sum of all access counts minus the count of reports)
    const reports = await Report.find({}, 'accessCount');
    const totalAccesses = reports.reduce((sum, report) => sum + (report.accessCount || 1), 0);
    const cachedAccesses = totalAccesses - allReportsCount;
    
    // Calculate cache hit rate
    const cacheHitRate = totalAccesses > 0 ? (cachedAccesses / totalAccesses) * 100 : 0;
    
    // Get most accessed reports
    const popularReports = await Report.find({})
      .sort({ accessCount: -1 })
      .limit(5)
      .select('name repository accessCount lastAccessed');
    
    // Get most recently accessed reports
    const recentlyAccessedReports = await Report.find({})
      .sort({ lastAccessed: -1 })
      .limit(5)
      .select('name repository accessCount lastAccessed');
    
    res.json({
      totalReports: allReportsCount,
      totalAccesses,
      cachedAccesses,
      cacheHitRate: cacheHitRate.toFixed(2) + '%',
      popularReports,
      recentlyAccessedReports
    });
  } catch (error) {
    console.error('Error fetching cache stats:', error);
    res.status(500).json({ error: 'Failed to fetch cache statistics' });
  }
};

/**
 * Cleanup old/unused reports from cache
 */
exports.cleanupReportsCache = async (req, res) => {
  try {
    const { olderThan = 90, accessCountLessThan = 2 } = req.query;
    
    // Calculate cutoff date
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - parseInt(olderThan));
    
    // Find reports that meet the criteria
    const reports = await Report.find({
      lastAccessed: { $lt: cutoffDate },
      accessCount: { $lt: parseInt(accessCountLessThan) }
    });
    
    // Delete reports and their S3 objects
    let deletedCount = 0;
    let s3DeletedCount = 0;
    
    for (const report of reports) {
      try {
        // Delete from S3 if it's not 'pending'
        if (report.pdfUrl && report.pdfUrl !== 'pending') {
          await s3Service.deleteObject(report.pdfUrl);
          s3DeletedCount++;
        }
        
        // Delete the report
        await Report.findByIdAndDelete(report.id);
        deletedCount++;
      } catch (error) {
        console.error(`Error deleting report ${report.id}:`, error);
      }
    }
    
    res.json({
      message: `Deleted ${deletedCount} reports and ${s3DeletedCount} S3 objects`,
      deletedCount,
      s3DeletedCount
    });
  } catch (error) {
    console.error('Error cleaning up reports cache:', error);
    res.status(500).json({ error: 'Failed to clean up reports cache' });
  }
}; 

---
File: backend/controllers/Report/ReportGenerationController.js
---
const Report = require('../../models/Report');
const githubService = require('../../services/github');
const openaiService = require('../../services/openai');
const pdfService = require('../../services/pdf');
const s3Service = require('../../services/s3');
const reportService = require('../../services/reportService');
const UsageStatsService = require('../../services/usageStats');
const User = require('../../models/User');
const { NotFoundError, ValidationError } = require('../../utils/errors');

/**
 * Generate a report based on selected commit IDs
 */
exports.generateReport = async (req, res) => {
  try {
    const { repository, branches, authors, startDate, endDate, title, includeCode, commitIds } = req.body;
    
    if (!repository || !commitIds || !Array.isArray(commitIds) || commitIds.length === 0) {
      return res.status(400).json({ error: 'Invalid request parameters' });
    }
    
    // Get user access token
    const accessToken = req.user.accessToken;
    const userId = req.user.id;
    
    // Track if this is a cached report or newly generated
    let isCachedReport = false;
    
    // Check if user has reached their report limit
    const hasReachedLimit = await UsageStatsService.hasReachedReportLimit(userId);
    if (hasReachedLimit) {
      return res.status(403).json({ 
        error: 'Monthly report generation limit reached',
        limitReached: true
      });
    }
    
    // Fetch commit details
    const commits = await githubService.getCommitsByIds({
      accessToken,
      repository,
      commitIds
    });
    
    if (!commits || commits.length === 0) {
      return res.status(404).json({ error: 'No commits found for the specified IDs' });
    }
    
    // Get user's plan limits
    const user = await User.findById(userId).populate('plan');
    if (!user || !user.plan) {
      return res.status(500).json({ error: 'User plan not found' });
    }
    
    // Get unique commit count
    const uniqueCommits = new Set(commits.map(commit => commit.commitId || commit.sha));
    const uniqueCommitCount = uniqueCommits.size;
    
    // Determine report type based on unique commit count
    const reportType = uniqueCommitCount <= user.plan.limits.commitsPerStandardReport ? 'standard' : 'large';
    
    // Check if commit count exceeds the limit for the report type
    if (reportType === 'large' && uniqueCommitCount > user.plan.limits.commitsPerLargeReport) {
      return res.status(400).json({
        error: `Report exceeds maximum commits allowed for large reports (${user.plan.limits.commitsPerLargeReport} commits)`,
        limit: user.plan.limits.commitsPerLargeReport
      });
    }
    
    // Generate a hash to uniquely identify this set of commits
    const commitsHash = reportService.generateCommitsHash(commits);
    
    // Check if a report with this exact set of commits already exists
    const existingReport = await reportService.findReportByCommitsHash(commitsHash);
    
    if (existingReport) {
      // Update the access stats and return existing report
      await reportService.updateReportAccessStats(existingReport);
      isCachedReport = true;
      return res.json({
        message: 'Existing report found with identical commits',
        reportId: existingReport.id,
        cached: true
      });
    }
    
    // Initialize token tracking
    let inputTokenCount = 0;
    let outputTokenCount = 0;
    let modelName = 'gpt-4';
    
    // Generate report content
    const reportContent = await openaiService.generateReportFromCommits({
      repository,
      commits,
      title,
      includeCode: includeCode || false,
      branchInfo: branches?.join(', '),
      authorInfo: authors?.join(', '),
      trackTokens: true
    });
    
    // Extract token usage
    if (reportContent.usage) {
      inputTokenCount = reportContent.usage.promptTokens || 0;
      outputTokenCount = reportContent.usage.completionTokens || 0;
      modelName = reportContent.model || 'gpt-4';
    }
    
    // Determine content for PDF
    const reportContentText = typeof reportContent === 'string' ? 
      reportContent : 
      (reportContent.content || JSON.stringify(reportContent));
    
    // Create report in database
    const report = await createReport({
      userId: req.user.id,
      title,
      repository,
      branches,
      authors,
      startDate,
      endDate,
      commits,
      commitsHash
    });
    
    try {
      // Generate PDF in background
      const jobInfo = await pdfService.generatePDF({
        title: report.name,
        content: reportContentText,
        repository: report.repository,
        startDate: report.startDate,
        endDate: report.endDate
      }, report.id);
      
      // Update report with job ID
      report.pdfJobId = jobInfo.id;
      await report.save();
      
      // Track usage statistics if not cached
      if (!isCachedReport) {
        await trackReportUsage({
          userId,
          reportType,
          uniqueCommitCount: uniqueCommits.size,
          inputTokenCount,
          outputTokenCount,
          modelName
        });
      }
      
      return res.json({
        id: report.id,
        title: report.name,
        repository,
        createdAt: report.createdAt,
        pdfUrl: report.pdfUrl,
        pdfJobId: report.pdfJobId,
        pdfStatus: 'pending'
      });
      
    } catch (error) {
      await handleReportGenerationError(error, report);
      throw error;
    }
  } catch (error) {
    console.error('Error generating report:', error);
    res.status(500).json({ error: 'Failed to generate report' });
  }
};

/**
 * Get commit information for report generation
 */
exports.getCommitInfo = async (req, res) => {
  try {
    const { repository, commitIds } = req.body;

    if (!repository || !commitIds || !Array.isArray(commitIds) || commitIds.length === 0) {
      return res.status(400).json({ error: 'Repository and commit IDs are required' });
    }

    const accessToken = req.user.accessToken;
    const commits = await githubService.getCommitsByIds({
      accessToken,
      repository,
      commitIds
    });

    // Get branch information for each commit
    const commitsWithBranches = await Promise.all(commits.map(async (commit) => {
      try {
        const branches = await githubService.getBranchesForCommit({
          accessToken,
          repository,
          commitSha: commit.sha
        });
        
        return {
          ...commit,
          branch: branches.length > 0 ? branches[0] : undefined
        };
      } catch (error) {
        console.error(`Error getting branches for commit ${commit.sha}:`, error);
        return commit;
      }
    }));

    return res.json({ commits: commitsWithBranches });
  } catch (error) {
    console.error('Error getting commit info:', error);
    return res.status(500).json({ error: 'Failed to get commit information' });
  }
};

/**
 * Get PDF generation status
 */
exports.getPdfStatus = async (req, res) => {
  try {
    const report = await reportService.getReportById(req.params.id, req.user.id);
    
    // If PDF is ready
    if (report.pdfUrl && report.pdfUrl !== 'pending' && report.pdfUrl !== 'failed') {
      const urls = await reportService.generateReportUrls(report);
      return res.json({
        status: 'completed',
        progress: 100,
        viewUrl: urls.viewUrl,
        downloadUrl: urls.downloadUrl
      });
    }
    
    // If PDF generation failed
    if (report.pdfUrl === 'failed') {
      return res.json({
        status: 'failed',
        error: report.pdfError || 'PDF generation failed'
      });
    }
    
    // If job is in progress
    if (report.pdfJobId) {
      const jobStatus = await pdfService.getPdfJobStatus(report.pdfJobId);
      return res.json({
        status: jobStatus.status,
        progress: jobStatus.progress,
        jobId: jobStatus.id
      });
    }
    
    // Default pending status
    return res.json({
      status: 'pending',
      progress: 0
    });
  } catch (error) {
    console.error('Error getting PDF status:', error);
    if (error instanceof NotFoundError) {
      return res.status(404).json({ message: 'Report not found' });
    }
    res.status(500).json({ message: 'Error getting PDF status', error: error.message });
  }
};

// Helper functions

async function createReport({ userId, title, repository, branches, authors, startDate, endDate, commits, commitsHash }) {
  // Extract authors from commits
  const authorsFromCommits = commits
    .filter(c => c.author?.name || c.commit?.author?.name)
    .map(c => c.author?.name || c.commit?.author?.name);
  
  const uniqueAuthors = [...new Set(authorsFromCommits)];
  
  const report = new Report({
    user: userId,
    name: title,
    repository,
    branch: branches?.length > 0 ? branches.join(', ') : 'All branches',
    author: uniqueAuthors.length > 0 ? uniqueAuthors.join(', ') : (authors?.join(', ') || 'All authors'),
    startDate: new Date(startDate),
    endDate: new Date(endDate),
    commits: commits.map(commit => ({
      commitId: commit.sha,
      message: commit.commit?.message || commit.message || 'No message',
      author: commit.author?.login || commit.author?.name || commit.commit?.author?.name || 'Unknown',
      date: commit.commit?.author?.date || commit.date || new Date(),
      summary: commit.summary || ''
    })),
    pdfUrl: 'pending',
    commitsHash,
    accessCount: 1,
    lastAccessed: new Date()
  });
  
  await report.save();
  return report;
}

async function trackReportUsage({ userId, reportType, uniqueCommitCount, inputTokenCount, outputTokenCount, modelName }) {
  // Track report generation
  await UsageStatsService.trackReportGeneration(userId, reportType);
  
  // Track commit analysis
  await UsageStatsService.trackCommitAnalysis(
    userId,
    uniqueCommitCount,
    uniqueCommitCount
  );
  
  // Track token usage
  const tokenCosts = {
    'gpt-4': { input: 0.000002027, output: 0.00001011 },
    'gpt-4-mini': { input: 0.000000156, output: 0.000000606 }
  };
  
  const { input: inputCost, output: outputCost } = tokenCosts[modelName] || tokenCosts['gpt-4-mini'];
  const estimatedCost = (inputTokenCount * inputCost) + (outputTokenCount * outputCost);
  
  await UsageStatsService.trackTokenUsage(
    userId,
    inputTokenCount,
    outputTokenCount,
    modelName,
    estimatedCost,
    inputTokenCount * inputCost,
    outputTokenCount * outputCost
  );
}

async function handleReportGenerationError(error, report) {
  console.error('Error in PDF generation or S3 upload:', error);
  
  if (report.id) {
    try {
      const existingReport = await Report.findById(report.id);
      if (existingReport) {
        if (existingReport.pdfUrl === 'pending') {
          await Report.findByIdAndDelete(report.id);
        } else {
          const pdfExists = await s3Service.objectExists(existingReport.pdfUrl);
          if (!pdfExists) {
            await Report.findByIdAndDelete(report.id);
          }
        }
      }
    } catch (cleanupError) {
      console.error('Error cleaning up failed report:', cleanupError);
    }
  }
} 

---
File: backend/controllers/Report/ReportViewController.js
---
const Report = require('../../models/Report');
const reportService = require('../../services/reportService');
const { NotFoundError } = require('../../utils/errors');

/**
 * Get all reports for the current user
 */
exports.getReports = async (req, res) => {
  try {
    const reports = await Report.find({ user: req.user.id }).sort({ createdAt: -1 });
    
    // Generate download URLs for each report
    const reportsWithUrls = await Promise.all(
      reports.map(async (report) => {
        let downloadUrl = '';
        
        if (report.pdfUrl && report.pdfUrl !== 'pending' && report.pdfUrl !== 'failed') {
          try {
            downloadUrl = await reportService.generateReportUrls(report);
          } catch (error) {
            console.error(`Error getting download URL for report ${report.id}:`, error);
          }
        }
        
        return reportService.formatReportResponse(report, { downloadUrl });
      })
    );
    
    res.json(reportsWithUrls);
  } catch (error) {
    console.error('Error fetching reports:', error);
    res.status(500).json({ error: 'Failed to fetch reports' });
  }
};

/**
 * Get a specific report by ID
 */
exports.getReportById = async (req, res) => {
  try {
    const report = await reportService.getReportById(req.params.id, req.user.id);
    
    // Update access stats
    await reportService.updateReportAccessStats(report);
    
    // Generate pre-signed URLs for viewing and downloading
    const urls = await reportService.generateReportUrls(report);
    
    // Return formatted report
    res.json(reportService.formatReportResponse(report, urls));
  } catch (error) {
    console.error('Error fetching report:', error);
    if (error instanceof NotFoundError) {
      return res.status(404).json({ message: 'Report not found' });
    }
    res.status(500).json({ message: 'Error fetching report', error: error.message });
  }
}; 

---
File: BIBLE.md
---
## Claude Bible

### GitStatus Code Standards Bible

1. **Architecture Principles**
   - Follow clear separation of concerns between controllers, services, and models
   - Controllers handle request/response, services contain business logic, models define data structure
   - Keep components and functions small and focused on a single responsibility
   - Limit component files to 300 lines maximum; extract larger components into smaller ones
   - When splitting large files (services, components, routes, etc.) into multiple focused files, organize them in a dedicated folder with an index.js that re-exports the components
   - Import specific service modules directly where needed rather than through aggregating services, promoting clear dependencies and better modularity
   - When refactoring, update all existing references to use the new structure directly, rather than creating backward compatibility wrappers
   - Avoid circular dependencies by carefully planning the service hierarchy
   - Never implement controller logic directly in route files - always create a dedicated controller file and import it in the route file, even for simple endpoints
   - Route files should only define routes and connect them to controller methods, never handle business logic or data manipulation
   - Maintain a clear component organization structure:
     - **Components**: Top-level components that represent entire routes/screens in the application
     - **PagePartials**: Smaller, reusable UI elements that compose the Components
     - **Modals**: Dialog components that appear over the main UI
     - Group related components in feature-based folders (e.g., `components/ViewReport/`)
     - Include an index.js in feature folders to re-export components for easier importing
   - Use a clear nested structure for component organization:
     - For PagePartials related to a specific parent component, use nested folders: `PagePartials/[ParentComponent]/[ChildComponent]/`
     - Name nested component files with both parent and child component names: `[ParentComponent][ChildComponent]Component.{js,jsx,css}`
     - Example: `PagePartials/ViewReport/CommitList/ViewReportCommitListComponent.{js,jsx,css}`
   - Separate logic from presentation in components:
     - Use the folder structure: `/ComponentName/ComponentName.js` (logic), `/ComponentName/ComponentName.jsx` (template), `/ComponentName/ComponentName.css` (styles), `/ComponentName/index.js` (export)
     - Keep business logic (state management, data fetching, event handlers) in .js files
     - Keep presentation (JSX markup) in .jsx files
     - Keep styles in separate CSS files, not inline styles or CSS-in-JS
     - Use className for styling instead of Material-UI's sx prop when possible

2. **Naming Conventions**
   - Use descriptive, consistent naming throughout the codebase
   - React components: PascalCase (e.g., `CommitList.js`)
   - Service files: PascalCase (e.g., `GitHubService.js`)
   - Route files: PascalCase (e.g., `AuthRoutes.js`)
   - JavaScript files in utils/scripts/templates: camelCase (e.g., `errorHandler.js`)
   - Functions and variables: camelCase
   - Constants: UPPER_SNAKE_CASE
   - MongoDB models: PascalCase singular nouns (e.g., `User.js`)
   - Folders for grouped services/components: PascalCase (e.g., `GitHub/`, `UserProfile/`)
   - Always include provider/source prefix in file names (e.g., `GitHubRepositoryController.js`, `StripePaymentService.js`) even when inside a folder with the same prefix, to maintain clarity when the files are imported elsewhere
   - File names should indicate their type based on their purpose:
     - Components: suffix with "Component" (e.g., `DashboardComponent.js`, `LoginComponent.js`)
     - PagePartials: suffix with "Partial" (e.g., `HeaderPartial.js`, `FooterPartial.js`)
     - Nested PagePartials: prefix with parent component name and suffix with "Component" (e.g., `ViewReportCommitListComponent.js`)
     - Context providers: suffix with "Context" (e.g., `AuthContext.js`, `ThemeContext.js`)
     - Services: suffix with "Service" (e.g., `APIService.js`, `PDFService.js`)
     - Controllers: suffix with "Controller" (e.g., `UserController.js`, `ReportController.js`)
     - Routes: suffix with "Routes" (e.g., `AuthRoutes.js`, `AdminRoutes.js`)
     - Models: no suffix, use singular nouns in PascalCase (e.g., `User.js`, `Report.js`)
     - Utilities: no suffix, use camelCase (e.g., `errorHandler.js`, `dateFormatter.js`)
   - CSS class names: use kebab-case (e.g., `view-report-container`, `loading-spinner`)

3. **State Management**
   - Use React Context for global state that changes infrequently
   - Use local component state for UI-specific state
   - Avoid prop drilling more than 2 levels deep
   - Extract complex state logic into custom hooks

4. **API and Data Handling**
   - Use service modules to encapsulate all API calls
   - Implement consistent error handling for all API requests
   - Cache API responses where appropriate
   - Use loading and error states for all asynchronous operations

5. **Security Practices**
   - Never store sensitive information in client-side code
   - Validate all user input on both client and server
   - Use environment variables for all configuration
   - Implement proper authentication checks on all protected routes

6. **Performance Considerations**
   - Implement pagination for all list views
   - Use memoization for expensive calculations
   - Optimize MongoDB queries with proper indexes
   - Implement request throttling and rate limiting

7. **Error Handling**
   - Use custom error classes from `utils/errors.js` for all error scenarios
   - In services: throw specific error types (e.g., NotFoundError, ValidationError)
   - In controllers: use try/catch and let the global error handler format responses
   - In frontend: use the errorHandler utility to process and display errors
   - Include relevant details in errors for debugging but sanitize sensitive information
   - Always log errors on the server with appropriate context
   - Use consistent error response format for all API endpoints
   - Return appropriate HTTP status codes that match the error type

8. **Code Organization**
   - Group related functionality in the same directory
   - Use index files to simplify imports
   - Keep configuration separate from business logic
   - Use consistent file structure across similar components
   - Follow this folder structure for components and pages:
     ```
     ComponentName/
     ├── ComponentName{Page/Component}.js     # Business logic
     ├── ComponentName{Page/Component}.jsx    # JSX template 
     ├── ComponentName{Page/Component}.css    # Component styles
     ├── index.js             # Re-exports the component
     └── [other related files]
     ```

9. **Documentation**
   - Document all non-obvious code with comments
   - Keep README and setup guides up to date
   - Document API endpoints with examples
   - Include JSDoc comments for functions with complex parameters

10. **Testing**
    - Write tests for critical business logic
    - Implement integration tests for API endpoints
    - Use snapshot testing for UI components
    - Maintain high test coverage for core functionality

11. **Styling**
    - Keep styles in separate CSS files, not inline or CSS-in-JS
    - Use consistent classNames following kebab-case convention
    - Avoid deeply nested CSS selectors (max 3 levels)
    - Use CSS variables for theme colors and shared values
    - Centralize theme configuration in dedicated files

Claude must update APP_DOCS.md after every change to the codebase to ensure documentation remains current and accurate.



---
File: APP_DOCS.md
---
## Application Docs

### GitStatus Application Overview

GitStatus is a full-stack application that analyzes GitHub commit history to generate concise, AI-powered reports of actual work accomplished. It helps developers and project managers track and report on progress by analyzing commit diffs and providing professional summaries.

#### Core Features

- GitHub OAuth integration for secure repository access
- Repository, branch, and commit selection
- AI-powered commit analysis and report generation
- PDF report generation and management
- Usage analytics and tracking
- Admin dashboard for system monitoring

### System Architecture

The application follows a client-server architecture:

- **Frontend**: React.js application with Material-UI
- **Backend**: Node.js with Express.js
- **Database**: MongoDB for data storage
- **Queue System**: Bull with Redis for background job processing
- **External Services**: GitHub API, OpenAI API, AWS S3

### Frontend Components

#### Frontend Organization

The frontend codebase is organized with a clear component structure:

1. **Components (`src/components/`)**: 
   - Top-level components that represent entire routes/screens in the application
   - Generally contain the main layout and composition of smaller elements
   - Handle state, data fetching, and routing logic
   - Named with the "Component" suffix (e.g., `DashboardComponent.js`, `LoginComponent.js`)
   - Examples: `LoginComponent`, `DashboardComponent`, `ViewReportComponent`
   - All components representing full screens/pages are placed directly in the components directory in their own feature folder (e.g., `components/Dashboard/`)

2. **PagePartials (`src/components/PagePartials/`)**: 
   - Smaller, reusable UI elements that compose the main Components
   - Focus on specific UI functionality and presentation
   - Generally receive data and callbacks as props
   - Named with the "Partial" suffix (e.g., `HeaderPartial.js`, `FooterPartial.js`)
   - Examples: `LayoutPartial`, `CommitListPartial`, `ReportHeaderPartial`

3. **Nested PagePartials**: 
   - PagePartials that belong to a specific parent component
   - Organized in subdirectories within PagePartials based on their parent component:
     ```
     PagePartials/
     ├── ViewReport/              # For ViewReport-specific partials
     │   ├── CommitList/          # A specific ViewReport partial
     │   │   ├── ViewReportCommitListComponent.js
     │   │   ├── ViewReportCommitListComponent.jsx
     │   │   ├── ViewReportCommitListComponent.css
     │   │   └── index.js
     │   └── ReportHeader/        # Another ViewReport partial
     │       ├── ViewReportReportHeaderComponent.js
     │       └── ...
     └── Dashboard/               # For Dashboard-specific partials
         └── ...
     ```
   - Named by combining the parent component name with the partial name and "Component" suffix
   - Example: `ViewReportCommitListComponent.js` for a CommitList partial used in the ViewReport component

4. **Modals (`src/components/Modals/`)**: 
   - Dialog components that appear over the main UI
   - Named with the "Modal" suffix (e.g., `CreateReportModal.js`)
   - Examples: `CreateReportModal`, `ViewCommitsModal`

5. **Component Organization Strategy**:
   - When a component becomes too large (>300 lines), it should be split into smaller focused components
   - Related components are grouped in feature-based folders (e.g., `components/ViewReport/`)
   - Each feature folder includes an `index.js` file that re-exports its components for easier importing
   - Complex UI elements are composed from multiple smaller PagePartials
   - This approach improves maintainability, readability, and allows for component reuse

6. **Component Structure**:
   - Each component has its own folder containing separate files for logic, presentation, and styles
   - The structure follows this pattern:
     ```
     ComponentName/
     ├── ComponentName.js     # Business logic (state, data fetching, event handlers)
     ├── ComponentName.jsx    # JSX template (presentation layer)
     ├── ComponentName.css    # Component styles
     ├── index.js             # Re-exports the component for easier imports
     └── [other related files]
     ```
   - This separation of concerns makes the codebase more maintainable and testable
   - Example: `ViewReport/ViewReportComponent.js` contains the business logic, while `ViewReport/ViewReportComponent.jsx` contains the template/JSX markup, and `ViewReport/ViewReportComponent.css` contains the styles

7. **Styling Approach**:
   - CSS is kept in separate files rather than inline styles or CSS-in-JS
   - Class names follow kebab-case convention (e.g., `view-report-container`)
   - Material-UI theme configuration is centralized in `styles/theme.js`
   - CSS variables are used for shared values and theming
   - CSS selectors are kept flat (max 3 levels of nesting) for better performance

#### File Naming Conventions

To maintain consistency and clarity across the codebase, we follow these naming conventions:

1. **Components**: Suffix with "Component" (e.g., `DashboardComponent.js`, `LoginComponent.js`)
2. **PagePartials**: Suffix with "Partial" (e.g., `HeaderPartial.js`, `FooterPartial.js`)
3. **Nested PagePartials**: Prefix with parent component name and suffix with "Component" (e.g., `ViewReportCommitListComponent.js`)
4. **Modals**: Suffix with "Modal" (e.g., `CreateReportModal.js`, `ViewCommitsModal.js`) - Modals are special components that use the "Modal" suffix instead of "Component"
5. **Context Providers**: Suffix with "Context" (e.g., `AuthContext.js`, `ThemeContext.js`)
6. **Services**: Suffix with "Service" (e.g., `APIService.js`, `PDFService.js`)

These conventions make it immediately clear what type of file you're working with, especially when imported from other locations in the codebase.

#### Core Components

1. **AuthContext** (`src/contexts/AuthContext.js`)
   - Manages user authentication state
   - Provides login/logout functionality
   - Handles session persistence

2. **ModalContext** (`src/contexts/ModalContext.js`)
   - Manages modal state across the application
   - Coordinates data flow between modals
   - Provides modal open/close functionality

3. **LayoutPartial** (`src/components/PagePartials/LayoutPartial.js`)
   - Main application layout with navigation
   - Responsive design with mobile support
   - Handles theme and styling

#### Main Application Components

1. **DashboardComponent** (`src/components/Dashboard/DashboardComponent.js`)
   - Displays user's generated reports
   - Provides report management functionality
   - Entry point for creating new reports

2. **CreateReportComponent** (via modals)
   - **CreateReportModal** (`src/components/Modals/CreateReportModal.js`)
     - Repository and branch selection
     - Date range and author filtering
     - Report configuration
   - **ViewCommitsModal** (`src/components/Modals/ViewCommitsModal.js`)
     - Commit selection and preview
     - Diff viewing functionality
     - Report generation trigger

3. **ViewReportComponent** (`src/components/ViewReport/ViewReportComponent.js`)
   - Displays generated report details
   - Shows commit list and summaries
   - Provides PDF preview and download
   - Follows the component structure with separated logic and presentation:
     - `ViewReportComponent.js` - Contains business logic (data fetching, state management)
     - `ViewReportComponent.jsx` - Contains the template/JSX markup
     - `ViewReportComponent.css` - Contains styles
     - `index.js` - Re-exports the component

4. **AnalyticsDashboardComponent** (`src/components/AnalyticsDashboard/AnalyticsDashboardComponent.js`)
   - Displays usage statistics
   - Shows limits and quotas
   - Visualizes report generation trends

5. **AdminDashboardComponent** (`src/components/AdminDashboard/AdminDashboardComponent.js`)
   - User management functionality
   - System-wide analytics
   - Plan management

### Backend Structure

#### API Routes

1. **Authentication** (`/api/auth`)
   - `GET /api/auth/github`: Initiate GitHub OAuth flow
   - `GET /api/auth/github/callback`: Handle OAuth callback
   - `GET /api/auth/me`: Get current user info
   - `GET /api/auth/logout`: Log out current user

2. **Reports** (`/api/reports`)
   The reports functionality is split into focused controllers for better maintainability:

   **Report Generation** (`ReportGenerationController`)
   - `POST /api/reports`: Generate a new report
   - `POST /api/reports/commit-info`: Get commit information for report generation
   - `GET /api/reports/:id/pdf-status`: Get PDF generation status
   
   **Report Viewing** (`ReportViewController`)
   - `GET /api/reports`: Get user's reports
   - `GET /api/reports/:id`: Get a specific report
   
   **Report Management** (`ReportManagementController`)
   - `DELETE /api/reports/:id`: Delete a report
   - `POST /api/reports/cleanup`: Clean up invalid reports
   
   **Report Cache** (`ReportCacheController`)
   - `GET /api/reports/cache/stats`: Get cache statistics
   - `POST /api/reports/cache/cleanup`: Clean up old reports

3. **Usage Stats** (`/api/usage-stats`)
   - `GET /api/usage-stats/user`: Get user usage statistics
   - `GET /api/usage-stats/check-limit`: Check usage limits
   - `GET /api/usage-stats/admin`: Get admin analytics

4. **Commits** (`/api/commits`)
   - `GET /api/commits`: Get commits with filtering
   - `GET /api/commits/repository`: Get repository info
   - `GET /api/commits/branches`: Get repository branches
   - `GET /api/commits/with-diffs`: Get commits with file diffs
   - `GET /api/commits/search-repositories`: Search repositories
   - `GET /api/commits/branch-authors`: Get authors for branches
   - `GET /api/commits/date-range`: Get commit date range

5. **Admin** (`/api/admin`)
   - `GET /api/admin/users`: Get all users
   - `PUT /api/admin/users/:userId/role`: Update user role
   - `GET /api/admin/analytics`: Get system analytics

6. **Plans** (`/api/plans`)
   - `GET /api/plans`: Get all plans
   - `PUT /api/plans/:planId/limits`: Update plan limits

#### Database Models

1. **User** (`models/User.js`)
   - Stores user information and GitHub credentials
   - Tracks user role and plan

2. **Report** (`models/Report.js`)
   - Stores generated reports
   - Contains commit information and metadata
   - Tracks PDF location and access statistics
   - Includes job status tracking fields for background processing
   - See `docs/DATABASE_INDEXES.md` for details on performance optimization

3. **CommitSummary** (`models/CommitSummary.js`)
   - Caches AI-generated commit summaries
   - Improves performance by avoiding redundant analysis

4. **Plan** (`models/Plan.js`)
   - Defines available plans and their limits
   - Used for enforcing usage restrictions

5. **UsageStats** (`models/UsageStats.js`)
   - Tracks detailed usage statistics
   - Stores monthly report and token usage

### Data Flow

1. **Report Generation Flow**
   1. User selects repository, branches, and filters in CreateReportModal
   2. Backend fetches commits from GitHub API
   3. User selects specific commits in ViewCommitsModal
   4. Backend analyzes commits with OpenAI
   5. Backend submits PDF generation to the job queue and returns immediately with a pending status
   6. Bull worker processes the PDF generation job in the background
   7. When complete, the PDF is uploaded to S3 and the report is updated
   8. Frontend polls for job status and displays the report when ready

2. **Authentication Flow**
   1. User clicks "Login with GitHub" button
   2. Backend initiates OAuth flow with GitHub
   3. GitHub redirects back to application with authorization code
   4. Backend exchanges code for access token
   5. Backend creates or updates user in database
   6. Frontend receives authentication status and displays dashboard

3. **Usage Tracking Flow**
   1. User performs actions (generates reports, analyzes commits)
   2. Backend tracks usage in UsageStats collection
   3. Frontend displays usage statistics in AnalyticsDashboardComponent
   4. Admin can view system-wide statistics in AdminDashboardComponent

### Integration Points

1. **GitHub API**: Repository and commit data retrieval
2. **OpenAI API**: Commit analysis and report generation
3. **AWS S3**: PDF storage and retrieval
4. **MongoDB**: Data persistence and retrieval

### Security Features

1. **CSRF Protection** (`docs/CSRF_PROTECTION.md`)
   - Token-based protection for state-changing operations
   - Selective application for POST, PUT, DELETE, and PATCH methods
   - Frontend utilities for working with CSRF tokens

2. **Input Validation** (`docs/INPUT_VALIDATION.md`)
   - Comprehensive validation for all API endpoints
   - Centralized validation rules with express-validator
   - Global request sanitization
   - Detailed validation error reporting

3. **Authentication Security**
   - OAuth 2.0 integration with GitHub
   - HTTP-only, secure session cookies
   - Role-based access control

4. **API Security**
   - Rate limiting to prevent abuse
   - Helmet.js for security headers
   - Input validation and sanitization

### Backend Components

#### Services

1. **GitHub Services** (`services/GitHub/`)
   GitHub functionality is organized into a folder with multiple specialized services:
   
   - `GitHubRepositoryService.js` - Handles repository-related operations
   - `GitHubCommitService.js` - Handles commit-related operations
   - `GitHubBranchService.js` - Handles branch-related operations
   - `GitHubSearchService.js` - Handles repository search operations
   - `index.js` - Exports all services for convenient importing
   
   Key functions across these services include:
   - Repository information retrieval and contributor listing
   - Commit analysis, filtering, and diff handling
   - Branch listing and author tracking
   - Repository search functionality
   - Date range analysis for commits
   
   These services are imported directly where needed, rather than through a unified service,
   promoting better modularity and clearer dependencies.

2. **OpenAI Service** (`services/OpenAIService.js`)
   - Analyzes commit data using OpenAI models
   - Generates summaries and reports
   - Provides caching mechanisms for AI responses

3. **PDF Service** (`services/PDFService.js`)
   - Handles PDF generation using Puppeteer
   - Converts Markdown to properly formatted PDFs
   - Interfaces with the job queue for background processing

4. **Queue Service** (`services/QueueService.js`)
   - Manages background job processing with Bull
   - Handles PDF generation jobs
   - Provides job status tracking and error handling
   - Implements automatic job cleanup

5. **S3 Service** (`services/S3Service.js`)
   - Manages file storage in AWS S3
   - Handles PDF upload and retrieval
   - Generates pre-signed URLs for secure access

#### Controllers

1. **GitHub Controllers** (`controllers/GitHub/`)
   
   GitHub-related functionality is organized into specialized controllers that mirror the service structure.
   These controllers are imported directly in route files, maintaining clean dependencies:

   a. **GitHubRepositoryController**
   - Handles repository information and search
   - Uses GitHubRepositoryService and GitHubSearchService
   - Key endpoints:
     - `getRepositoryInfo`: Fetches repository details
     - `getContributors`: Lists repository contributors
     - `searchRepositories`: Searches for repositories

   b. **GitHubBranchController**
   - Handles branch-related operations
   - Uses GitHubBranchService
   - Key endpoints:
     - `getBranches`: Lists branches in a repository
     - `getAuthorsForBranches`: Gets authors who contributed to specific branches

   c. **GitHubCommitController**
   - Handles commit-related operations
   - Uses GitHubCommitService
   - Key endpoints:
     - `getCommits`: Fetches commits from a repository
     - `getDateRange`: Gets first and last commit dates
     - `getCommitsWithDiffs`: Gets commits with their diffs

2. **Report Controllers** (`controllers/Report/`)
   
   The report functionality is split into four focused controllers:

   a. **ReportGenerationController**
   - Handles report creation and PDF generation
   - Manages commit analysis and content generation
   - Tracks usage statistics and limits
   - Key functions:
     - `generateReport`: Creates new reports from commits
     - `getCommitInfo`: Retrieves commit details with branch info
     - `getPdfStatus`: Tracks PDF generation progress

   b. **ReportViewController**
   - Handles report retrieval and viewing
   - Manages report access statistics
   - Key functions:
     - `getReports`: Lists all user reports
     - `getReportById`: Retrieves specific report details

   c. **ReportManagementController**
   - Handles report lifecycle management
   - Manages cleanup of invalid reports
   - Key functions:
     - `deleteReport`: Removes reports and associated files
     - `cleanupInvalidReports`: Cleans up reports with missing files

   d. **ReportCacheController**
   - Handles report caching and statistics
   - Manages cleanup of old/unused reports
   - Key functions:
     - `getCacheStats`: Retrieves caching statistics
     - `cleanupReportsCache`: Removes old cached reports

2. **Authentication Controller** (`controllers/auth.js`)
   - Handles user authentication
   - Manages GitHub OAuth flow
   - Maintains user sessions

### Error Handling System

The application implements a standardized error handling system to ensure consistent error responses across all API endpoints and improved debugging capabilities.

#### Backend Error Handling

1. **Custom Error Classes** (`utils/errors.js`)
   - `ApplicationError`: Base error class with standardized properties
   - `NotFoundError`: For resources that don't exist (404)
   - `ValidationError`: For invalid user input (400)
   - `AuthenticationError`: For authentication issues (401)
   - `AuthorizationError`: For permission issues (403)
   - `ExternalServiceError`: For failures in external services (502)
   - `RateLimitError`: For rate limit exceeded errors (429)
   - `DatabaseError`: For database operation failures (500)
   - `PdfGenerationError`: For PDF generation failures (500)
   - `NotImplementedError`: For unimplemented features (501)

2. **Global Error Handler** (`middleware/errorHandler.js`)
   - Catches all errors thrown in the application
   - Converts errors to the standardized format
   - Logs detailed error information for debugging
   - Returns consistent JSON responses to clients
   - Includes appropriate HTTP status codes

3. **Error Response Format**
   ```json
   {
     "status": "error",
     "error": {
       "code": "ERROR_CODE",
       "message": "Human-readable error message",
       "details": ["Additional error details if applicable"]
     }
   }
   ```

#### Frontend Error Handling

1. **Error Handling Utilities** (`utils/errorHandler.js`)
   - Parses API error responses into a consistent format
   - Provides helper functions for common error scenarios
   - Maps backend error codes to frontend error types
   - Handles authentication redirects automatically

2. **API Service Integration**
   - Centralizes error handling in API calls
   - Uses axios interceptors for consistent error processing
   - Provides standardized error objects to components

3. **Component Error Handling**
   - Components display user-friendly error messages
   - Uses structured approach to handle different error types
   - Implements appropriate UI for different error scenarios

#### Error Handling Best Practices

1. **Service Layer**
   - Throw specific error types based on the scenario
   - Include relevant context in error messages
   - Document expected error types in JSDoc comments

2. **Controller Layer**
   - Use try/catch blocks and let errors propagate to the global handler
   - Avoid handling errors directly unless specific logic is required
   - Do not mix error handling patterns (throw vs return)

3. **Frontend Components**
   - Use the errorHandler utility for all API error handling
   - Display appropriate UI feedback based on error type
   - Handle authentication and validation errors specifically

This documentation provides a high-level overview of the GitStatus application architecture and functionality. For detailed implementation information, refer to the specific files and components mentioned above.



---

### Instructions
- Summarize the codebase structure (e.g., key directories, file types).
- Estimate the total lines of code (excluding comments and blank lines if possible).
- Note: This is a sample run to calibrate token usage—keep the response concise.
